; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	C:\Users\Michael McNally\source\repos\Final Proj\src\mainsrc\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?lightPosition@@3PAMA				; lightPosition
PUBLIC	?surfaceNormImg@@3PAVSTImage@@A			; surfaceNormImg
PUBLIC	?surfaceNormTex@@3PAVSTTexture@@A		; surfaceNormTex
PUBLIC	?surfaceDisplaceImg@@3PAVSTImage@@A		; surfaceDisplaceImg
PUBLIC	?surfaceDisplaceTex@@3PAVSTTexture@@A		; surfaceDisplaceTex
PUBLIC	?surfaceColorImg@@3PAVSTImage@@A		; surfaceColorImg
PUBLIC	?surfaceColorTex@@3PAVSTTexture@@A		; surfaceColorTex
PUBLIC	?shader@@3PAVSTShaderProgram@@A			; shader
PUBLIC	?gPreviousMouseX@@3HA				; gPreviousMouseX
PUBLIC	?gPreviousMouseY@@3HA				; gPreviousMouseY
PUBLIC	?gMouseButton@@3HA				; gMouseButton
PUBLIC	?smooth@@3_NA					; smooth
PUBLIC	?textureType@@3W4TextureType@@A			; textureType
PUBLIC	?proxyType@@3_NA				; proxyType
PUBLIC	?globallevels@@3HA				; globallevels
PUBLIC	?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A	; gCoordAxisTriangleMesh
PUBLIC	?TesselationDepth@@3HA				; TesselationDepth
PUBLIC	?meshType@@3W4MeshType@@A			; meshType
_BSS	SEGMENT
?surfaceNormImg@@3PAVSTImage@@A DD 01H DUP (?)		; surfaceNormImg
?surfaceNormTex@@3PAVSTTexture@@A DD 01H DUP (?)	; surfaceNormTex
?surfaceDisplaceImg@@3PAVSTImage@@A DD 01H DUP (?)	; surfaceDisplaceImg
?surfaceDisplaceTex@@3PAVSTTexture@@A DD 01H DUP (?)	; surfaceDisplaceTex
?surfaceColorImg@@3PAVSTImage@@A DD 01H DUP (?)		; surfaceColorImg
?surfaceColorTex@@3PAVSTTexture@@A DD 01H DUP (?)	; surfaceColorTex
?shader@@3PAVSTShaderProgram@@A DD 01H DUP (?)		; shader
?textureType@@3W4TextureType@@A DD 01H DUP (?)		; textureType
?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A DD 01H DUP (?) ; gCoordAxisTriangleMesh
?meshType@@3W4MeshType@@A DD 01H DUP (?)		; meshType
_BSS	ENDS
_DATA	SEGMENT
?lightPosition@@3PAMA DD 041200000r		; 10	; lightPosition
	DD	041700000r			; 15
	DD	041200000r			; 10
	DD	03f800000r			; 1
?gPreviousMouseX@@3HA DD 0ffffffffH			; gPreviousMouseX
?gPreviousMouseY@@3HA DD 0ffffffffH			; gPreviousMouseY
?gMouseButton@@3HA DD 0ffffffffH			; gMouseButton
?smooth@@3_NA DB 01H					; smooth
?proxyType@@3_NA DB 01H					; proxyType
	ORG $+2
?globallevels@@3HA DD 01H				; globallevels
?TesselationDepth@@3HA DD 064H				; TesselationDepth
_DATA	ENDS
CONST	SEGMENT
$SG147542 DB	'Processing...', 00H
	ORG $+2
$SG147543 DB	'Sphere created!', 00H
$SG147547 DB	'../../data/images/screenshot.jpg', 00H
	ORG $+3
$SG147559 DB	'output.obj', 00H
	ORG $+1
$SG147561 DB	'Enter the number of levels:', 00H
$SG147640 DB	'../../data/meshes/', 00H
	ORG $+1
$SG147641 DB	'Enter OBJ File Name(otherwise press enter none):', 00H
	ORG $+3
$SG147642 DB	'kernels/default.vert', 00H
	ORG $+3
$SG147643 DB	'kernels/phong.frag', 00H
	ORG $+1
$SG147644 DB	'../../data/images/world_map.jpeg', 00H
	ORG $+3
$SG147645 DB	'../../data/images/world_map.jpeg', 00H
	ORG $+3
$SG147646 DB	'../../data/images/cactus.jpeg', 00H
	ORG $+2
$SG147647 DB	'proj1_mesh', 00H
	ORG $+1
$SG147650 DB	'OpenGL 3.3 is supported!', 0aH, 0aH, 00H
	ORG $+1
$SG147651 DB	'OpenGL 3.3 NOT supported!', 0aH, 0aH, 00H
$SG147656 DB	'ARB extensions don''t work either.', 0aH, 00H
	ORG $+1
$SG147653 DB	'Your graphics card or graphics driver does', 0aH, 09H, 'n'
	DB	'ot support OpenGL 2.0, trying ARB extensions', 0aH, 00H
	ORG $+1
$SG147658 DB	09H, 'a machine with a newer graphics card.', 0aH, 00H
$SG147151 DB	' - ', 00H
$SG147657 DB	09H, 'You can try updating your graphics drivers.', 0aH, 09H
	DB	'If that does not work, you will have to find', 0aH, 00H
$SG147150 DB	'Mass Center: ', 00H
	ORG $+2
$SG147152 DB	'Bounding Box: ', 00H
	ORG $+1
$SG147220 DB	'normalTex', 00H
	ORG $+2
$SG147221 DB	'displacementTex', 00H
$SG147222 DB	'colorTex', 00H
	ORG $+3
$SG147225 DB	'normalMapping', 00H
	ORG $+2
$SG147226 DB	'displacementMapping', 00H
$SG147227 DB	'colorMapping', 00H
	ORG $+3
$SG147230 DB	'displacementMapping', 00H
$SG147231 DB	'normalMapping', 00H
	ORG $+2
$SG147232 DB	'colorMapping', 00H
	ORG $+3
$SG147235 DB	'displacementMapping', 00H
$SG147236 DB	'normalMapping', 00H
	ORG $+2
$SG147237 DB	'colorMapping', 00H
	ORG $+3
$SG147239 DB	'displacementMapping', 00H
$SG147240 DB	'normalMapping', 00H
	ORG $+2
$SG147241 DB	'colorMapping', 00H
	ORG $+3
$SG147242 DB	'TesselationDepth', 00H
	ORG $+3
$SG147246 DB	'displacementMapping', 00H
$SG147247 DB	'normalMapping', 00H
	ORG $+2
$SG147248 DB	'colorMapping', 00H
	ORG $+3
$SG147251 DB	'displacementMapping', 00H
$SG147252 DB	'normalMapping', 00H
	ORG $+2
$SG147253 DB	'colorMapping', 00H
	ORG $+3
$SG147255 DB	'displacementMapping', 00H
$SG147256 DB	'normalMapping', 00H
	ORG $+2
$SG147257 DB	'colorMapping', 00H
	ORG $+3
$SG147258 DB	'TesselationDepth', 00H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_cosf
PUBLIC	_ldexpf
PUBLIC	_powf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	_fabsl
PUBLIC	_frexpl
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	___local_stdio_printf_options
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z	; std::_Container_base12::_Swap_all
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??2_Crt_new_delete@std@@SAPAXI@Z		; std::_Crt_new_delete::operator new
PUBLIC	??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z	; std::_Crt_new_delete::operator new
PUBLIC	??3_Crt_new_delete@std@@SAXPAX@Z		; std::_Crt_new_delete::operator delete
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?_Stodx_v2@std@@YANPBDPAPADHPAH@Z		; std::_Stodx_v2
PUBLIC	?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z		; std::_Stofx_v2
PUBLIC	??_GSTImage@@QAEPAXI@Z				; STImage::`scalar deleting destructor'
PUBLIC	??0STMatrix4@@QAE@XZ				; STMatrix4::STMatrix4
PUBLIC	?EncodeI@STMatrix4@@QAEXXZ			; STMatrix4::EncodeI
PUBLIC	?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z	; STMatrix4::EncodeR
PUBLIC	??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z		; STMatrix4::operator*
PUBLIC	??0STVector3@@QAE@XZ				; STVector3::STVector3
PUBLIC	??0STVector3@@QAE@ABU0@@Z			; STVector3::STVector3
PUBLIC	??0STVector3@@QAE@MMM@Z				; STVector3::STVector3
PUBLIC	??4STVector3@@QAEAAU0@ABU0@@Z			; STVector3::operator=
PUBLIC	??XSTVector3@@QAEAAU0@M@Z			; STVector3::operator*=
PUBLIC	??_0STVector3@@QAEAAU0@M@Z			; STVector3::operator/=
PUBLIC	??YSTVector3@@QAEAAU0@ABU0@@Z			; STVector3::operator+=
PUBLIC	??ZSTVector3@@QAEAAU0@ABU0@@Z			; STVector3::operator-=
PUBLIC	?Normalize@STVector3@@QAEXXZ			; STVector3::Normalize
PUBLIC	?Length@STVector3@@QBEMXZ			; STVector3::Length
PUBLIC	?LengthSq@STVector3@@QBEMXZ			; STVector3::LengthSq
PUBLIC	?Cross@STVector3@@SA?AU1@ABU1@0@Z		; STVector3::Cross
PUBLIC	??D@YA?AUSTVector3@@MABU0@@Z			; operator*
PUBLIC	??G@YA?AUSTVector3@@ABU0@0@Z			; operator-
PUBLIC	??G@YA?AUSTVector3@@ABUSTPoint3@@0@Z		; operator-
PUBLIC	??0STPoint3@@QAE@XZ				; STPoint3::STPoint3
PUBLIC	??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z ; operator<<
PUBLIC	??$max@M@std@@YAABMABM0@Z			; std::max<float>
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??_GSTTriangleMesh@@QAEPAXI@Z			; STTriangleMesh::`scalar deleting destructor'
PUBLIC	??0?$allocator@PAVSTTriangleMesh@@@std@@QAE@XZ	; std::allocator<STTriangleMesh *>::allocator<STTriangleMesh *>
PUBLIC	?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z ; std::allocator<STTriangleMesh *>::deallocate
PUBLIC	?allocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEPAPAVSTTriangleMesh@@I@Z ; std::allocator<STTriangleMesh *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@SAIABV?$allocator@PAVSTTriangleMesh@@@2@@Z ; std::_Default_allocator_traits<std::allocator<STTriangleMesh *> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::~_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXABV?$allocator@PAVSTTriangleMesh@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Copy_alloc
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Free_proxy
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<STTriangleMesh *> >::_Vector_val<std::_Simple_types<STTriangleMesh *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second
PUBLIC	??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
PUBLIC	??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
PUBLIC	??4?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator=
PUBLIC	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
PUBLIC	?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size
PUBLIC	?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity
PUBLIC	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
PUBLIC	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
PUBLIC	?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@ABEII@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Calculate_growth
PUBLIC	?_Buy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAE_NI@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Buy
PUBLIC	?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xlength
PUBLIC	?_Xrange@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xrange
PUBLIC	??0?$allocator@W4TextureType@@@std@@QAE@XZ	; std::allocator<enum TextureType>::allocator<enum TextureType>
PUBLIC	?deallocate@?$allocator@W4TextureType@@@std@@QAEXQAW4TextureType@@I@Z ; std::allocator<enum TextureType>::deallocate
PUBLIC	?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z ; std::allocator<enum TextureType>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAIABV?$allocator@W4TextureType@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::max_size
PUBLIC	?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z ; std::allocator<enum TextureType *>::deallocate
PUBLIC	?allocate@?$allocator@PAW4TextureType@@@std@@QAEPAPAW4TextureType@@I@Z ; std::allocator<enum TextureType *>::allocate
PUBLIC	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
PUBLIC	??0?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >
PUBLIC	??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::~_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getpfirst
PUBLIC	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
PUBLIC	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
PUBLIC	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Deque_val<std::_Deque_simple_types<enum TextureType> >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Getblock
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second
PUBLIC	??0?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::deque<enum TextureType,std::allocator<enum TextureType> >
PUBLIC	?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back
PUBLIC	??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::~deque<enum TextureType,std::allocator<enum TextureType> >
PUBLIC	?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::begin
PUBLIC	?max_size@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBEIXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::max_size
PUBLIC	?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty
PUBLIC	?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::front
PUBLIC	?pop_front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_front
PUBLIC	?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXABW4TextureType@@@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back
PUBLIC	?pop_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_back
PUBLIC	?_Xlen@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Xlen
PUBLIC	?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Growmap
PUBLIC	?_Tidy@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Tidy
PUBLIC	?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Orphan_off
PUBLIC	??0?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >
PUBLIC	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push
PUBLIC	?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::front
PUBLIC	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXABW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push
PUBLIC	?pop@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::pop
PUBLIC	??1?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::~queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >
PUBLIC	??$?0USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAE@XZ ; std::pair<STPoint3,STPoint3>::pair<STPoint3,STPoint3><STPoint3,STPoint3,0>
PUBLIC	??0?$allocator@W4MeshType@@@std@@QAE@XZ		; std::allocator<enum MeshType>::allocator<enum MeshType>
PUBLIC	?deallocate@?$allocator@W4MeshType@@@std@@QAEXQAW4MeshType@@I@Z ; std::allocator<enum MeshType>::deallocate
PUBLIC	?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z ; std::allocator<enum MeshType>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAIABV?$allocator@W4MeshType@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::max_size
PUBLIC	?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z ; std::allocator<enum MeshType *>::deallocate
PUBLIC	?allocate@?$allocator@PAW4MeshType@@@std@@QAEPAPAW4MeshType@@I@Z ; std::allocator<enum MeshType *>::allocate
PUBLIC	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
PUBLIC	??0?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >
PUBLIC	??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::~_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getpfirst
PUBLIC	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
PUBLIC	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
PUBLIC	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Deque_val<std::_Deque_simple_types<enum MeshType> >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Getblock
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second
PUBLIC	??0?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::deque<enum MeshType,std::allocator<enum MeshType> >
PUBLIC	?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back
PUBLIC	??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::~deque<enum MeshType,std::allocator<enum MeshType> >
PUBLIC	?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::begin
PUBLIC	?max_size@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBEIXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::max_size
PUBLIC	?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty
PUBLIC	?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::front
PUBLIC	?pop_front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_front
PUBLIC	?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXABW4MeshType@@@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back
PUBLIC	?pop_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_back
PUBLIC	?_Xlen@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Xlen
PUBLIC	?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Growmap
PUBLIC	?_Tidy@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Tidy
PUBLIC	?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Orphan_off
PUBLIC	??0?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >
PUBLIC	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push
PUBLIC	?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::front
PUBLIC	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXABW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push
PUBLIC	?pop@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::pop
PUBLIC	??1?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::~queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >
PUBLIC	?ClearGlobalMesh@@YAXXZ				; ClearGlobalMesh
PUBLIC	?SetUpAndRight@@YAXXZ				; SetUpAndRight
PUBLIC	?resetCamera@@YAXXZ				; resetCamera
PUBLIC	?resetUp@@YAXXZ					; resetUp
PUBLIC	?CreateYourOwnMesh@@YAXXZ			; CreateYourOwnMesh
PUBLIC	?Setup@@YAXXZ					; Setup
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z ; std::pair<STPoint3,STPoint3>::operator=<STPoint3,STPoint3,0>
PUBLIC	?RotateCamera@@YAXMM@Z				; RotateCamera
PUBLIC	?ZoomCamera@@YAXM@Z				; ZoomCamera
PUBLIC	?StrafeCamera@@YAXMM@Z				; StrafeCamera
PUBLIC	?DisplayCallback@@YAXXZ				; DisplayCallback
PUBLIC	?ReshapeCallback@@YAXHH@Z			; ReshapeCallback
PUBLIC	?SpecialKeyCallback@@YAXHHH@Z			; SpecialKeyCallback
PUBLIC	?MouseCallback@@YAXHHHH@Z			; MouseCallback
PUBLIC	?MouseMotionCallback@@YAXHH@Z			; MouseMotionCallback
PUBLIC	?KeyCallback@@YAXEHH@Z				; KeyCallback
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
PUBLIC	_main
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ; std::move<enum MeshType &>
PUBLIC	??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ; std::move<enum TextureType &>
PUBLIC	??$addressof@$$CBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@0@ABV10@@Z ; std::addressof<std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> > const >
PUBLIC	??$assign@PAPAVSTTriangleMesh@@X@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::assign<STTriangleMesh * *,void>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
PUBLIC	??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<enum MeshType *>::allocator<enum MeshType *><enum MeshType>
PUBLIC	??$addressof@PAW4MeshType@@@std@@YAPAPAW4MeshType@@AAPAW41@@Z ; std::addressof<enum MeshType *>
PUBLIC	??$destroy@PAW4MeshType@@@?$_Default_allocator_traits@V?$allocator@PAW4MeshType@@@std@@@std@@SAXAAV?$allocator@PAW4MeshType@@@1@QAPAW4MeshType@@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType *> >::destroy<enum MeshType *>
PUBLIC	??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ; std::_Unfancy<enum MeshType>
PUBLIC	??$construct@W4MeshType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@ABW43@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType const &>
PUBLIC	??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::destroy<enum MeshType>
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEABW4MeshType@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Setcont
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEAAW4MeshType@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
PUBLIC	??$construct@W4MeshType@@W41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@$$QAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType>
PUBLIC	??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<enum TextureType *>::allocator<enum TextureType *><enum TextureType>
PUBLIC	??$addressof@PAW4TextureType@@@std@@YAPAPAW4TextureType@@AAPAW41@@Z ; std::addressof<enum TextureType *>
PUBLIC	??$destroy@PAW4TextureType@@@?$_Default_allocator_traits@V?$allocator@PAW4TextureType@@@std@@@std@@SAXAAV?$allocator@PAW4TextureType@@@1@QAPAW4TextureType@@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType *> >::destroy<enum TextureType *>
PUBLIC	??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ; std::_Unfancy<enum TextureType>
PUBLIC	??$construct@W4TextureType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@ABW43@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType const &>
PUBLIC	??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::destroy<enum TextureType>
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEABW4TextureType@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Setcont
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEAAW4TextureType@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
PUBLIC	??$construct@W4TextureType@@W41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@$$QAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType>
PUBLIC	??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@@Z ; std::_Pocca<std::allocator<STTriangleMesh *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1><>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum MeshType>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1><>
PUBLIC	??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
PUBLIC	??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Destroy_range<std::allocator<enum MeshType *> >
PUBLIC	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum TextureType>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1><>
PUBLIC	??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
PUBLIC	??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Destroy_range<std::allocator<enum TextureType *> >
PUBLIC	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
PUBLIC	??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><STTriangleMesh *>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<STTriangleMesh *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ; std::_Destroy_range<std::allocator<STTriangleMesh *> >
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??$_Verify_range@D@std@@YAXQBD0@Z		; std::_Verify_range<char>
PUBLIC	??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z ; std::_Adl_verify_range1<char const *,char const *>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
PUBLIC	??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z ; std::forward<STPoint3>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$_Adl_verify_range@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0@Z ; std::_Adl_verify_range<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Get_unwrapped<STTriangleMesh *>
PUBLIC	??$_Assign_range@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0Uforward_iterator_tag@1@@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Assign_range<STTriangleMesh * *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
PUBLIC	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
PUBLIC	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
PUBLIC	??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
PUBLIC	??$forward@ABW4MeshType@@@std@@YAABW4MeshType@@ABW41@@Z ; std::forward<enum MeshType const &>
PUBLIC	??$forward@W4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ; std::forward<enum MeshType>
PUBLIC	??$forward@ABW4TextureType@@@std@@YAABW4TextureType@@ABW41@@Z ; std::forward<enum TextureType const &>
PUBLIC	??$forward@W4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ; std::forward<enum TextureType>
PUBLIC	??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<STTriangleMesh *> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z ; std::_Get_unwrapped<enum MeshType *>
PUBLIC	??$_Idl_distance@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0@Z ; std::_Idl_distance<enum MeshType * *,enum MeshType * *>
PUBLIC	??$_Idl_distance1@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<enum MeshType * *,enum MeshType * *>
PUBLIC	??$_Get_unwrapped_n@PAW4MeshType@@H$0A@@std@@YAPAPAW4MeshType@@QAPAW41@H@Z ; std::_Get_unwrapped_n<enum MeshType *,int,0>
PUBLIC	??$_Ptr_copy_cat@PAW4MeshType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4MeshType@@0@Z ; std::_Ptr_copy_cat<enum MeshType *,enum MeshType *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAW4MeshType@@PAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@00AAV?$allocator@PAW4MeshType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<enum MeshType *,enum MeshType *,std::allocator<enum MeshType *> >
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >
PUBLIC	??$_Seek_wrapped@PAW4MeshType@@@std@@YAXAAPAPAW4MeshType@@QAPAW41@@Z ; std::_Seek_wrapped<enum MeshType *>
PUBLIC	??$_Uninitialized_value_construct_n1@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
PUBLIC	??$_Destroy_range1@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<enum MeshType *> >
PUBLIC	??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z ; std::_Get_unwrapped<enum TextureType *>
PUBLIC	??$_Idl_distance@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0@Z ; std::_Idl_distance<enum TextureType * *,enum TextureType * *>
PUBLIC	??$_Idl_distance1@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<enum TextureType * *,enum TextureType * *>
PUBLIC	??$_Get_unwrapped_n@PAW4TextureType@@H$0A@@std@@YAPAPAW4TextureType@@QAPAW41@H@Z ; std::_Get_unwrapped_n<enum TextureType *,int,0>
PUBLIC	??$_Ptr_copy_cat@PAW4TextureType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4TextureType@@0@Z ; std::_Ptr_copy_cat<enum TextureType *,enum TextureType *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAW4TextureType@@PAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@00AAV?$allocator@PAW4TextureType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<enum TextureType *,enum TextureType *,std::allocator<enum TextureType *> >
PUBLIC	??$_Seek_wrapped@PAW4TextureType@@@std@@YAXAAPAPAW4TextureType@@QAPAW41@@Z ; std::_Seek_wrapped<enum TextureType *>
PUBLIC	??$_Uninitialized_value_construct_n1@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
PUBLIC	??$_Destroy_range1@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<enum TextureType *> >
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$_Destroy_range1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<STTriangleMesh *> >
PUBLIC	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
PUBLIC	??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z	; std::_Find_elem<char,15>
PUBLIC	??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z	; std::_Find_elem<char,27>
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z	; std::_Find_elem<char,29>
PUBLIC	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
PUBLIC	??$_Verify_range@PAVSTTriangleMesh@@@std@@YAXQBQAVSTTriangleMesh@@0@Z ; std::_Verify_range<STTriangleMesh *>
PUBLIC	??$_Adl_verify_range1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0U?$integral_constant@_N$00@0@@Z ; std::_Adl_verify_range1<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$distance@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0@Z ; std::distance<STTriangleMesh * *>
PUBLIC	??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Ucopy<STTriangleMesh * *>
PUBLIC	??$next@PAPAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@H@Z ; std::next<STTriangleMesh * *>
PUBLIC	??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_unchecked<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Copy_memmove@PAPAW4MeshType@@PAPAW41@@std@@YAPAPAW4MeshType@@PAPAW41@00@Z ; std::_Copy_memmove<enum MeshType * *,enum MeshType * *>
PUBLIC	??$_Zero_range@PAPAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@0@Z ; std::_Zero_range<enum MeshType * *>
PUBLIC	??$_Copy_memmove@PAPAW4TextureType@@PAPAW41@@std@@YAPAPAW4TextureType@@PAPAW41@00@Z ; std::_Copy_memmove<enum TextureType * *,enum TextureType * *>
PUBLIC	??$_Zero_range@PAPAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@0@Z ; std::_Zero_range<enum TextureType * *>
PUBLIC	??$_Adl_verify_range1@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ; std::_Adl_verify_range1<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z	; std::_Find_unchecked<char const *,char>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Distance1@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<STTriangleMesh * *>
PUBLIC	??$_Uninitialized_copy@PAPAVSTTriangleMesh@@PAPAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@0PAPAV1@AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ; std::_Uninitialized_copy<STTriangleMesh * *,STTriangleMesh * *,std::allocator<STTriangleMesh *> >
PUBLIC	??$advance@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@H@Z ; std::advance<STTriangleMesh * *,int>
PUBLIC	??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z ; std::_Ptr_copy_cat<STTriangleMesh *,STTriangleMesh *>
PUBLIC	??$_Copy_unchecked1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Find_unchecked1@PBDD@std@@YAPBDPBDQBDABDU?$integral_constant@_N$00@0@@Z ; std::_Find_unchecked1<char const *,char>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$_Idl_distance@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0@Z ; std::_Idl_distance<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Idl_distance1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Get_unwrapped_n@PAVSTTriangleMesh@@H$0A@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@H@Z ; std::_Get_unwrapped_n<STTriangleMesh *,int,0>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAVSTTriangleMesh@@PAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@00AAV?$allocator@PAVSTTriangleMesh@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<STTriangleMesh *,STTriangleMesh *,std::allocator<STTriangleMesh *> >
PUBLIC	??$_Seek_wrapped@PAVSTTriangleMesh@@@std@@YAXAAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Seek_wrapped<STTriangleMesh *>
PUBLIC	??$_Advance1@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<STTriangleMesh * *,int>
PUBLIC	??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_memmove<STTriangleMesh * *,STTriangleMesh * *>
PUBLIC	??$_Within_limits@PBDD@std@@YA_NPBDABD@Z	; std::_Within_limits<char const *,char>
PUBLIC	??$_Within_limits@D@std@@YA_NABDU?$integral_constant@_N$00@0@1U_Unused_parameter@0@@Z ; std::_Within_limits<char>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error@	; `string'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL@				; `string'
PUBLIC	?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; vertexShader
PUBLIC	?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; fragmentShader
PUBLIC	?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; normalMap
PUBLIC	?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; displacementMap
PUBLIC	?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; meshOBJ
PUBLIC	?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; colorMap
PUBLIC	?mPosition@@3USTVector3@@A			; mPosition
PUBLIC	?mLookAt@@3USTVector3@@A			; mLookAt
PUBLIC	?mRight@@3USTVector3@@A				; mRight
PUBLIC	?mUp@@3USTVector3@@A				; mUp
PUBLIC	?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
PUBLIC	?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
PUBLIC	?gMassCenter@@3USTPoint3@@A			; gMassCenter
PUBLIC	?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A	; gBoundingBox
PUBLIC	?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1LO@PDFJBEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1LO@NPPEKPAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@	; `string'
PUBLIC	??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1JE@GOCCMDDF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ ; `string'
PUBLIC	??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@ ; `string'
PUBLIC	??_C@_1KA@GCMBJJEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ ; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@ ; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_1JC@FMAFMAOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ ; `string'
PUBLIC	??_C@_1JO@BIGKCEFI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ ; `string'
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_0DE@MANMEIKC@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1OA@EJNJGAHC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1GM@HLAFMPGB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CN@IEPDPKI@cannot?5deference?5out?5of?5range?5d@ ; `string'
PUBLIC	??_C@_1FO@KFELHBJF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_1OG@LMMEOOCI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
PUBLIC	?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
PUBLIC	?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
PUBLIC	?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
PUBLIC	??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@ ; `string'
PUBLIC	??_C@_0GK@MKMOJOPB@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NE@KHFMDOHB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1JG@KCHMIAPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@ ; `string'
PUBLIC	??_C@_1FG@EPFFBKIL@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_0CK@IACNJOAE@istreambuf_iterator?5is?5not?5dere@ ; `string'
PUBLIC	??_C@_1JE@DOOFMCFJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@ ; `string'
PUBLIC	??_C@_1FI@NCHBPOBH@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f800000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@403e000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40a00000
PUBLIC	__real@40c3880000000000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@43340000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c1200000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__imp__glClear@4:PROC
EXTRN	__imp__glClearColor@16:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp__glLightfv@12:PROC
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	__imp__glPopMatrix@0:PROC
EXTRN	__imp__glPushMatrix@0:PROC
EXTRN	__imp__glScalef@12:PROC
EXTRN	__imp__glTranslatef@12:PROC
EXTRN	__imp__glViewport@16:PROC
EXTRN	_gluPerspective@32:PROC
EXTRN	_gluLookAt@72:PROC
EXTRN	_glewInit@0:PROC
EXTRN	__invalid_parameter:PROC
EXTRN	__errno:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcspn:PROC
EXTRN	_strlen:PROC
EXTRN	__calloc_dbg:PROC
EXTRN	__free_dbg:PROC
EXTRN	__malloc_dbg:PROC
EXTRN	__CrtDbgReport:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	_abs:PROC
EXTRN	_strtof:PROC
EXTRN	_strtod:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_pow:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_frexp:PROC
EXTRN	_ldexp:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	_terminate:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??0STColor4ub@@QAE@EEEE@Z:PROC			; STColor4ub::STColor4ub
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z:PROC ; std::_Execute_once
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	__Stolx:PROC
EXTRN	__Stoulx:PROC
EXTRN	__Stollx:PROC
EXTRN	__Stoullx:PROC
EXTRN	??0STImage@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; STImage::STImage
EXTRN	??0STImage@@QAE@HHUSTColor4ub@@@Z:PROC		; STImage::STImage
EXTRN	??1STImage@@QAE@XZ:PROC				; STImage::~STImage
EXTRN	?Save@STImage@@QBE?AW4STStatus@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; STImage::Save
EXTRN	?Read@STImage@@QAEXHH@Z:PROC			; STImage::Read
EXTRN	??0STShaderProgram@@QAE@XZ:PROC			; STShaderProgram::STShaderProgram
EXTRN	?LoadVertexShader@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; STShaderProgram::LoadVertexShader
EXTRN	?LoadFragmentShader@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; STShaderProgram::LoadFragmentShader
EXTRN	?Bind@STShaderProgram@@QAEXXZ:PROC		; STShaderProgram::Bind
EXTRN	?UnBind@STShaderProgram@@QAEXXZ:PROC		; STShaderProgram::UnBind
EXTRN	?SetTexture@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC ; STShaderProgram::SetTexture
EXTRN	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z:PROC ; STShaderProgram::SetUniform
EXTRN	??0STTexture@@QAE@PBVSTImage@@W4ImageOptions@0@@Z:PROC ; STTexture::STTexture
EXTRN	?Bind@STTexture@@QAEXXZ:PROC			; STTexture::Bind
EXTRN	?UnBind@STTexture@@QAEXXZ:PROC			; STTexture::UnBind
EXTRN	??0STTriangleMesh@@QAE@XZ:PROC			; STTriangleMesh::STTriangleMesh
EXTRN	??1STTriangleMesh@@QAE@XZ:PROC			; STTriangleMesh::~STTriangleMesh
EXTRN	?Draw@STTriangleMesh@@QBEX_N@Z:PROC		; STTriangleMesh::Draw
EXTRN	?Write@STTriangleMesh@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; STTriangleMesh::Write
EXTRN	?AddVertex@STTriangleMesh@@QAEIMMMMM@Z:PROC	; STTriangleMesh::AddVertex
EXTRN	?AddFace@STTriangleMesh@@QAEIIII@Z:PROC		; STTriangleMesh::AddFace
EXTRN	?Build@STTriangleMesh@@QAE_NXZ:PROC		; STTriangleMesh::Build
EXTRN	?CalculateTextureCoordinatesViaSphericalProxy@STTriangleMesh@@QAE_NXZ:PROC ; STTriangleMesh::CalculateTextureCoordinatesViaSphericalProxy
EXTRN	?LoopSubdivide@STTriangleMesh@@QAEXXZ:PROC	; STTriangleMesh::LoopSubdivide
EXTRN	?LoadObj@STTriangleMesh@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@ABV23@@Z:PROC ; STTriangleMesh::LoadObj
EXTRN	?GetMassCenter@STTriangleMesh@@SA?AUSTPoint3@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@Z:PROC ; STTriangleMesh::GetMassCenter
EXTRN	?GetBoundingBox@STTriangleMesh@@SA?AU?$pair@USTPoint3@@U1@@std@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@@Z:PROC ; STTriangleMesh::GetBoundingBox
EXTRN	_glutInitWindowPosition:PROC
EXTRN	_glutInitWindowSize:PROC
EXTRN	_glutInitDisplayMode:PROC
EXTRN	_glutMainLoop:PROC
EXTRN	_glutPostRedisplay:PROC
EXTRN	_glutSwapBuffers:PROC
EXTRN	_glutIdleFunc:PROC
EXTRN	_glutKeyboardFunc:PROC
EXTRN	_glutSpecialFunc:PROC
EXTRN	_glutReshapeFunc:PROC
EXTRN	_glutDisplayFunc:PROC
EXTRN	_glutMouseFunc:PROC
EXTRN	_glutMotionFunc:PROC
EXTRN	___glutInitWithExit:PROC
EXTRN	___glutCreateWindowWithExit:PROC
EXTRN	??0MySphere@@QAE@XZ:PROC			; MySphere::MySphere
EXTRN	??1MySphere@@QAE@XZ:PROC			; MySphere::~MySphere
EXTRN	?Create@MySphere@@QAEXH@Z:PROC			; MySphere::Create
EXTRN	?FileName@MySphere@@QAEPADXZ:PROC		; MySphere::FileName
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___glewActiveTexture:DWORD
EXTRN	___GLEW_VERSION_2_0:BYTE
EXTRN	___GLEW_ARB_fragment_shader:BYTE
EXTRN	___GLEW_ARB_vertex_shader:BYTE
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cin
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?gWindowSizeX@@3HA DD 01H DUP (?)			; gWindowSizeX
?gWindowSizeY@@3HA DD 01H DUP (?)			; gWindowSizeY
?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; vertexShader
?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; fragmentShader
?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; normalMap
?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; displacementMap
?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; meshOBJ
?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 01cH DUP (?) ; colorMap
?mPosition@@3USTVector3@@A DB 0cH DUP (?)		; mPosition
?mLookAt@@3USTVector3@@A DB 0cH DUP (?)			; mLookAt
?mRight@@3USTVector3@@A DB 0cH DUP (?)			; mRight
?mUp@@3USTVector3@@A DB 0cH DUP (?)			; mUp
?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A DB 014H DUP (?) ; textureQueue
?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A DB 010H DUP (?) ; gTriangleMeshes
?gMassCenter@@3USTPoint3@@A DB 0cH DUP (?)		; gMassCenter
?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A DB 018H DUP (?) ; gBoundingBox
?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A DB 014H DUP (?) ; meshQueue
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA DD 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
?vertexShader$initializer$@@3P6AXXZA DD FLAT:??__EvertexShader@@YAXXZ ; vertexShader$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
CONST	SEGMENT
??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@NCHBPOBH@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@
CONST	SEGMENT
??_C@_1FI@NCHBPOBH@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@ DB '"'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	'm', 00H, 'b', 00H, 'u', 00H, 'f', 00H, '_', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't'
	DB	00H, ' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1JE@DOOFMCFJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@
CONST	SEGMENT
??_C@_1JE@DOOFMCFJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'b', 00H, 'u'
	DB	00H, 'f', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd'
	DB	00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H
	DB	'_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H, 's'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'*', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IACNJOAE@istreambuf_iterator?5is?5not?5dere@
CONST	SEGMENT
??_C@_0CK@IACNJOAE@istreambuf_iterator?5is?5not?5dere@ DB 'istreambuf_ite'
	DB	'rator is not dereferencable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@EPFFBKIL@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@
CONST	SEGMENT
??_C@_1FG@EPFFBKIL@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@ DB '"'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	'm', 00H, 'b', 00H, 'u', 00H, 'f', 00H, '_', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't'
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1JG@KCHMIAPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@
CONST	SEGMENT
??_C@_1JG@KCHMIAPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'b', 00H, 'u'
	DB	00H, 'f', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd'
	DB	00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H
	DB	'_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H, 's'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'+', 00H, '+', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@KHFMDOHB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@KHFMDOHB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@MKMOJOPB@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@MKMOJOPB@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\streambuf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@
CONST	SEGMENT
??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@ DB 'istreambuf_itera'
	DB	'tor is not incrementable', 00H		; `string'
CONST	ENDS
;	COMDAT ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	050H
	DB	070H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02dH
	DB	02bH
	DB	045H
	DB	065H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
CONST	SEGMENT
??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@ DB 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H
	DB	'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\algorithm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1OG@LMMEOOCI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
CONST	SEGMENT
??_C@_1OG@LMMEOOCI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@KFELHBJF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn@
CONST	SEGMENT
??_C@_1FO@KFELHBJF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IEPDPKI@cannot?5deference?5out?5of?5range?5d@
CONST	SEGMENT
??_C@_0CN@IEPDPKI@cannot?5deference?5out?5of?5range?5d@ DB 'cannot defere'
	DB	'nce out of range deque iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@HLAFMPGB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GM@HLAFMPGB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1OA@EJNJGAHC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
CONST	SEGMENT
??_C@_1OA@EJNJGAHC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<'
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, '_', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 's', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	' ', 00H, 'M', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MANMEIKC@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DE@MANMEIKC@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized deque iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@BIGKCEFI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
CONST	SEGMENT
??_C@_1JO@BIGKCEFI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'p', 00H, 'o', 00H
	DB	'p', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@FMAFMAOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
CONST	SEGMENT
??_C@_1JC@FMAFMAOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 's', 00H, 'h', 00H
	DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'e', 00H, 'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, 'M', 00H, 'e'
	DB	00H, 's', 00H, 'h', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'p', 00H, 'o'
	DB	00H, 'p', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@ DB 'invalid vecto'
	DB	'r<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KA@GCMBJJEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
CONST	SEGMENT
??_C@_1KA@GCMBJJEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'p', 00H, 'o', 00H
	DB	'p', 00H, '_', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
CONST	SEGMENT
??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@ DB '"'
	DB	00H, 'd', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, ' ', 00H
	DB	'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'b'
	DB	00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'p', 00H, 'o', 00H, 'p', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JE@GOCCMDDF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
CONST	SEGMENT
??_C@_1JE@GOCCMDDF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, '<', 00H, 'e', 00H, 'n', 00H, 'u'
	DB	00H, 'm', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 's', 00H, 'h', 00H
	DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'e', 00H, 'n', 00H, 'u', 00H, 'm', 00H, ' ', 00H, 'M', 00H, 'e'
	DB	00H, 's', 00H, 'h', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'p', 00H, 'o'
	DB	00H, 'p', 00H, '_', 00H, 'f', 00H, 'r', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\deque', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
CONST	SEGMENT
??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@ DB 'deque empty before pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LO@NPPEKPAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr?$AAi@
CONST	SEGMENT
??_C@_1LO@NPPEKPAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr?$AAi@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b', 00H, 'a', 00H
	DB	's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '_'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H, 's', 00H
	DB	'<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ','
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '[', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xstring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LO@PDFJBEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@
CONST	SEGMENT
??_C@_1LO@PDFJBEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'S', 00H, 'T', 00H
	DB	'T', 00H, 'r', 00H, 'i', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'l'
	DB	00H, 'e', 00H, 'M', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H
	DB	'*', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 'S', 00H, 'T', 00H, 'T', 00H, 'r'
	DB	00H, 'i', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'l', 00H, 'e', 00H
	DB	'M', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '[', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\vector', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?ambientLight@@3PAMA DD 03f000000r		; 0.5	; ambientLight
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
?diffuseLight@@3PAMA DD 03f800000r		; 1	; diffuseLight
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
?specularLight@@3PAMA DD 03f800000r		; 1	; specularLight
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error@ DB 'iostream stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xlocale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xmemory0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
CONST	SEGMENT
??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'I', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '_', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '1', 00H
	DB	'2', 00H, ':', 00H, ':', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'p'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xutility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0
__ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
__ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
__ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1
__ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$numpunct@D@std@@MAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$0
__tryblocktable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$4
__unwindtable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$3
	DD	00H
	DD	00H
__ehfuncinfo$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z$0
__ehfuncinfo$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?CreateYourOwnMesh@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateYourOwnMesh@@YAXXZ$0
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
__ehfuncinfo$_main DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?KeyCallback@@YAXEHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?KeyCallback@@YAXEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DisplayCallback@@YAXXZ DD 019930522H
	DD	01aH
	DD	FLAT:__unwindtable$?DisplayCallback@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Setup@@YAXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?Setup@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateYourOwnMesh@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateYourOwnMesh@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?KeyCallback@@YAXEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?KeyCallback@@YAXEHH@Z$7
__unwindtable$?Setup@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@@YAXXZ$6
__unwindtable$?DisplayCallback@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayCallback@@YAXXZ$25
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z$0
__ehfuncinfo$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ$0
__ehfuncinfo$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z$0
__ehfuncinfo$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ$0
__ehfuncinfo$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$3
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?iostream_category@std@@YAABVerror_category@1@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ctype@D@std@@MAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Yarn@_W@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Yarn@D@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?fragmentShader$initializer$@@3P6AXXZA DD FLAT:??__EfragmentShader@@YAXXZ ; fragmentShader$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?normalMap$initializer$@@3P6AXXZA DD FLAT:??__EnormalMap@@YAXXZ ; normalMap$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?displacementMap$initializer$@@3P6AXXZA DD FLAT:??__EdisplacementMap@@YAXXZ ; displacementMap$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?meshOBJ$initializer$@@3P6AXXZA DD FLAT:??__EmeshOBJ@@YAXXZ ; meshOBJ$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?colorMap$initializer$@@3P6AXXZA DD FLAT:??__EcolorMap@@YAXXZ ; colorMap$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?mPosition$initializer$@@3P6AXXZA DD FLAT:??__EmPosition@@YAXXZ ; mPosition$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?mLookAt$initializer$@@3P6AXXZA DD FLAT:??__EmLookAt@@YAXXZ ; mLookAt$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?mRight$initializer$@@3P6AXXZA DD FLAT:??__EmRight@@YAXXZ ; mRight$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?mUp$initializer$@@3P6AXXZA DD FLAT:??__EmUp@@YAXXZ	; mUp$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?textureQueue$initializer$@@3P6AXXZA DD FLAT:??__EtextureQueue@@YAXXZ ; textureQueue$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gTriangleMeshes$initializer$@@3P6AXXZA DD FLAT:??__EgTriangleMeshes@@YAXXZ ; gTriangleMeshes$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gMassCenter$initializer$@@3P6AXXZA DD FLAT:??__EgMassCenter@@YAXXZ ; gMassCenter$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gBoundingBox$initializer$@@3P6AXXZA DD FLAT:??__EgBoundingBox@@YAXXZ ; gBoundingBox$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?meshQueue$initializer$@@3P6AXXZA DD FLAT:??__EmeshQueue@@YAXXZ ; meshQueue$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Within_limits@D@std@@YA_NABDU?$integral_constant@_N$00@0@1U_Unused_parameter@0@@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Within_limits@D@std@@YA_NABDU?$integral_constant@_N$00@0@1U_Unused_parameter@0@@Z PROC ; std::_Within_limits<char>, COMDAT

; 3458 : 	{	// signed _Elem, signed _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 3459 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);

	mov	eax, DWORD PTR __Val$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -128				; ffffff80H
	jl	SHORT $LN3@Within_lim
	mov	edx, DWORD PTR __Val$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN3@Within_lim
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Within_lim
$LN3@Within_lim:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Within_lim:
	mov	al, BYTE PTR tv68[ebp]

; 3460 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Within_limits@D@std@@YA_NABDU?$integral_constant@_N$00@0@1U_Unused_parameter@0@@Z ENDP ; std::_Within_limits<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Within_limits@PBDD@std@@YA_NPBDABD@Z
_TEXT	SEGMENT
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
___formal$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Within_limits@PBDD@std@@YA_NPBDABD@Z PROC		; std::_Within_limits<char const *,char>, COMDAT

; 3489 : 	{	// check whether _Val is within the limits of _Elem

	push	ebp
	mov	ebp, esp
	push	ecx

; 3490 : 	using _Elem = remove_pointer_t<_InIt>;
; 3491 : 	return (_Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{},

	xor	eax, eax
	mov	BYTE PTR $T3[ebp], al
	push	ecx
	mov	ecx, esp
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$_Within_limits@D@std@@YA_NABDU?$integral_constant@_N$00@0@1U_Unused_parameter@0@@Z ; std::_Within_limits<char>
	add	esp, 16					; 00000010H

; 3492 : 		bool_constant<-1 == static_cast<_Ty>(-1)>{}));
; 3493 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Within_limits@PBDD@std@@YA_NPBDABD@Z ENDP		; std::_Within_limits<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z PROC ; std::_Copy_memmove<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 2398 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], ecx

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], edx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First_ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest_ch$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 2405 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Advance1@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance1@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<STTriangleMesh * *,int>, COMDAT

; 1207 : 	{	// increment iterator by offset, random-access iterators

	push	ebp
	mov	ebp, esp

; 1208 : 	_Where += _Off;

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [ecx], eax

; 1209 : 	}

	pop	ebp
	ret	0
??$_Advance1@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<STTriangleMesh * *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@PAVSTTriangleMesh@@@std@@YAXAAPAPAVSTTriangleMesh@@QAPAV1@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@PAVSTTriangleMesh@@@std@@YAXAAPAPAVSTTriangleMesh@@QAPAV1@@Z PROC ; std::_Seek_wrapped<STTriangleMesh *>, COMDAT

; 871  : 	{

	push	ebp
	mov	ebp, esp

; 872  : 	_It = _UIt;

	mov	eax, DWORD PTR __It$[ebp]
	mov	ecx, DWORD PTR __UIt$[ebp]
	mov	DWORD PTR [eax], ecx

; 873  : 	}

	pop	ebp
	ret	0
??$_Seek_wrapped@PAVSTTriangleMesh@@@std@@YAXAAPAPAVSTTriangleMesh@@QAPAV1@@Z ENDP ; std::_Seek_wrapped<STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAVSTTriangleMesh@@PAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@00AAV?$allocator@PAVSTTriangleMesh@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@PAVSTTriangleMesh@@PAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@00AAV?$allocator@PAVSTTriangleMesh@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<STTriangleMesh *,STTriangleMesh *,std::allocator<STTriangleMesh *> >, COMDAT

; 201  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp

; 202  : 	return (_Copy_memmove(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_memmove<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 203  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAVSTTriangleMesh@@PAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@00AAV?$allocator@PAVSTTriangleMesh@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<STTriangleMesh *,STTriangleMesh *,std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@PAVSTTriangleMesh@@H$0A@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@H@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@PAVSTTriangleMesh@@H$0A@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@H@Z PROC ; std::_Get_unwrapped_n<STTriangleMesh *,int,0>, COMDAT

; 808  : 	{

	push	ebp
	mov	ebp, esp

; 809  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 810  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped_n@PAVSTTriangleMesh@@H$0A@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@H@Z ENDP ; std::_Get_unwrapped_n<STTriangleMesh *,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 967  : 	{	// _Idl_distance for random-access iterators

	push	ebp
	mov	ebp, esp

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 969  : 	}

	pop	ebp
	ret	0
??$_Idl_distance1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0@Z PROC ; std::_Idl_distance<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 974  : 	{	// tries to get the distance between _First and _Last if they are random-access iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Idl_distance1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 976  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Idl_distance@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0@Z ENDP ; std::_Idl_distance<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Find_unchecked1@PBDD@std@@YAPBDPBDQBDABDU?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PBDD@std@@YAPBDPBDQBDABDU?$integral_constant@_N$00@0@@Z PROC ; std::_Find_unchecked1<char const *,char>, COMDAT

; 3504 : 	{	// find first byte matching integral _Val

	push	ebp
	mov	ebp, esp
	push	ecx

; 3505 : 	if (!_Within_limits(_First, _Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Within_limits@PBDD@std@@YA_NPBDABD@Z ; std::_Within_limits<char const *,char>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@Find_unche

; 3506 : 		{
; 3507 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	jmp	SHORT $LN1@Find_unche
$LN2@Find_unche:

; 3508 : 		}
; 3509 : 
; 3510 : 	_First = static_cast<_InIt>(_CSTD memchr(

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax

; 3511 : 		_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 3512 : 	return (_First ? _First : _Last);

	cmp	DWORD PTR __First$[ebp], 0
	je	SHORT $LN4@Find_unche
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	jmp	SHORT $LN5@Find_unche
$LN4@Find_unche:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR tv76[ebp], edx
$LN5@Find_unche:
	mov	eax, DWORD PTR tv76[ebp]
$LN1@Find_unche:

; 3513 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked1@PBDD@std@@YAPBDPBDQBDABDU?$integral_constant@_N$00@0@@Z ENDP ; std::_Find_unchecked1<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_unchecked1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 2424 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

	push	ebp
	mov	ebp, esp

; 2425 : 	return (_Copy_memmove(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_memmove<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 2426 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z PROC ; std::_Ptr_copy_cat<STTriangleMesh *,STTriangleMesh *>, COMDAT

; 1069 : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp

; 1070 : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1071 : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z ENDP ; std::_Ptr_copy_cat<STTriangleMesh *,STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$advance@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@H@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@H@Z PROC ; std::advance<STTriangleMesh * *,int>, COMDAT

; 1214 : 	{	// increment iterator by offset, arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 1215 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1216 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Advance1@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<STTriangleMesh * *,int>
	add	esp, 12					; 0000000cH

; 1217 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$advance@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@H@Z ENDP ; std::advance<STTriangleMesh * *,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVSTTriangleMesh@@PAPAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@0PAPAV1@AAV?$allocator@PAVSTTriangleMesh@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -16						; size = 4
__UDest$ = -12						; size = 4
__UFirst$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVSTTriangleMesh@@PAPAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@0PAPAV1@AAV?$allocator@PAVSTTriangleMesh@@@0@@Z PROC ; std::_Uninitialized_copy<STTriangleMesh * *,STTriangleMesh * *,std::allocator<STTriangleMesh *> >, COMDAT

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 210  : 		// note: only called internally from elsewhere in the STL
; 211  : 	const auto _UFirst = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Get_unwrapped<STTriangleMesh *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 212  : 	const auto _ULast = _Get_unwrapped(_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Get_unwrapped<STTriangleMesh *>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 213  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	edx, DWORD PTR __ULast$[ebp]
	push	edx
	lea	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$_Idl_distance@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAHABQAPAVSTTriangleMesh@@0@Z ; std::_Idl_distance<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Get_unwrapped_n@PAVSTTriangleMesh@@H$0A@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@H@Z ; std::_Get_unwrapped_n<STTriangleMesh *,int,0>
	add	esp, 8
	mov	DWORD PTR __UDest$[ebp], eax

; 214  : 	_Seek_wrapped(_Dest,

	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR __UDest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __UFirst$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z ; std::_Ptr_copy_cat<STTriangleMesh *,STTriangleMesh *>
	add	esp, 12					; 0000000cH
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __UDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Uninitialized_copy_al_unchecked@PAVSTTriangleMesh@@PAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@00AAV?$allocator@PAVSTTriangleMesh@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<STTriangleMesh *,STTriangleMesh *,std::allocator<STTriangleMesh *> >
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Seek_wrapped@PAVSTTriangleMesh@@@std@@YAXAAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Seek_wrapped<STTriangleMesh *>
	add	esp, 8

; 215  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 216  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 217  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
; 218  : 
; 219  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAVSTTriangleMesh@@PAPAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@0PAPAV1@AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ENDP ; std::_Uninitialized_copy<STTriangleMesh * *,STTriangleMesh * *,std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Distance1@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<STTriangleMesh * *>, COMDAT

; 1234 : 	{	// return distance between iterators; random-access

	push	ebp
	mov	ebp, esp

; 1235 : 	return (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2

; 1236 : 	}

	pop	ebp
	ret	0
??$_Distance1@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	push	eax
	call	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 279  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1404 : 	__PURE_APPDOMAIN_GLOBAL locale::id num_get<_Elem, _InIt>::id;

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z PROC	; std::_Find_unchecked<char const *,char>, COMDAT

; 3528 : 	{	// find first matching _Val; choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx

; 3529 : 	// activate optimization for pointers to (const) bytes and integral values
; 3530 : 	using _Memchr_opt = bool_constant<is_integral_v<_Ty> && _Is_any_of_v<_InIt,
; 3531 : 		char *, signed char *, unsigned char *, const char *, const signed char *, const unsigned char *>>;
; 3532 : 
; 3533 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt{}));

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Find_unchecked1@PBDD@std@@YAPBDPBDQBDABDU?$integral_constant@_N$00@0@@Z ; std::_Find_unchecked1<char const *,char>
	add	esp, 16					; 00000010H

; 3534 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ENDP	; std::_Find_unchecked<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range1@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Adl_verify_range1<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 609  : 	{	// (don't) check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp

; 610  : 	}

	pop	ebp
	ret	0
??$_Adl_verify_range1@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Adl_verify_range1<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAPAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@0@Z PROC ; std::_Zero_range<enum TextureType * *>, COMDAT

; 310  : 	{	// fill [_First, _Last) with zeroes

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	edx, DWORD PTR __Last_ch$[ebp]
	sub	edx, DWORD PTR __First_ch$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __First_ch$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 314  : 	return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 315  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Zero_range@PAPAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@0@Z ENDP ; std::_Zero_range<enum TextureType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAW4TextureType@@PAPAW41@@std@@YAPAPAW4TextureType@@PAPAW41@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAW4TextureType@@PAPAW41@@std@@YAPAPAW4TextureType@@PAPAW41@00@Z PROC ; std::_Copy_memmove<enum TextureType * *,enum TextureType * *>, COMDAT

; 2398 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], ecx

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], edx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First_ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest_ch$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 2405 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAPAW4TextureType@@PAPAW41@@std@@YAPAPAW4TextureType@@PAPAW41@00@Z ENDP ; std::_Copy_memmove<enum TextureType * *,enum TextureType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAPAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@0@Z PROC ; std::_Zero_range<enum MeshType * *>, COMDAT

; 310  : 	{	// fill [_First, _Last) with zeroes

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	edx, DWORD PTR __Last_ch$[ebp]
	sub	edx, DWORD PTR __First_ch$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __First_ch$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 314  : 	return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 315  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Zero_range@PAPAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@0@Z ENDP ; std::_Zero_range<enum MeshType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAW4MeshType@@PAPAW41@@std@@YAPAPAW4MeshType@@PAPAW41@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAW4MeshType@@PAPAW41@@std@@YAPAPAW4MeshType@@PAPAW41@00@Z PROC ; std::_Copy_memmove<enum MeshType * *,enum MeshType * *>, COMDAT

; 2398 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], ecx

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], edx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First_ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest_ch$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 2405 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAPAW4MeshType@@PAPAW41@@std@@YAPAPAW4MeshType@@PAPAW41@00@Z ENDP ; std::_Copy_memmove<enum MeshType * *,enum MeshType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z PROC ; std::_Copy_unchecked<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 2432 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 2433 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2434 : 	return (_Copy_unchecked1(_First, _Last, _Dest, _Ptr_copy_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??$_Ptr_copy_cat@PAVSTTriangleMesh@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVSTTriangleMesh@@0@Z ; std::_Ptr_copy_cat<STTriangleMesh *,STTriangleMesh *>
	add	esp, 12					; 0000000cH
	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_unchecked1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 16					; 00000010H

; 2435 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ENDP ; std::_Copy_unchecked<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$next@PAPAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@H@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Off$ = 12						; size = 4
??$next@PAPAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@H@Z PROC ; std::next<STTriangleMesh * *>, COMDAT

; 1254 : 	{	// increment iterator

	push	ebp
	mov	ebp, esp

; 1255 : 	static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1256 : 
; 1257 : 	_STD advance(_First, _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$advance@PAPAVSTTriangleMesh@@H@std@@YAXAAPAPAVSTTriangleMesh@@H@Z ; std::advance<STTriangleMesh * *,int>
	add	esp, 8

; 1258 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 1259 : 	}

	pop	ebp
	ret	0
??$next@PAPAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@H@Z ENDP ; std::next<STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Ucopy<STTriangleMesh * *>, COMDAT
; _this$ = ecx

; 1822 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1823 : 		return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninitialized_copy@PAPAVSTTriangleMesh@@PAPAV1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@0PAPAV1@AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ; std::_Uninitialized_copy<STTriangleMesh * *,STTriangleMesh * *,std::allocator<STTriangleMesh *> >
	add	esp, 16					; 00000010H

; 1824 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Ucopy<STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$distance@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0@Z PROC ; std::distance<STTriangleMesh * *>, COMDAT

; 1240 : 	{	// return distance between iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 1241 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Distance1@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 1242 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$distance@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0@Z ENDP ; std::distance<STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Adl_verify_range1<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 602  : 	{	// check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp

; 603  : 	_Verify_range(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Verify_range@PAVSTTriangleMesh@@@std@@YAXQBQAVSTTriangleMesh@@0@Z ; std::_Verify_range<STTriangleMesh *>
	add	esp, 8

; 604  : 	}

	pop	ebp
	ret	0
??$_Adl_verify_range1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Adl_verify_range1<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Verify_range@PAVSTTriangleMesh@@@std@@YAXQBQAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Verify_range@PAVSTTriangleMesh@@@std@@YAXQBQAVSTTriangleMesh@@0@Z PROC ; std::_Verify_range<STTriangleMesh *>, COMDAT

; 558  : 	{	// special case range verification for pointers

	push	ebp
	mov	ebp, esp
$LN4@Verify_ran:

; 559  : 	_STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	ja	SHORT $LN7@Verify_ran
	jmp	SHORT $LN2@Verify_ran
$LN7@Verify_ran:
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	559					; 0000022fH
	push	OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@Verify_ran
	int	3
$LN11@Verify_ran:
	push	0
	push	559					; 0000022fH
	push	OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
	push	OFFSET ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN7@Verify_ran
$LN2@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN4@Verify_ran

; 560  : 	}

	pop	ebp
	ret	0
??$_Verify_range@PAVSTTriangleMesh@@@std@@YAXQBQAVSTTriangleMesh@@0@Z ENDP ; std::_Verify_range<STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>, COMDAT
; _this$ = ecx

; 2144 : 		{	// construct with compatible pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2143 : 		: _Mypair(_Zero_then_variadic_args_t(), _Ptr)

	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>

; 2145 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 297  : 	__PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1843 : 	__PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z PROC	; std::_Find_elem<char,29>, COMDAT

; 91   : 	{	// lookup _Ch in array storing NUL-terminated string _Base

	push	ebp
	mov	ebp, esp

; 92   : 		// pre: _Base contains no nulls except for _Base[_Base_size - 1]
; 93   : 	return (static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base));

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Base$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	call	??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ; std::_Find_unchecked<char const *,char>
	add	esp, 12					; 0000000cH
	sub	eax, DWORD PTR __Base$[ebp]

; 94   : 	}

	pop	ebp
	ret	0
??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ENDP	; std::_Find_elem<char,29>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 188  : 		{	// get values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 		_Dp = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2 *>(nullptr), _Cvt);

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	push	0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	push	edx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], al

; 190  : 		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2 *>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+13], al

; 191  : 		}

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 634  : 	{	// convert char to _Elem using _Cvtvec

	push	ebp
	mov	ebp, esp

; 635  : 	return ((_Elem)(unsigned char)_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 636  : 	}

	pop	ebp
	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptrdest$ = -12					; size = 4
__Ptrnext$1 = -8					; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 664  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 665  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR __Count$[ebp], eax

; 666  : 
; 667  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	push	668					; 0000029cH
	push	OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	push	1
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	__calloc_dbg
	add	esp, 20					; 00000014H
	mov	DWORD PTR __Ptrdest$[ebp], eax

; 668  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 669  : 
; 670  : 	if (!_Ptrdest)

	cmp	DWORD PTR __Ptrdest$[ebp], 0
	jne	SHORT $LN5@Maklocstr

; 671  : 		_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN5@Maklocstr:

; 672  : 
; 673  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	edx, DWORD PTR __Ptrdest$[ebp]
	mov	DWORD PTR __Ptrnext$1[ebp], edx
	jmp	SHORT $LN4@Maklocstr
$LN2@Maklocstr:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Ptrnext$1[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptrnext$1[ebp], ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Maklocstr

; 674  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	eax, DWORD PTR __Ptrnext$1[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 675  : 
; 676  : 	return (_Ptrdest);

	mov	eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 677  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Old_ptr$1 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__Al$ = -20						; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3922 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], edx

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3930 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3931 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3935 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 3940 : 			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	eax, DWORD PTR __Old_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3943 : 			}
; 3944 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3945 : 			{
; 3946 : 			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	ecx, BYTE PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3947 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3948 : 			}
; 3949 : 
; 3950 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$ = ecx

; 3241 : 				const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3242 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 3243 : 			_Traits::assign(_New_ptr[_Old_size], _Ch);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3244 : 			_Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3245 : 			}, _Ch);

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z PROC	; std::_Find_elem<char,27>, COMDAT

; 91   : 	{	// lookup _Ch in array storing NUL-terminated string _Base

	push	ebp
	mov	ebp, esp

; 92   : 		// pre: _Base contains no nulls except for _Base[_Base_size - 1]
; 93   : 	return (static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base));

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Base$[ebp]
	add	ecx, 26					; 0000001aH
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	call	??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ; std::_Find_unchecked<char const *,char>
	add	esp, 12					; 0000000cH
	sub	eax, DWORD PTR __Base$[ebp]

; 94   : 	}

	pop	ebp
	ret	0
??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z ENDP	; std::_Find_elem<char,27>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z PROC		; std::_Find_elem<char,15>, COMDAT

; 91   : 	{	// lookup _Ch in array storing NUL-terminated string _Base

	push	ebp
	mov	ebp, esp

; 92   : 		// pre: _Base contains no nulls except for _Base[_Base_size - 1]
; 93   : 	return (static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base));

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Base$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	call	??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ; std::_Find_unchecked<char const *,char>
	add	esp, 12					; 0000000cH
	sub	eax, DWORD PTR __Base$[ebp]

; 94   : 	}

	pop	ebp
	ret	0
??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z ENDP		; std::_Find_elem<char,15>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 648  : 	{	// test for istreambuf_iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx

; 649  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 650  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Old_ptr$1 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__Al$ = -20						; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3922 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], edx

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3930 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3931 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3935 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 3940 : 			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	edx, DWORD PTR __Old_capacity$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 3943 : 			}
; 3944 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3945 : 			{
; 3946 : 			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 3947 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3948 : 			}
; 3949 : 
; 3950 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$ = ecx

; 3352 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3353 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

	mov	eax, DWORD PTR __Old_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 3354 : 				});

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBEXQADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT
__Str$ = -76						; size = 28
$T2 = -48						; size = 4
tv174 = -44						; size = 4
tv156 = -40						; size = 4
__Ans$ = -36						; size = 4
__Off$3 = -32						; size = 4
__Column$4 = -28					; size = 4
__Field$5 = -24						; size = 4
__Off$6 = -20						; size = 4
__Prefix$7 = -13					; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z PROC ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 555  : 	{	// find field at _Ptr that matches longest in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	esi

; 556  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	DWORD PTR __Off$3[ebp], 0
	jmp	SHORT $LN4@Getloctxt
$LN2@Getloctxt:
	mov	eax, DWORD PTR __Off$3[ebp]
	add	eax, 1
	mov	DWORD PTR __Off$3[ebp], eax
$LN4@Getloctxt:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Off$3[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Getloctxt

; 557  : 		if (_Ptr[_Off] == _Ptr[0])

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR __Ptr$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	jne	SHORT $LN13@Getloctxt

; 558  : 			++_Numfields;	// add fields with leading mark to initial count

	mov	ecx, DWORD PTR __Numfields$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Numfields$[ebp], ecx
$LN13@Getloctxt:

; 559  : 	string _Str(_Numfields, '\0');	// one column counter for each field

	jmp	SHORT $LN2@Getloctxt
$LN3@Getloctxt:
	push	0
	mov	edx, DWORD PTR __Numfields$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 560  : 
; 561  : 	int _Ans = -2;	// no candidates so far

	mov	DWORD PTR __Ans$[ebp], -2		; fffffffeH

; 562  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	mov	DWORD PTR __Column$4[ebp], 1
	jmp	SHORT $LN7@Getloctxt
$LN5@Getloctxt:
	mov	eax, DWORD PTR __Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR __Column$4[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	DWORD PTR __Ans$[ebp], -1
$LN7@Getloctxt:

; 563  : 		{	// test each element against all viable fields
; 564  : 		bool _Prefix = false;	// seen at least one valid prefix

	mov	BYTE PTR __Prefix$7[ebp], 0

; 565  : 		size_t _Off = 0;	// offset into fields

	mov	DWORD PTR __Off$6[ebp], 0

; 566  : 		size_t _Field = 0;	// current field number

	mov	DWORD PTR __Field$5[ebp], 0

; 567  : 
; 568  : 		for (; _Field < _Numfields; ++_Field)

	jmp	SHORT $LN10@Getloctxt
$LN8@Getloctxt:
	mov	ecx, DWORD PTR __Field$5[ebp]
	add	ecx, 1
	mov	DWORD PTR __Field$5[ebp], ecx
$LN10@Getloctxt:
	mov	edx, DWORD PTR __Field$5[ebp]
	cmp	edx, DWORD PTR __Numfields$[ebp]
	jae	$LN9@Getloctxt
$LN11@Getloctxt:

; 569  : 			{	// test element at _Column in field _Field
; 570  : 			while (_Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0])

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$6[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@Getloctxt
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, DWORD PTR __Off$6[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	je	SHORT $LN12@Getloctxt

; 571  : 				{	// find beginning of field
; 572  : 				++_Off;

	mov	eax, DWORD PTR __Off$6[ebp]
	add	eax, 1
	mov	DWORD PTR __Off$6[ebp], eax

; 573  : 				}

	jmp	SHORT $LN11@Getloctxt
$LN12@Getloctxt:

; 574  : 
; 575  : 			if (_Str[_Field] != '\0')

	mov	ecx, DWORD PTR __Field$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN14@Getloctxt

; 576  : 				{
; 577  : 				_Off += _Str[_Field];	// skip tested columns in field

	mov	eax, DWORD PTR __Field$5[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR __Off$6[ebp]
	mov	DWORD PTR __Off$6[ebp], ecx
	jmp	$LN15@Getloctxt
$LN14@Getloctxt:

; 578  : 				}
; 579  : 			else if (_Ptr[_Off += _Column] == _Ptr[0] || _Ptr[_Off] == (_Elem)0)

	mov	edx, DWORD PTR __Off$6[ebp]
	add	edx, DWORD PTR __Column$4[ebp]
	mov	DWORD PTR __Off$6[ebp], edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Off$6[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR __Ptr$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	je	SHORT $LN18@Getloctxt
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Off$6[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN16@Getloctxt
$LN18@Getloctxt:

; 580  : 				{	// matched all of field, save as possible answer
; 581  : 				_Str[_Field] = (char)(_Column < 127 ? _Column : 127);	// save skip count if small enough

	cmp	DWORD PTR __Column$4[ebp], 127		; 0000007fH
	jae	SHORT $LN25@Getloctxt
	mov	eax, DWORD PTR __Column$4[ebp]
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN26@Getloctxt
$LN25@Getloctxt:
	mov	DWORD PTR tv156[ebp], 127		; 0000007fH
$LN26@Getloctxt:
	mov	ecx, DWORD PTR __Field$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	dl, BYTE PTR tv156[ebp]
	mov	BYTE PTR [eax], dl

; 582  : 				_Ans = (int)_Field;	// save answer

	mov	eax, DWORD PTR __Field$5[ebp]
	mov	DWORD PTR __Ans$[ebp], eax
	jmp	SHORT $LN15@Getloctxt
$LN16@Getloctxt:

; 583  : 				}
; 584  : 			else if (_First == _Last || _Ptr[_Off] != *_First)

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@Getloctxt
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Off$6[ebp]
	movsx	esi, BYTE PTR [ecx]
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	cmp	esi, edx
	je	SHORT $LN19@Getloctxt
$LN21@Getloctxt:

; 585  : 				{
; 586  : 				_Str[_Field] = (char)(_Column < 127 ? _Column : 127);	// no match, just save skip count

	cmp	DWORD PTR __Column$4[ebp], 127		; 0000007fH
	jae	SHORT $LN27@Getloctxt
	mov	eax, DWORD PTR __Column$4[ebp]
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN28@Getloctxt
$LN27@Getloctxt:
	mov	DWORD PTR tv174[ebp], 127		; 0000007fH
$LN28@Getloctxt:
	mov	ecx, DWORD PTR __Field$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	dl, BYTE PTR tv174[ebp]
	mov	BYTE PTR [eax], dl

; 587  : 				}
; 588  : 			else

	jmp	SHORT $LN15@Getloctxt
$LN19@Getloctxt:

; 589  : 				{
; 590  : 				_Prefix = true;	// still a valid prefix

	mov	BYTE PTR __Prefix$7[ebp], 1
$LN15@Getloctxt:

; 591  : 				}
; 592  : 			}

	jmp	$LN8@Getloctxt
$LN9@Getloctxt:

; 593  : 
; 594  : 		if (!_Prefix || _First == _Last)

	movzx	eax, BYTE PTR __Prefix$7[ebp]
	test	eax, eax
	je	SHORT $LN23@Getloctxt
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@Getloctxt
$LN23@Getloctxt:

; 595  : 			break;	// no pending prefixes or no input, give up

	jmp	SHORT $LN6@Getloctxt
$LN22@Getloctxt:

; 596  : 		}

	jmp	$LN5@Getloctxt
$LN6@Getloctxt:

; 597  : 	return (_Ans);	// return field number or negative value on failure

	mov	ecx, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]

; 598  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ENDP ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 639  : 	{	// test for istreambuf_iterator equality

	push	ebp
	mov	ebp, esp

; 640  : 	return (_Left.equal(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 641  : 	}

	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 615  : 	{	// check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp
	push	ecx

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adl_verify_range1@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ; std::_Adl_verify_range1<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 12					; 0000000cH

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<STTriangleMesh *> >, COMDAT

; 1145 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

	push	ebp
	mov	ebp, esp

; 1146 : 		// nothing to do
; 1147 : 	}

	pop	ebp
	ret	0
??$_Destroy_range1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<enum TextureType *> >, COMDAT

; 1145 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

	push	ebp
	mov	ebp, esp

; 1146 : 		// nothing to do
; 1147 : 	}

	pop	ebp
	ret	0
??$_Destroy_range1@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_value_construct_n1@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >, COMDAT

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	push	ebp
	mov	ebp, esp

; 336  : 	return (_Zero_range(_First, _First + _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Zero_range@PAPAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@0@Z ; std::_Zero_range<enum TextureType * *>
	add	esp, 8

; 337  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_value_construct_n1@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@PAW4TextureType@@@std@@YAXAAPAPAW4TextureType@@QAPAW41@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@PAW4TextureType@@@std@@YAXAAPAPAW4TextureType@@QAPAW41@@Z PROC ; std::_Seek_wrapped<enum TextureType *>, COMDAT

; 871  : 	{

	push	ebp
	mov	ebp, esp

; 872  : 	_It = _UIt;

	mov	eax, DWORD PTR __It$[ebp]
	mov	ecx, DWORD PTR __UIt$[ebp]
	mov	DWORD PTR [eax], ecx

; 873  : 	}

	pop	ebp
	ret	0
??$_Seek_wrapped@PAW4TextureType@@@std@@YAXAAPAPAW4TextureType@@QAPAW41@@Z ENDP ; std::_Seek_wrapped<enum TextureType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAW4TextureType@@PAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@00AAV?$allocator@PAW4TextureType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@PAW4TextureType@@PAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@00AAV?$allocator@PAW4TextureType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<enum TextureType *,enum TextureType *,std::allocator<enum TextureType *> >, COMDAT

; 201  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp

; 202  : 	return (_Copy_memmove(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAW4TextureType@@PAPAW41@@std@@YAPAPAW4TextureType@@PAPAW41@00@Z ; std::_Copy_memmove<enum TextureType * *,enum TextureType * *>
	add	esp, 12					; 0000000cH

; 203  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAW4TextureType@@PAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@00AAV?$allocator@PAW4TextureType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<enum TextureType *,enum TextureType *,std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAW4TextureType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4TextureType@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@PAW4TextureType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4TextureType@@0@Z PROC ; std::_Ptr_copy_cat<enum TextureType *,enum TextureType *>, COMDAT

; 1069 : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp

; 1070 : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1071 : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@PAW4TextureType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4TextureType@@0@Z ENDP ; std::_Ptr_copy_cat<enum TextureType *,enum TextureType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@PAW4TextureType@@H$0A@@std@@YAPAPAW4TextureType@@QAPAW41@H@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@PAW4TextureType@@H$0A@@std@@YAPAPAW4TextureType@@QAPAW41@H@Z PROC ; std::_Get_unwrapped_n<enum TextureType *,int,0>, COMDAT

; 808  : 	{

	push	ebp
	mov	ebp, esp

; 809  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 810  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped_n@PAW4TextureType@@H$0A@@std@@YAPAPAW4TextureType@@QAPAW41@H@Z ENDP ; std::_Get_unwrapped_n<enum TextureType *,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<enum TextureType * *,enum TextureType * *>, COMDAT

; 967  : 	{	// _Idl_distance for random-access iterators

	push	ebp
	mov	ebp, esp

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 969  : 	}

	pop	ebp
	ret	0
??$_Idl_distance1@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<enum TextureType * *,enum TextureType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0@Z PROC ; std::_Idl_distance<enum TextureType * *,enum TextureType * *>, COMDAT

; 974  : 	{	// tries to get the distance between _First and _Last if they are random-access iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Idl_distance1@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<enum TextureType * *,enum TextureType * *>
	add	esp, 12					; 0000000cH

; 976  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Idl_distance@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0@Z ENDP ; std::_Idl_distance<enum TextureType * *,enum TextureType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z PROC ; std::_Get_unwrapped<enum TextureType *>, COMDAT

; 662  : 	{	// special case already-unwrapped pointers

	push	ebp
	mov	ebp, esp

; 663  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 664  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z ENDP ; std::_Get_unwrapped<enum TextureType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<enum MeshType *> >, COMDAT

; 1145 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

	push	ebp
	mov	ebp, esp

; 1146 : 		// nothing to do
; 1147 : 	}

	pop	ebp
	ret	0
??$_Destroy_range1@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_value_construct_n1@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >, COMDAT

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	push	ebp
	mov	ebp, esp

; 336  : 	return (_Zero_range(_First, _First + _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Zero_range@PAPAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@0@Z ; std::_Zero_range<enum MeshType * *>
	add	esp, 8

; 337  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_value_construct_n1@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@PAW4MeshType@@@std@@YAXAAPAPAW4MeshType@@QAPAW41@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@PAW4MeshType@@@std@@YAXAAPAPAW4MeshType@@QAPAW41@@Z PROC ; std::_Seek_wrapped<enum MeshType *>, COMDAT

; 871  : 	{

	push	ebp
	mov	ebp, esp

; 872  : 	_It = _UIt;

	mov	eax, DWORD PTR __It$[ebp]
	mov	ecx, DWORD PTR __UIt$[ebp]
	mov	DWORD PTR [eax], ecx

; 873  : 	}

	pop	ebp
	ret	0
??$_Seek_wrapped@PAW4MeshType@@@std@@YAXAAPAPAW4MeshType@@QAPAW41@@Z ENDP ; std::_Seek_wrapped<enum MeshType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 436  : 		constexpr _Unused_parameter(_Ty&&) noexcept {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAW4MeshType@@PAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@00AAV?$allocator@PAW4MeshType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked@PAW4MeshType@@PAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@00AAV?$allocator@PAW4MeshType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<enum MeshType *,enum MeshType *,std::allocator<enum MeshType *> >, COMDAT

; 201  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp

; 202  : 	return (_Copy_memmove(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAW4MeshType@@PAPAW41@@std@@YAPAPAW4MeshType@@PAPAW41@00@Z ; std::_Copy_memmove<enum MeshType * *,enum MeshType * *>
	add	esp, 12					; 0000000cH

; 203  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAW4MeshType@@PAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@00AAV?$allocator@PAW4MeshType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<enum MeshType *,enum MeshType *,std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAW4MeshType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4MeshType@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@PAW4MeshType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4MeshType@@0@Z PROC ; std::_Ptr_copy_cat<enum MeshType *,enum MeshType *>, COMDAT

; 1069 : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp

; 1070 : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1071 : 	}

	pop	ebp
	ret	0
??$_Ptr_copy_cat@PAW4MeshType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4MeshType@@0@Z ENDP ; std::_Ptr_copy_cat<enum MeshType *,enum MeshType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@PAW4MeshType@@H$0A@@std@@YAPAPAW4MeshType@@QAPAW41@H@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@PAW4MeshType@@H$0A@@std@@YAPAPAW4MeshType@@QAPAW41@H@Z PROC ; std::_Get_unwrapped_n<enum MeshType *,int,0>, COMDAT

; 808  : 	{

	push	ebp
	mov	ebp, esp

; 809  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 810  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped_n@PAW4MeshType@@H$0A@@std@@YAPAPAW4MeshType@@QAPAW41@H@Z ENDP ; std::_Get_unwrapped_n<enum MeshType *,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<enum MeshType * *,enum MeshType * *>, COMDAT

; 967  : 	{	// _Idl_distance for random-access iterators

	push	ebp
	mov	ebp, esp

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 969  : 	}

	pop	ebp
	ret	0
??$_Idl_distance1@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<enum MeshType * *,enum MeshType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0@Z PROC ; std::_Idl_distance<enum MeshType * *,enum MeshType * *>, COMDAT

; 974  : 	{	// tries to get the distance between _First and _Last if they are random-access iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Idl_distance1@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<enum MeshType * *,enum MeshType * *>
	add	esp, 12					; 0000000cH

; 976  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Idl_distance@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0@Z ENDP ; std::_Idl_distance<enum MeshType * *,enum MeshType * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z PROC ; std::_Get_unwrapped<enum MeshType *>, COMDAT

; 662  : 	{	// special case already-unwrapped pointers

	push	ebp
	mov	ebp, esp

; 663  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 664  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z ENDP ; std::_Get_unwrapped<enum MeshType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 92   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 94   : 	if (_Block_size <= _Bytes)

	mov	ecx, DWORD PTR __Block_size$[ebp]
	cmp	ecx, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN8@Allocate_m

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);

	mov	DWORD PTR __Block_size$[ebp], -1
$LN8@Allocate_m:

; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	edx, DWORD PTR __Block_size$[ebp]
	push	edx
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	je	SHORT $LN7@Allocate_m
	jmp	SHORT $LN2@Allocate_m
$LN7@Allocate_m:
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	101					; 00000065H
	push	OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
$LN12@Allocate_m:
	push	0
	push	101					; 00000065H
	push	OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@Allocate_m
$LN2@Allocate_m:
	xor	edx, edx
	jne	SHORT $LN4@Allocate_m

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	mov	eax, DWORD PTR __Ptr_container$[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	ecx, 4
	imul	edx, ecx, -1
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	edx, 4
	imul	eax, edx, -2
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx+eax], -84215046		; fafafafaH

; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1088 : 	{	// propagate on container move assignment

	push	ebp
	mov	ebp, esp

; 1089 : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4

; 1090 : 	}

	pop	ebp
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<STTriangleMesh *> >, COMDAT

; 1075 : 	{	// (don't) propagate on container copy assignment

	push	ebp
	mov	ebp, esp

; 1076 : 	}

	pop	ebp
	ret	0
??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@W4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z PROC ; std::forward<enum TextureType>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@W4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ENDP ; std::forward<enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABW4TextureType@@@std@@YAABW4TextureType@@ABW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABW4TextureType@@@std@@YAABW4TextureType@@ABW41@@Z PROC ; std::forward<enum TextureType const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@ABW4TextureType@@@std@@YAABW4TextureType@@ABW41@@Z ENDP ; std::forward<enum TextureType const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@W4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z PROC ; std::forward<enum MeshType>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@W4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ENDP ; std::forward<enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABW4MeshType@@@std@@YAABW4MeshType@@ABW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABW4MeshType@@@std@@YAABW4MeshType@@ABW41@@Z PROC ; std::forward<enum MeshType const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@ABW4MeshType@@@std@@YAABW4MeshType@@ABW41@@Z ENDP ; std::forward<enum MeshType const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Meta$ = -8						; size = 4
_this$ = -4						; size = 4
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT
; _this$ = ecx

; 617  : 		{	// peek at next input element

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 618  : 		int_type _Meta;
; 619  : 		if (_Strbuf == nullptr
; 620  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Peek
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR __Meta$[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T1[ebp], eax
	lea	edx, DWORD PTR __Meta$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Peek
$LN4@Peek:

; 621  : 				_Meta = _Strbuf->sgetc()))
; 622  : 			_Strbuf = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 623  : 		else

	jmp	SHORT $LN3@Peek
$LN2@Peek:

; 624  : 			_Val = traits_type::to_char_type(_Meta);

	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5], al
$LN3@Peek:

; 625  : 		_Got = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1

; 626  : 		return (_Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+5]

; 627  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT
; _this$ = ecx

; 602  : 		{	// skip to next input element

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (_Strbuf == nullptr
; 604  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Inc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
	mov	DWORD PTR $T2[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T1[ebp], eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Inc
$LN4@Inc:

; 605  : 				_Strbuf->sbumpc()))
; 606  : 			{
; 607  : 			_Strbuf = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 608  : 			_Got = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 609  : 			}
; 610  : 		else

	jmp	SHORT $LN1@Inc
$LN2@Inc:

; 611  : 			{
; 612  : 			_Got = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
$LN1@Inc:

; 613  : 			}
; 614  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT
; _this$ = ecx

; 591  : 		{	// test for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 592  : 		if (!_Got)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@equal

; 593  : 			_Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN2@equal:

; 594  : 		if (!_Right._Got)

	mov	edx, DWORD PTR __Right$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	test	eax, eax
	jne	SHORT $LN3@equal

; 595  : 			_Right._Peek();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN3@equal:

; 596  : 		return ((_Strbuf == nullptr && _Right._Strbuf == nullptr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN5@equal
	mov	edx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@equal
$LN5@equal:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@equal
	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN7@equal
$LN6@equal:
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN8@equal
$LN7@equal:
	mov	DWORD PTR tv80[ebp], 1
$LN8@equal:
	mov	al, BYTE PTR tv80[ebp]

; 597  : 			|| (_Strbuf != nullptr && _Right._Strbuf != nullptr));
; 598  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 572  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@operator:

; 573  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 574  : 		_STL_VERIFY(_Strbuf != nullptr, "istreambuf_iterator is not incrementable");

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0CJ@JANLIC@istreambuf_iterator?5is?5not?5incr@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	574					; 0000023eH
	push	OFFSET ??_C@_0GK@MKMOJOPB@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	push	0
	push	574					; 0000023eH
	push	OFFSET ??_C@_1NE@KHFMDOHB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1JG@KCHMIAPO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@
	push	OFFSET ??_C@_1FG@EPFFBKIL@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	eax, eax
	jne	SHORT $LN4@operator

; 575  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 576  : 
; 577  : 		_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc

; 578  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 560  : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		if (!_Got)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN4@operator

; 562  : 			_Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN4@operator:

; 563  : 
; 564  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 565  : 		_STL_VERIFY(_Strbuf != nullptr, "istreambuf_iterator is not dereferencable");

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0CK@IACNJOAE@istreambuf_iterator?5is?5not?5dere@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	565					; 00000235H
	push	OFFSET ??_C@_0GK@MKMOJOPB@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN12@operator
	int	3
$LN12@operator:
	push	0
	push	565					; 00000235H
	push	OFFSET ??_C@_1NE@KHFMDOHB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1JE@DOOFMCFJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf@
	push	OFFSET ??_C@_1FI@NCHBPOBH@?$AA?$CC?$AAi?$AAs?$AAt?$AAr?$AAe?$AAa?$AAm?$AAb?$AAu?$AAf?$AA_?$AAi?$AAt?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	edx, edx
	jne	SHORT $LN4@operator

; 566  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 567  : 
; 568  : 		return (_Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+5]

; 569  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
tv79 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct from stream buffer in istream _Istr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 525  : 		: _Strbuf(_Istr.rdbuf()),

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 526  : 		_Got(_Strbuf == nullptr),

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@istreambuf
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@istreambuf
$LN3@istreambuf:
	mov	DWORD PTR tv79[ebp], 0
$LN4@istreambuf:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv79[ebp]
	mov	BYTE PTR [eax+4], cl

; 527  : 		_Val()

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0

; 529  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 514  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		: _Strbuf(nullptr),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 512  : 		_Got(true),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1

; 513  : 		_Val()

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0

; 515  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
__Grouping$ = -204					; size = 28
$T2 = -176						; size = 8
$T3 = -168						; size = 8
__Numget_poff$ = -160					; size = 4
__Numget_xoff$ = -156					; size = 4
__Numget_signoff$ = -152				; size = 4
__Groups$4 = -148					; size = 28
$T5 = -120						; size = 4
__Ctype_fac$ = -116					; size = 4
tv442 = -112						; size = 4
tv72 = -108						; size = 4
tv439 = -104						; size = 4
tv445 = -100						; size = 4
__Atoms$ = -96						; size = 29
tv249 = -64						; size = 4
tv182 = -60						; size = 4
__Max_sig_dig$ = -56					; size = 4
__Punct_fac$ = -52					; size = 4
__Pg$ = -48						; size = 4
__Phex$ = -44						; size = 4
__Kseparator$6 = -38					; size = 1
tv215 = -37						; size = 1
__Idx$ = -36						; size = 4
__Group$7 = -32						; size = 4
__Significant$ = -28					; size = 4
__Bad$ = -21						; size = 1
__Ptr$ = -20						; size = 4
__Seendigit$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx, COMDAT

; 1173 : 		{	// get hex floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 192				; 000000c0H
	push	esi

; 1174 : 		const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv445[ebp], eax
	mov	ecx, DWORD PTR tv445[ebp]
	mov	DWORD PTR tv439[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv439[ebp]
	push	edx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1175 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1176 : 
; 1177 : 		constexpr int _Numget_signoff = 22;

	mov	DWORD PTR __Numget_signoff$[ebp], 22	; 00000016H

; 1178 : 		constexpr int _Numget_xoff = 24;

	mov	DWORD PTR __Numget_xoff$[ebp], 24	; 00000018H

; 1179 : 		constexpr int _Numget_poff = 26;

	mov	DWORD PTR __Numget_poff$[ebp], 26	; 0000001aH

; 1180 : 		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
; 1181 : 		_Elem _Atoms[sizeof (_Src)];
; 1182 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv72[ebp], eax
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv442[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv442[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1183 : 		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 29
	add	eax, OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	add	edx, OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	push	edx
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 1184 : 
; 1185 : 		char *_Ptr = _Ac;

	mov	eax, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1186 : 		bool _Bad = false;

	mov	BYTE PTR __Bad$[ebp], 0

; 1187 : 		size_t _Idx;
; 1188 : 
; 1189 : 		if (_First != _Last)

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@Getffldx

; 1190 : 			{
; 1191 : 			if (*_First == _Atoms[_Numget_signoff + 1])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 23
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN23@Getffldx

; 1192 : 				{	// gather plus sign
; 1193 : 				*_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1194 : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN22@Getffldx
$LN23@Getffldx:

; 1195 : 				}
; 1196 : 			else if (*_First == _Atoms[_Numget_signoff])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 22
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN22@Getffldx

; 1197 : 				{	// gather minus sign
; 1198 : 				*_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1199 : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN22@Getffldx:

; 1200 : 				}
; 1201 : 			}
; 1202 : 
; 1203 : 		*_Ptr++ = '0';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1204 : 		*_Ptr++ = 'x';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 120			; 00000078H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1205 : 
; 1206 : 		bool _Seendigit = false;	// seen a digit in input

	mov	BYTE PTR __Seendigit$[ebp], 0

; 1207 : 		int _Significant = 0;	// number of significant digits

	mov	DWORD PTR __Significant$[ebp], 0

; 1208 : 		int _Phex = 0;	// power of 10 multiplier

	mov	DWORD PTR __Phex$[ebp], 0

; 1209 : 
; 1210 : 		if (_First != _Last && *_First == _Atoms[0])

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 0
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN26@Getffldx

; 1211 : 			{
; 1212 : 			if (++_First != _Last
; 1213 : 				&& (*_First == _Atoms[_Numget_xoff + 1]

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN27@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 25
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	je	SHORT $LN29@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 24
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN27@Getffldx
$LN29@Getffldx:

; 1214 : 					|| *_First == _Atoms[_Numget_xoff]))
; 1215 : 				{
; 1216 : 				++_First;	// discard any 0x or 0X

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 1217 : 				}
; 1218 : 			else

	jmp	SHORT $LN26@Getffldx
$LN27@Getffldx:

; 1219 : 				{
; 1220 : 				_Seendigit = true;	// '0' not followed by 'x' or 'X'

	mov	BYTE PTR __Seendigit$[ebp], 1
$LN26@Getffldx:

; 1221 : 				}
; 1222 : 			}
; 1223 : 
; 1224 : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	eax, DWORD PTR __Phexexp$[ebp]
	cmp	DWORD PTR [eax], 1000000000		; 3b9aca00H
	jne	SHORT $LN72@Getffldx
	mov	DWORD PTR tv182[ebp], 768		; 00000300H
	jmp	SHORT $LN73@Getffldx
$LN72@Getffldx:
	mov	DWORD PTR tv182[ebp], 36		; 00000024H
$LN73@Getffldx:
	mov	ecx, DWORD PTR tv182[ebp]
	mov	DWORD PTR __Max_sig_dig$[ebp], ecx

; 1225 : 
; 1226 : 		const char *_Pg = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$[ebp], eax

; 1227 : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN32@Getffldx
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jg	$LN30@Getffldx
$LN32@Getffldx:

; 1228 : 			{
; 1229 : 			for (; _First != _Last

	jmp	SHORT $LN4@Getffldx
$LN2@Getffldx:

; 1231 : 					_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN4@Getffldx:

; 1230 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 22		; 00000016H
	jae	SHORT $LN3@Getffldx

; 1232 : 				{
; 1233 : 				if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Max_sig_dig$[ebp]
	cmp	edx, DWORD PTR __Significant$[ebp]
	jg	SHORT $LN33@Getffldx

; 1234 : 					{
; 1235 : 					++_Phex;	// just scale by 10

	mov	eax, DWORD PTR __Phex$[ebp]
	add	eax, 1
	mov	DWORD PTR __Phex$[ebp], eax
	jmp	SHORT $LN34@Getffldx
$LN33@Getffldx:

; 1236 : 					}
; 1237 : 				else if (_Idx != 0 || _Significant != 0)

	cmp	DWORD PTR __Idx$[ebp], 0
	jne	SHORT $LN36@Getffldx
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN34@Getffldx
$LN36@Getffldx:

; 1238 : 					{	// save a significant digit
; 1239 : 					*_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1240 : 					++_Significant;

	mov	edx, DWORD PTR __Significant$[ebp]
	add	edx, 1
	mov	DWORD PTR __Significant$[ebp], edx
$LN34@Getffldx:

; 1241 : 					}
; 1242 : 				}

	jmp	$LN2@Getffldx
$LN3@Getffldx:

; 1243 : 			}
; 1244 : 		else

	jmp	$LN31@Getffldx
$LN30@Getffldx:

; 1245 : 			{	// grouping specified, gather digits and group sizes
; 1246 : 			const _Elem _Kseparator = _Grouping.size() == 0

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN74@Getffldx
	mov	BYTE PTR tv215[ebp], 0
	jmp	SHORT $LN75@Getffldx
$LN74@Getffldx:
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR tv215[ebp], al
$LN75@Getffldx:
	mov	al, BYTE PTR tv215[ebp]
	mov	BYTE PTR __Kseparator$6[ebp], al

; 1247 : 				? (_Elem)0 : _Punct_fac.thousands_sep();
; 1248 : 			string _Groups((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1249 : 			size_t _Group = 0;

	mov	DWORD PTR __Group$7[ebp], 0

; 1250 : 
; 1251 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN7@Getffldx
$LN5@Getffldx:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN7@Getffldx:
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN6@Getffldx

; 1252 : 				{
; 1253 : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff)

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 22		; 00000016H
	jae	SHORT $LN37@Getffldx

; 1254 : 					{	// got a digit, add to group size
; 1255 : 					_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 1256 : 					if (_Max_sig_dig <= _Significant)

	mov	eax, DWORD PTR __Max_sig_dig$[ebp]
	cmp	eax, DWORD PTR __Significant$[ebp]
	jg	SHORT $LN39@Getffldx

; 1257 : 						{
; 1258 : 						++_Phex;	// just scale by 10

	mov	ecx, DWORD PTR __Phex$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Phex$[ebp], ecx
	jmp	SHORT $LN40@Getffldx
$LN39@Getffldx:

; 1259 : 						}
; 1260 : 					else if (_Idx != 0 || _Significant != 0)

	cmp	DWORD PTR __Idx$[ebp], 0
	jne	SHORT $LN42@Getffldx
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN40@Getffldx
$LN42@Getffldx:

; 1261 : 						{	// save a significant digit
; 1262 : 						*_Ptr++ = _Src[_Idx];

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	cl, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1263 : 						++_Significant;

	mov	eax, DWORD PTR __Significant$[ebp]
	add	eax, 1
	mov	DWORD PTR __Significant$[ebp], eax
$LN40@Getffldx:

; 1264 : 						}
; 1265 : 
; 1266 : 					if (_Groups[_Group] != CHAR_MAX)

	mov	ecx, DWORD PTR __Group$7[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 127				; 0000007fH
	je	SHORT $LN43@Getffldx

; 1267 : 						{
; 1268 : 						++_Groups[_Group];

	mov	eax, DWORD PTR __Group$7[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR tv249[ebp], eax
	mov	ecx, DWORD PTR tv249[ebp]
	mov	dl, BYTE PTR [ecx]
	add	dl, 1
	mov	eax, DWORD PTR tv249[ebp]
	mov	BYTE PTR [eax], dl
$LN43@Getffldx:

; 1269 : 						}
; 1270 : 					}
; 1271 : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN38@Getffldx
$LN37@Getffldx:

; 1272 : 					|| _Kseparator == (_Elem)0
; 1273 : 					|| *_First != _Kseparator)

	mov	ecx, DWORD PTR __Group$7[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN46@Getffldx
	movsx	eax, BYTE PTR __Kseparator$6[ebp]
	test	eax, eax
	je	SHORT $LN46@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Kseparator$6[ebp]
	cmp	ecx, edx
	je	SHORT $LN44@Getffldx
$LN46@Getffldx:

; 1274 : 					{
; 1275 : 					break;	// not a group separator, done

	jmp	SHORT $LN6@Getffldx

; 1276 : 					}
; 1277 : 				else

	jmp	SHORT $LN38@Getffldx
$LN44@Getffldx:

; 1278 : 					{	// add a new group to _Groups string
; 1279 : 					_Groups.push_back('\0');

	push	0
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 1280 : 					++_Group;

	mov	eax, DWORD PTR __Group$7[ebp]
	add	eax, 1
	mov	DWORD PTR __Group$7[ebp], eax
$LN38@Getffldx:

; 1281 : 					}
; 1282 : 				}

	jmp	$LN5@Getffldx
$LN6@Getffldx:

; 1283 : 
; 1284 : 			if (_Group != 0)

	cmp	DWORD PTR __Group$7[ebp], 0
	je	SHORT $LN8@Getffldx

; 1285 : 				{
; 1286 : 				if ('\0' < _Groups[_Group])

	mov	ecx, DWORD PTR __Group$7[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jle	SHORT $LN48@Getffldx

; 1287 : 					{
; 1288 : 					++_Group;	// add trailing group to group count

	mov	eax, DWORD PTR __Group$7[ebp]
	add	eax, 1
	mov	DWORD PTR __Group$7[ebp], eax

; 1289 : 					}
; 1290 : 				else

	jmp	SHORT $LN8@Getffldx
$LN48@Getffldx:

; 1291 : 					{
; 1292 : 					_Bad = true;	// trailing separator, fail

	mov	BYTE PTR __Bad$[ebp], 1
$LN8@Getffldx:

; 1293 : 					}
; 1294 : 				}
; 1295 : 
; 1296 : 			while (!_Bad && 0 < _Group)

	movzx	ecx, BYTE PTR __Bad$[ebp]
	test	ecx, ecx
	jne	$LN9@Getffldx
	cmp	DWORD PTR __Group$7[ebp], 0
	jbe	SHORT $LN9@Getffldx

; 1297 : 				{
; 1298 : 				if (*_Pg == CHAR_MAX)

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jne	SHORT $LN50@Getffldx

; 1299 : 					{
; 1300 : 					break;	// end of grouping constraints to check

	jmp	SHORT $LN9@Getffldx
$LN50@Getffldx:

; 1301 : 					}
; 1302 : 
; 1303 : 				if ((0 < --_Group && *_Pg != _Groups[_Group])
; 1304 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	mov	ecx, DWORD PTR __Group$7[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Group$7[ebp], ecx
	je	SHORT $LN54@Getffldx
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	esi, BYTE PTR [edx]
	mov	eax, DWORD PTR __Group$7[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	esi, ecx
	jne	SHORT $LN53@Getffldx
$LN54@Getffldx:
	cmp	DWORD PTR __Group$7[ebp], 0
	jne	SHORT $LN51@Getffldx
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	esi, BYTE PTR [edx]
	mov	eax, DWORD PTR __Group$7[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	esi, ecx
	jge	SHORT $LN51@Getffldx
$LN53@Getffldx:

; 1305 : 					{
; 1306 : 					_Bad = true;	// bad group size, fail

	mov	BYTE PTR __Bad$[ebp], 1
	jmp	SHORT $LN52@Getffldx
$LN51@Getffldx:

; 1307 : 					}
; 1308 : 				else if ('\0' < _Pg[1])

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jle	SHORT $LN52@Getffldx

; 1309 : 					{
; 1310 : 					++_Pg;	// group size okay, advance to next test

	mov	edx, DWORD PTR __Pg$[ebp]
	add	edx, 1
	mov	DWORD PTR __Pg$[ebp], edx
$LN52@Getffldx:

; 1311 : 					}
; 1312 : 				}

	jmp	$LN8@Getffldx
$LN9@Getffldx:

; 1313 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@Getffldx:

; 1314 : 
; 1315 : 		if (_Seendigit && _Significant == 0)

	movzx	eax, BYTE PTR __Seendigit$[ebp]
	test	eax, eax
	je	SHORT $LN56@Getffldx
	cmp	DWORD PTR __Significant$[ebp], 0
	jne	SHORT $LN56@Getffldx

; 1316 : 			*_Ptr++ = '0';	// save at least one leading digit

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 48			; 00000030H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN56@Getffldx:

; 1317 : 
; 1318 : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN57@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	esi, al
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	movsx	eax, al
	cmp	esi, eax
	jne	SHORT $LN57@Getffldx

; 1319 : 			{	// add .
; 1320 : 			*_Ptr++ = localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1321 : 			++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN57@Getffldx:

; 1322 : 			}
; 1323 : 
; 1324 : 		if (_Significant == 0)

	cmp	DWORD PTR __Significant$[ebp], 0
	jne	SHORT $LN58@Getffldx

; 1325 : 			{	// 0000. so far
; 1326 : 			for (; _First != _Last && *_First == _Atoms[0];

	jmp	SHORT $LN12@Getffldx
$LN10@Getffldx:

; 1327 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN12@Getffldx:

; 1325 : 			{	// 0000. so far
; 1326 : 			for (; _First != _Last && *_First == _Atoms[0];

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 0
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN11@Getffldx

; 1328 : 				--_Phex;	// just count leading fraction zeros

	mov	eax, DWORD PTR __Phex$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Phex$[ebp], eax
	jmp	SHORT $LN10@Getffldx
$LN11@Getffldx:

; 1329 : 			if (_Phex < 0)

	cmp	DWORD PTR __Phex$[ebp], 0
	jge	SHORT $LN58@Getffldx

; 1330 : 				{	// put one back
; 1331 : 				*_Ptr++ = '0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 48			; 00000030H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1332 : 				++_Phex;

	mov	eax, DWORD PTR __Phex$[ebp]
	add	eax, 1
	mov	DWORD PTR __Phex$[ebp], eax
$LN58@Getffldx:

; 1333 : 				}
; 1334 : 			}
; 1335 : 
; 1336 : 		for (; _First != _Last

	jmp	SHORT $LN15@Getffldx
$LN13@Getffldx:

; 1338 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN15@Getffldx:

; 1337 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 22		; 00000016H
	jae	SHORT $LN14@Getffldx

; 1339 : 			if (_Significant < _Max_sig_dig)

	mov	eax, DWORD PTR __Significant$[ebp]
	cmp	eax, DWORD PTR __Max_sig_dig$[ebp]
	jge	SHORT $LN60@Getffldx

; 1340 : 				{	// save a significant fraction digit
; 1341 : 				*_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1342 : 				++_Significant;

	mov	edx, DWORD PTR __Significant$[ebp]
	add	edx, 1
	mov	DWORD PTR __Significant$[ebp], edx
$LN60@Getffldx:

; 1343 : 				}
; 1344 : 
; 1345 : 		if (_Seendigit && _First != _Last

	jmp	SHORT $LN13@Getffldx
$LN14@Getffldx:

; 1346 : 			&& (*_First == _Atoms[_Numget_poff + 1]

	movzx	eax, BYTE PTR __Seendigit$[ebp]
	test	eax, eax
	je	$LN61@Getffldx
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN61@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 27
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	je	SHORT $LN62@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 26
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	jne	$LN61@Getffldx
$LN62@Getffldx:

; 1347 : 				|| *_First == _Atoms[_Numget_poff]))
; 1348 : 			{	// 'p' or 'P', collect exponent
; 1349 : 			*_Ptr++ = 'p';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 112			; 00000070H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1350 : 			++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 1351 : 			_Seendigit = false;

	mov	BYTE PTR __Seendigit$[ebp], 0

; 1352 : 			_Significant = 0;

	mov	DWORD PTR __Significant$[ebp], 0

; 1353 : 
; 1354 : 			if (_First != _Last)

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN63@Getffldx

; 1355 : 				{
; 1356 : 				if (*_First == _Atoms[_Numget_signoff + 1])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 23
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN64@Getffldx

; 1357 : 					{	// gather plus sign
; 1358 : 					*_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1359 : 					++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN63@Getffldx
$LN64@Getffldx:

; 1360 : 					}
; 1361 : 				else if (*_First == _Atoms[_Numget_signoff])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 22
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN63@Getffldx

; 1362 : 					{	// gather minus sign
; 1363 : 					*_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1364 : 					++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN63@Getffldx:

; 1365 : 					}
; 1366 : 				}
; 1367 : 
; 1368 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	jmp	SHORT $LN18@Getffldx
$LN16@Getffldx:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN18@Getffldx:
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	jne	SHORT $LN17@Getffldx

; 1369 : 				{	// strip leading zeros
; 1370 : 				_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 1371 : 				}

	jmp	SHORT $LN16@Getffldx
$LN17@Getffldx:

; 1372 : 
; 1373 : 			if (_Seendigit)

	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	SHORT $LN67@Getffldx

; 1374 : 				*_Ptr++ = '0';	// put one back

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN67@Getffldx:

; 1375 : 			for (; _First != _Last

	jmp	SHORT $LN21@Getffldx
$LN19@Getffldx:

; 1377 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN21@Getffldx:

; 1376 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN61@Getffldx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR __Atoms$[ebp]
	push	eax
	call	??$_Find_elem@D$0BN@@std@@YAIAAY0BN@$$CBDD@Z ; std::_Find_elem<char,29>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 22		; 00000016H
	jae	SHORT $LN61@Getffldx

; 1378 : 				if (_Significant < _MAX_EXP_DIG)

	cmp	DWORD PTR __Significant$[ebp], 8
	jge	SHORT $LN68@Getffldx

; 1379 : 					{	// save a significant exponent digit
; 1380 : 					*_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1381 : 					++_Significant;

	mov	edx, DWORD PTR __Significant$[ebp]
	add	edx, 1
	mov	DWORD PTR __Significant$[ebp], edx
$LN68@Getffldx:

; 1382 : 					}
; 1383 : 			}

	jmp	SHORT $LN19@Getffldx
$LN61@Getffldx:

; 1384 : 
; 1385 : 		if (_Bad || !_Seendigit)

	movzx	eax, BYTE PTR __Bad$[ebp]
	test	eax, eax
	jne	SHORT $LN70@Getffldx
	movzx	ecx, BYTE PTR __Seendigit$[ebp]
	test	ecx, ecx
	jne	SHORT $LN69@Getffldx
$LN70@Getffldx:

; 1386 : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	edx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN69@Getffldx:

; 1387 : 		*_Ptr = '\0';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 0

; 1388 : 		*_Phexexp = _Phex;	// power of 16 multiplier

	mov	ecx, DWORD PTR __Phexexp$[ebp]
	mov	edx, DWORD PTR __Phex$[ebp]
	mov	DWORD PTR [ecx], edx

; 1389 : 		return (0);	// power of 10 multiplier

	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T5[ebp]

; 1390 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
__Grouping$ = -192					; size = 28
$T2 = -164						; size = 8
$T3 = -156						; size = 8
__Numget_eoff$ = -148					; size = 4
__Numget_signoff$ = -144				; size = 4
__Groups$4 = -140					; size = 28
$T5 = -112						; size = 4
__Ctype_fac$ = -108					; size = 4
tv434 = -104						; size = 4
tv83 = -100						; size = 4
tv431 = -96						; size = 4
tv437 = -92						; size = 4
__Leading$ = -88					; size = 4
tv227 = -84						; size = 4
tv158 = -80						; size = 4
__Atoms$ = -76						; size = 15
__Max_sig_dig$ = -60					; size = 4
__Punct_fac$ = -56					; size = 4
__Pg$ = -52						; size = 4
__Px$6 = -48						; size = 4
__Kseparator$7 = -42					; size = 1
tv192 = -41						; size = 1
__Pten$ = -40						; size = 4
__Significant$ = -36					; size = 4
__Idx$ = -32						; size = 4
__Group$8 = -28						; size = 4
__Bad$ = -22						; size = 1
__Sticky$ = -21						; size = 1
__Ptr$ = -20						; size = 4
__Seendigit$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld, COMDAT

; 932  : 		{	// get floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 180				; 000000b4H
	push	esi

; 933  : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN24@Getffld

; 934  : 			return (_Getffldx(_Ac, _First, _Last,

	mov	eax, DWORD PTR __Phexexp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
	add	esp, 24					; 00000018H
	jmp	$LN1@Getffld
$LN24@Getffld:

; 935  : 				_Iosbase, _Phexexp));	// hex format
; 936  : 
; 937  : 		const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv437[ebp], eax
	mov	ecx, DWORD PTR tv437[ebp]
	mov	DWORD PTR tv431[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv431[ebp]
	push	edx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 938  : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 939  : 		char *_Ptr = _Ac;

	mov	ecx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 940  : 		bool _Bad = false;

	mov	BYTE PTR __Bad$[ebp], 0

; 941  : 		bool _Sticky = false;

	mov	BYTE PTR __Sticky$[ebp], 0

; 942  : 
; 943  : 		constexpr int _Numget_signoff = 10;

	mov	DWORD PTR __Numget_signoff$[ebp], 10	; 0000000aH

; 944  : 		constexpr int _Numget_eoff = 12;

	mov	DWORD PTR __Numget_eoff$[ebp], 12	; 0000000cH

; 945  : 		static constexpr char _Src[] = {"0123456789-+Ee"};
; 946  : 		_Elem _Atoms[sizeof (_Src)];
; 947  : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv83[ebp], eax
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv434[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv434[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 948  : 		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 15
	add	ecx, OFFSET ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, OFFSET ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 949  : 
; 950  : 		if (_First != _Last)

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@Getffld

; 951  : 			{
; 952  : 			if (*_First == _Atoms[_Numget_signoff + 1])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 11
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN26@Getffld

; 953  : 				{	// gather plus sign
; 954  : 				*_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 955  : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN25@Getffld
$LN26@Getffld:

; 956  : 				}
; 957  : 			else if (*_First == _Atoms[_Numget_signoff])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 10
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN25@Getffld

; 958  : 				{	// gather minus sign
; 959  : 				*_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 960  : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN25@Getffld:

; 961  : 				}
; 962  : 			}
; 963  : 
; 964  : 		char *_Leading = _Ptr;	// remember backstop

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Leading$[ebp], eax

; 965  : 		*_Ptr++ = '0';	// backstop carries from sticky bit

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 48			; 00000030H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 966  : 
; 967  : 		bool _Seendigit = false;	// seen a digit in input

	mov	BYTE PTR __Seendigit$[ebp], 0

; 968  : 		int _Significant = 0;	// number of significant digits

	mov	DWORD PTR __Significant$[ebp], 0

; 969  : 		int _Pten = 0;	// power of 10 multiplier

	mov	DWORD PTR __Pten$[ebp], 0

; 970  : 		size_t _Idx;
; 971  : 
; 972  : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	eax, DWORD PTR __Phexexp$[ebp]
	cmp	DWORD PTR [eax], 1000000000		; 3b9aca00H
	jne	SHORT $LN78@Getffld
	mov	DWORD PTR tv158[ebp], 768		; 00000300H
	jmp	SHORT $LN79@Getffld
$LN78@Getffld:
	mov	DWORD PTR tv158[ebp], 36		; 00000024H
$LN79@Getffld:
	mov	ecx, DWORD PTR tv158[ebp]
	mov	DWORD PTR __Max_sig_dig$[ebp], ecx

; 973  : 
; 974  : 		const char *_Pg = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$[ebp], eax

; 975  : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN31@Getffld
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jg	$LN29@Getffld
$LN31@Getffld:

; 976  : 			{
; 977  : 			for (; _First != _Last

	jmp	SHORT $LN4@Getffld
$LN2@Getffld:

; 979  : 					_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN4@Getffld:

; 978  : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	call	??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z ; std::_Find_elem<char,15>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 10		; 0000000aH
	jae	SHORT $LN3@Getffld

; 980  : 				{
; 981  : 				if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Max_sig_dig$[ebp]
	cmp	edx, DWORD PTR __Significant$[ebp]
	jg	SHORT $LN32@Getffld

; 982  : 					{	// enough digits, scale by 10 and update _Sticky
; 983  : 					++_Pten;

	mov	eax, DWORD PTR __Pten$[ebp]
	add	eax, 1
	mov	DWORD PTR __Pten$[ebp], eax

; 984  : 					if (0 < _Idx)

	cmp	DWORD PTR __Idx$[ebp], 0
	jbe	SHORT $LN34@Getffld

; 985  : 						{
; 986  : 						_Sticky = true;

	mov	BYTE PTR __Sticky$[ebp], 1
$LN34@Getffld:

; 987  : 						}
; 988  : 					}

	jmp	SHORT $LN33@Getffld
$LN32@Getffld:

; 989  : 				else if (_Idx != 0 || _Significant != 0)

	cmp	DWORD PTR __Idx$[ebp], 0
	jne	SHORT $LN36@Getffld
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN33@Getffld
$LN36@Getffld:

; 990  : 					{	// save a significant digit
; 991  : 					*_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 992  : 					++_Significant;

	mov	edx, DWORD PTR __Significant$[ebp]
	add	edx, 1
	mov	DWORD PTR __Significant$[ebp], edx
$LN33@Getffld:

; 993  : 					}
; 994  : 				}

	jmp	$LN2@Getffld
$LN3@Getffld:

; 995  : 			}
; 996  : 		else

	jmp	$LN30@Getffld
$LN29@Getffld:

; 997  : 			{	// grouping specified, gather digits and group sizes
; 998  : 			const _Elem _Kseparator = _Grouping.size() == 0

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN80@Getffld
	mov	BYTE PTR tv192[ebp], 0
	jmp	SHORT $LN81@Getffld
$LN80@Getffld:
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR tv192[ebp], al
$LN81@Getffld:
	mov	al, BYTE PTR tv192[ebp]
	mov	BYTE PTR __Kseparator$7[ebp], al

; 999  : 				? (_Elem)0 : _Punct_fac.thousands_sep();
; 1000 : 			string _Groups((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1001 : 			size_t _Group = 0;

	mov	DWORD PTR __Group$8[ebp], 0

; 1002 : 
; 1003 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN7@Getffld
$LN5@Getffld:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN7@Getffld:
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN6@Getffld

; 1004 : 				{
; 1005 : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	call	??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z ; std::_Find_elem<char,15>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 10		; 0000000aH
	jae	$LN37@Getffld

; 1006 : 					{	// got a digit, add to group size
; 1007 : 					_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 1008 : 					if (_Max_sig_dig <= _Significant)

	mov	eax, DWORD PTR __Max_sig_dig$[ebp]
	cmp	eax, DWORD PTR __Significant$[ebp]
	jg	SHORT $LN39@Getffld

; 1009 : 						{	// enough digits, scale by 10 and update _Sticky
; 1010 : 						++_Pten;

	mov	ecx, DWORD PTR __Pten$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Pten$[ebp], ecx

; 1011 : 						if (0 < _Idx)

	cmp	DWORD PTR __Idx$[ebp], 0
	jbe	SHORT $LN41@Getffld

; 1012 : 							{
; 1013 : 							_Sticky = true;

	mov	BYTE PTR __Sticky$[ebp], 1
$LN41@Getffld:

; 1014 : 							}
; 1015 : 						}

	jmp	SHORT $LN40@Getffld
$LN39@Getffld:

; 1016 : 					else if (_Idx != 0 || _Significant != 0)

	cmp	DWORD PTR __Idx$[ebp], 0
	jne	SHORT $LN43@Getffld
	cmp	DWORD PTR __Significant$[ebp], 0
	je	SHORT $LN40@Getffld
$LN43@Getffld:

; 1017 : 						{	// save a significant digit
; 1018 : 						*_Ptr++ = _Src[_Idx];

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	cl, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1019 : 						++_Significant;

	mov	eax, DWORD PTR __Significant$[ebp]
	add	eax, 1
	mov	DWORD PTR __Significant$[ebp], eax
$LN40@Getffld:

; 1020 : 						}
; 1021 : 
; 1022 : 					if (_Groups[_Group] != CHAR_MAX)

	mov	ecx, DWORD PTR __Group$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 127				; 0000007fH
	je	SHORT $LN44@Getffld

; 1023 : 						{
; 1024 : 						++_Groups[_Group];

	mov	eax, DWORD PTR __Group$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR tv227[ebp], eax
	mov	ecx, DWORD PTR tv227[ebp]
	mov	dl, BYTE PTR [ecx]
	add	dl, 1
	mov	eax, DWORD PTR tv227[ebp]
	mov	BYTE PTR [eax], dl
$LN44@Getffld:

; 1025 : 						}
; 1026 : 					}
; 1027 : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN38@Getffld
$LN37@Getffld:

; 1028 : 					|| _Kseparator == (_Elem)0
; 1029 : 					|| *_First != _Kseparator)

	mov	ecx, DWORD PTR __Group$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN47@Getffld
	movsx	eax, BYTE PTR __Kseparator$7[ebp]
	test	eax, eax
	je	SHORT $LN47@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	movsx	edx, BYTE PTR __Kseparator$7[ebp]
	cmp	ecx, edx
	je	SHORT $LN45@Getffld
$LN47@Getffld:

; 1030 : 					{
; 1031 : 					break;	// not a group separator, done

	jmp	SHORT $LN6@Getffld

; 1032 : 					}
; 1033 : 				else

	jmp	SHORT $LN38@Getffld
$LN45@Getffld:

; 1034 : 					{	// add a new group to _Groups string
; 1035 : 					_Groups.push_back('\0');

	push	0
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 1036 : 					++_Group;

	mov	eax, DWORD PTR __Group$8[ebp]
	add	eax, 1
	mov	DWORD PTR __Group$8[ebp], eax
$LN38@Getffld:

; 1037 : 					}
; 1038 : 				}

	jmp	$LN5@Getffld
$LN6@Getffld:

; 1039 : 
; 1040 : 			if (_Group != 0)

	cmp	DWORD PTR __Group$8[ebp], 0
	je	SHORT $LN8@Getffld

; 1041 : 				{
; 1042 : 				if ('\0' < _Groups[_Group])

	mov	ecx, DWORD PTR __Group$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jle	SHORT $LN49@Getffld

; 1043 : 					{
; 1044 : 					++_Group;	// add trailing group to group count

	mov	eax, DWORD PTR __Group$8[ebp]
	add	eax, 1
	mov	DWORD PTR __Group$8[ebp], eax

; 1045 : 					}
; 1046 : 				else

	jmp	SHORT $LN8@Getffld
$LN49@Getffld:

; 1047 : 					{
; 1048 : 					_Bad = true;	// trailing separator, fail

	mov	BYTE PTR __Bad$[ebp], 1
$LN8@Getffld:

; 1049 : 					}
; 1050 : 				}
; 1051 : 
; 1052 : 			while (!_Bad && 0 < _Group)

	movzx	ecx, BYTE PTR __Bad$[ebp]
	test	ecx, ecx
	jne	$LN9@Getffld
	cmp	DWORD PTR __Group$8[ebp], 0
	jbe	SHORT $LN9@Getffld

; 1053 : 				{
; 1054 : 				if (*_Pg == CHAR_MAX)

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jne	SHORT $LN51@Getffld

; 1055 : 					{
; 1056 : 					break;	// end of grouping constraints to check

	jmp	SHORT $LN9@Getffld
$LN51@Getffld:

; 1057 : 					}
; 1058 : 
; 1059 : 				if ((0 < --_Group && *_Pg != _Groups[_Group])
; 1060 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	mov	ecx, DWORD PTR __Group$8[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Group$8[ebp], ecx
	je	SHORT $LN55@Getffld
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	esi, BYTE PTR [edx]
	mov	eax, DWORD PTR __Group$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	esi, ecx
	jne	SHORT $LN54@Getffld
$LN55@Getffld:
	cmp	DWORD PTR __Group$8[ebp], 0
	jne	SHORT $LN52@Getffld
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	esi, BYTE PTR [edx]
	mov	eax, DWORD PTR __Group$8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	cmp	esi, ecx
	jge	SHORT $LN52@Getffld
$LN54@Getffld:

; 1061 : 					{
; 1062 : 					_Bad = true;	// bad group size, fail

	mov	BYTE PTR __Bad$[ebp], 1
	jmp	SHORT $LN53@Getffld
$LN52@Getffld:

; 1063 : 					}
; 1064 : 				else if ('\0' < _Pg[1])

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jle	SHORT $LN53@Getffld

; 1065 : 					{
; 1066 : 					++_Pg;	// group size okay, advance to next test

	mov	edx, DWORD PTR __Pg$[ebp]
	add	edx, 1
	mov	DWORD PTR __Pg$[ebp], edx
$LN53@Getffld:

; 1067 : 					}
; 1068 : 				}

	jmp	$LN8@Getffld
$LN9@Getffld:

; 1069 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN30@Getffld:

; 1070 : 
; 1071 : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN57@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	esi, al
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	movsx	eax, al
	cmp	esi, eax
	jne	SHORT $LN57@Getffld

; 1072 : 			{	// add .
; 1073 : 			*_Ptr++ = localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1074 : 			++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN57@Getffld:

; 1075 : 			}
; 1076 : 
; 1077 : 		if (*_Phexexp != _ENABLE_V2_BEHAVIOR && _Significant == 0)

	mov	ecx, DWORD PTR __Phexexp$[ebp]
	cmp	DWORD PTR [ecx], 1000000000		; 3b9aca00H
	je	SHORT $LN58@Getffld
	cmp	DWORD PTR __Significant$[ebp], 0
	jne	SHORT $LN58@Getffld

; 1078 : 			{	// 0000. so far
; 1079 : 			for (; _First != _Last && *_First == _Atoms[0];

	jmp	SHORT $LN12@Getffld
$LN10@Getffld:

; 1080 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN12@Getffld:

; 1078 : 			{	// 0000. so far
; 1079 : 			for (; _First != _Last && *_First == _Atoms[0];

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN11@Getffld

; 1081 : 				--_Pten;	// just count leading fraction zeros

	mov	ecx, DWORD PTR __Pten$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pten$[ebp], ecx
	jmp	SHORT $LN10@Getffld
$LN11@Getffld:

; 1082 : 			if (_Pten < 0)

	cmp	DWORD PTR __Pten$[ebp], 0
	jge	SHORT $LN58@Getffld

; 1083 : 				{	// put one back
; 1084 : 				*_Ptr++ = '0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 48			; 00000030H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1085 : 				++_Pten;

	mov	ecx, DWORD PTR __Pten$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Pten$[ebp], ecx
$LN58@Getffld:

; 1086 : 				}
; 1087 : 			}
; 1088 : 
; 1089 : 		for (; _First != _Last

	jmp	SHORT $LN15@Getffld
$LN13@Getffld:

; 1091 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN15@Getffld:

; 1090 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR __Atoms$[ebp]
	push	eax
	call	??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z ; std::_Find_elem<char,15>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 10		; 0000000aH
	jae	SHORT $LN14@Getffld

; 1092 : 			if (_Significant < _Max_sig_dig)

	mov	ecx, DWORD PTR __Significant$[ebp]
	cmp	ecx, DWORD PTR __Max_sig_dig$[ebp]
	jge	SHORT $LN60@Getffld

; 1093 : 				{	// save a significant fraction digit
; 1094 : 				*_Ptr++ = _Src[_Idx];

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	cl, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1095 : 				++_Significant;

	mov	eax, DWORD PTR __Significant$[ebp]
	add	eax, 1
	mov	DWORD PTR __Significant$[ebp], eax
	jmp	SHORT $LN61@Getffld
$LN60@Getffld:

; 1096 : 				}
; 1097 : 			else if (0 < _Idx)

	cmp	DWORD PTR __Idx$[ebp], 0
	jbe	SHORT $LN61@Getffld

; 1098 : 				_Sticky = true;	// just update _Sticky

	mov	BYTE PTR __Sticky$[ebp], 1
$LN61@Getffld:

; 1099 : 
; 1100 : 		if (_Sticky)

	jmp	SHORT $LN13@Getffld
$LN14@Getffld:
	movzx	ecx, BYTE PTR __Sticky$[ebp]
	test	ecx, ecx
	je	SHORT $LN63@Getffld

; 1101 : 			{	// increment ls digit in memory of those lost
; 1102 : 			char *_Px = _Ptr;

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Px$6[ebp], edx
$LN16@Getffld:

; 1103 : 			while (--_Px != _Leading)

	mov	eax, DWORD PTR __Px$6[ebp]
	sub	eax, 1
	mov	DWORD PTR __Px$6[ebp], eax
	mov	ecx, DWORD PTR __Px$6[ebp]
	cmp	ecx, DWORD PTR __Leading$[ebp]
	je	SHORT $LN17@Getffld

; 1104 : 				{	// add in carry
; 1105 : 				if (*_Px != localeconv()->decimal_point[0])

	mov	edx, DWORD PTR __Px$6[ebp]
	movsx	esi, BYTE PTR [edx]
	call	_localeconv
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	esi, ecx
	je	SHORT $LN64@Getffld

; 1106 : 					{	// non decimal point
; 1107 : 					if (*_Px != '9')

	mov	edx, DWORD PTR __Px$6[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	je	SHORT $LN65@Getffld

; 1108 : 						{	// carry stops here
; 1109 : 						++*_Px;

	mov	ecx, DWORD PTR __Px$6[ebp]
	mov	dl, BYTE PTR [ecx]
	add	dl, 1
	mov	eax, DWORD PTR __Px$6[ebp]
	mov	BYTE PTR [eax], dl

; 1110 : 						break;

	jmp	SHORT $LN17@Getffld
$LN65@Getffld:

; 1111 : 						}
; 1112 : 
; 1113 : 					*_Px = '0';	// propagate carry

	mov	ecx, DWORD PTR __Px$6[ebp]
	mov	BYTE PTR [ecx], 48			; 00000030H
$LN64@Getffld:

; 1114 : 					}
; 1115 : 				}

	jmp	SHORT $LN16@Getffld
$LN17@Getffld:

; 1116 : 
; 1117 : 			if (_Px == _Leading)

	mov	edx, DWORD PTR __Px$6[ebp]
	cmp	edx, DWORD PTR __Leading$[ebp]
	jne	SHORT $LN63@Getffld

; 1118 : 				{	// change "999..." to "1000..." and scale _Pten
; 1119 : 				*_Px = '1';

	mov	eax, DWORD PTR __Px$6[ebp]
	mov	BYTE PTR [eax], 49			; 00000031H

; 1120 : 				++_Pten;

	mov	ecx, DWORD PTR __Pten$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Pten$[ebp], ecx
$LN63@Getffld:

; 1121 : 				}
; 1122 : 			}
; 1123 : 
; 1124 : 		if (_Seendigit && _First != _Last
; 1125 : 			&& (*_First == _Atoms[_Numget_eoff + 1]

	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	$LN67@Getffld
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN67@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 13
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	je	SHORT $LN68@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 12
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	$LN67@Getffld
$LN68@Getffld:

; 1126 : 				|| *_First == _Atoms[_Numget_eoff]))
; 1127 : 			{	// 'e' or 'E', collect exponent
; 1128 : 			*_Ptr++ = 'e';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 101			; 00000065H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1129 : 			++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 1130 : 			_Seendigit = false;

	mov	BYTE PTR __Seendigit$[ebp], 0

; 1131 : 			_Significant = 0;

	mov	DWORD PTR __Significant$[ebp], 0

; 1132 : 
; 1133 : 			if (_First != _Last)

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN69@Getffld

; 1134 : 				{
; 1135 : 				if (*_First == _Atoms[_Numget_signoff + 1])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 11
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	jne	SHORT $LN70@Getffld

; 1136 : 					{	// gather plus sign
; 1137 : 					*_Ptr++ = '+';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 43			; 0000002bH
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1138 : 					++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN69@Getffld
$LN70@Getffld:

; 1139 : 					}
; 1140 : 				else if (*_First == _Atoms[_Numget_signoff])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 10
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN69@Getffld

; 1141 : 					{	// gather minus sign
; 1142 : 					*_Ptr++ = '-';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 45			; 0000002dH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1143 : 					++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN69@Getffld:

; 1144 : 					}
; 1145 : 				}
; 1146 : 
; 1147 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	jmp	SHORT $LN20@Getffld
$LN18@Getffld:
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN20@Getffld:
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN19@Getffld

; 1148 : 				{	// strip leading zeros
; 1149 : 				_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 1150 : 				}

	jmp	SHORT $LN18@Getffld
$LN19@Getffld:

; 1151 : 
; 1152 : 			if (_Seendigit)

	movzx	ecx, BYTE PTR __Seendigit$[ebp]
	test	ecx, ecx
	je	SHORT $LN73@Getffld

; 1153 : 				*_Ptr++ = '0';	// put one back

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 48			; 00000030H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax
$LN73@Getffld:

; 1154 : 			for (; _First != _Last

	jmp	SHORT $LN23@Getffld
$LN21@Getffld:

; 1156 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$[ebp], 1
	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN23@Getffld:

; 1155 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN67@Getffld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	ecx, al
	push	ecx
	lea	edx, DWORD PTR __Atoms$[ebp]
	push	edx
	call	??$_Find_elem@D$0P@@std@@YAIAAY0P@$$CBDD@Z ; std::_Find_elem<char,15>
	add	esp, 8
	mov	DWORD PTR __Idx$[ebp], eax
	cmp	DWORD PTR __Idx$[ebp], 10		; 0000000aH
	jae	SHORT $LN67@Getffld

; 1157 : 				if (_Significant < _MAX_EXP_DIG)

	cmp	DWORD PTR __Significant$[ebp], 8
	jge	SHORT $LN74@Getffld

; 1158 : 					{	// save a significant exponent digit
; 1159 : 					*_Ptr++ = _Src[_Idx];

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	dl, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1160 : 					++_Significant;

	mov	ecx, DWORD PTR __Significant$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Significant$[ebp], ecx
$LN74@Getffld:

; 1161 : 					}
; 1162 : 			}

	jmp	SHORT $LN21@Getffld
$LN67@Getffld:

; 1163 : 
; 1164 : 		if (_Bad || !_Seendigit)

	movzx	edx, BYTE PTR __Bad$[ebp]
	test	edx, edx
	jne	SHORT $LN76@Getffld
	movzx	eax, BYTE PTR __Seendigit$[ebp]
	test	eax, eax
	jne	SHORT $LN75@Getffld
$LN76@Getffld:

; 1165 : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	ecx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN75@Getffld:

; 1166 : 		*_Ptr = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 1167 : 		return (_Pten);

	mov	eax, DWORD PTR __Pten$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T5[ebp]
$LN1@Getffld:

; 1168 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT
__Grouping$ = -176					; size = 28
__Numget_xoff$ = -148					; size = 4
__Numget_signoff$ = -144				; size = 4
__Atoms$ = -140						; size = 27
__Groups$ = -112					; size = 28
$T2 = -84						; size = 4
__Pe$3 = -80						; size = 4
__Dlen$ = -76						; size = 4
__Ctype_fac$ = -72					; size = 4
tv224 = -68						; size = 4
__Idx$4 = -64						; size = 4
tv188 = -60						; size = 4
tv187 = -56						; size = 4
tv147 = -52						; size = 4
tv146 = -48						; size = 4
tv145 = -44						; size = 4
__Punct_fac$ = -40					; size = 4
__Pg$5 = -36						; size = 4
__Base$ = -32						; size = 4
__Kseparator$ = -27					; size = 1
tv75 = -26						; size = 1
__Nonzero$ = -25					; size = 1
__Ptr$ = -24						; size = 4
__Group$ = -20						; size = 4
__Seendigit$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Basefield$ = 24					; size = 4
__Loc$ = 28						; size = 4
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld, COMDAT

; 812  : 		{	// get integer field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 164				; 000000a4H
	push	esi

; 813  : 		const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Loc);

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax

; 814  : 		const string _Grouping = _Punct_fac.grouping();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 815  : 		const _Elem _Kseparator = _Grouping.size() == 0

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN40@Getifld
	mov	BYTE PTR tv75[ebp], 0
	jmp	SHORT $LN41@Getifld
$LN40@Getifld:
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR tv75[ebp], al
$LN41@Getifld:
	mov	dl, BYTE PTR tv75[ebp]
	mov	BYTE PTR __Kseparator$[ebp], dl

; 816  : 			? (_Elem)0 : _Punct_fac.thousands_sep();
; 817  : 
; 818  : 		constexpr int _Numget_signoff = 22;

	mov	DWORD PTR __Numget_signoff$[ebp], 22	; 00000016H

; 819  : 		constexpr int _Numget_xoff = 24;

	mov	DWORD PTR __Numget_xoff$[ebp], 24	; 00000018H

; 820  : 		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
; 821  : 		_Elem _Atoms[sizeof (_Src)];
; 822  : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax

; 823  : 		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 27
	add	eax, OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	add	edx, OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	push	edx
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 824  : 
; 825  : 		char *_Ptr = _Ac;

	mov	eax, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 826  : 
; 827  : 		if (_First != _Last)

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Getifld

; 828  : 			{
; 829  : 			if (*_First == _Atoms[_Numget_signoff + 1])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 23
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	SHORT $LN9@Getifld

; 830  : 				{	// gather plus sign
; 831  : 				*_Ptr++ = '+';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 832  : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN8@Getifld
$LN9@Getifld:

; 833  : 				}
; 834  : 			else if (*_First == _Atoms[_Numget_signoff])

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 22
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN8@Getifld

; 835  : 				{	// gather minus sign
; 836  : 				*_Ptr++ = '-';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 837  : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN8@Getifld:

; 838  : 				}
; 839  : 			}
; 840  : 
; 841  : 		_Basefield &= ios_base::basefield;

	mov	eax, DWORD PTR __Basefield$[ebp]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Basefield$[ebp], eax

; 842  : 		int _Base = _Basefield == ios_base::oct ? 8

	cmp	DWORD PTR __Basefield$[ebp], 1024	; 00000400H
	jne	SHORT $LN46@Getifld
	mov	DWORD PTR tv147[ebp], 8
	jmp	SHORT $LN47@Getifld
$LN46@Getifld:
	cmp	DWORD PTR __Basefield$[ebp], 2048	; 00000800H
	jne	SHORT $LN44@Getifld
	mov	DWORD PTR tv146[ebp], 16		; 00000010H
	jmp	SHORT $LN45@Getifld
$LN44@Getifld:
	cmp	DWORD PTR __Basefield$[ebp], 0
	jne	SHORT $LN42@Getifld
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN43@Getifld
$LN42@Getifld:
	mov	DWORD PTR tv145[ebp], 10		; 0000000aH
$LN43@Getifld:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv146[ebp], ecx
$LN45@Getifld:
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv147[ebp], edx
$LN47@Getifld:
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR __Base$[ebp], eax

; 843  : 			: _Basefield == ios_base::hex ? 16
; 844  : 			: _Basefield == ios_base::_Fmtzero ? 0 : 10;
; 845  : 
; 846  : 		bool _Seendigit = false;	// seen a digit in input

	mov	BYTE PTR __Seendigit$[ebp], 0

; 847  : 		bool _Nonzero = false;	// seen a nonzero digit in input

	mov	BYTE PTR __Nonzero$[ebp], 0

; 848  : 
; 849  : 		if (_First != _Last && *_First == _Atoms[0])

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN12@Getifld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	ecx, al
	mov	edx, 1
	imul	eax, edx, 0
	movsx	edx, BYTE PTR __Atoms$[ebp+eax]
	cmp	ecx, edx
	jne	$LN12@Getifld

; 850  : 			{	// leading zero, look for 0x, 0X
; 851  : 			_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 852  : 			++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 853  : 			if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1]
; 854  : 					|| *_First == _Atoms[_Numget_xoff])
; 855  : 				&& (_Base == 0 || _Base == 16))

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@Getifld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	eax, al
	mov	ecx, 1
	imul	edx, ecx, 25
	movsx	ecx, BYTE PTR __Atoms$[ebp+edx]
	cmp	eax, ecx
	je	SHORT $LN15@Getifld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	mov	eax, 1
	imul	ecx, eax, 24
	movsx	eax, BYTE PTR __Atoms$[ebp+ecx]
	cmp	edx, eax
	jne	SHORT $LN13@Getifld
$LN15@Getifld:
	cmp	DWORD PTR __Base$[ebp], 0
	je	SHORT $LN16@Getifld
	cmp	DWORD PTR __Base$[ebp], 16		; 00000010H
	jne	SHORT $LN13@Getifld
$LN16@Getifld:

; 856  : 				{
; 857  : 				_Base = 16;

	mov	DWORD PTR __Base$[ebp], 16		; 00000010H

; 858  : 				_Seendigit = false;

	mov	BYTE PTR __Seendigit$[ebp], 0

; 859  : 				++_First;

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN12@Getifld
$LN13@Getifld:

; 860  : 				}
; 861  : 			else if (_Base == 0)

	cmp	DWORD PTR __Base$[ebp], 0
	jne	SHORT $LN12@Getifld

; 862  : 				{
; 863  : 				_Base = 8;

	mov	DWORD PTR __Base$[ebp], 8
$LN12@Getifld:

; 864  : 				}
; 865  : 			}
; 866  : 
; 867  : 		const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10

	cmp	DWORD PTR __Base$[ebp], 0
	je	SHORT $LN48@Getifld
	cmp	DWORD PTR __Base$[ebp], 10		; 0000000aH
	je	SHORT $LN48@Getifld
	cmp	DWORD PTR __Base$[ebp], 8
	jne	SHORT $LN49@Getifld
	mov	DWORD PTR tv187[ebp], 8
	jmp	SHORT $LN50@Getifld
$LN49@Getifld:
	mov	DWORD PTR tv187[ebp], 22		; 00000016H
$LN50@Getifld:
	mov	ecx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv188[ebp], ecx
	jmp	SHORT $LN51@Getifld
$LN48@Getifld:
	mov	DWORD PTR tv188[ebp], 10		; 0000000aH
$LN51@Getifld:
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR __Dlen$[ebp], edx

; 868  : 			: _Base == 8 ? 8 : 16 + 6);
; 869  : 		string _Groups((size_t)1, (char)_Seendigit);

	movzx	eax, BYTE PTR __Seendigit$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 870  : 		size_t _Group = 0;

	mov	DWORD PTR __Group$[ebp], 0

; 871  : 
; 872  : 		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];

	mov	ecx, 1
	imul	edx, ecx, 31
	add	edx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Pe$3[ebp], edx
	jmp	SHORT $LN4@Getifld
$LN2@Getifld:

; 873  : 			_First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[ebp]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN4@Getifld:
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN3@Getifld

; 874  : 			{	// look for digits and separators
; 875  : 			size_t _Idx = _Find_elem(_Atoms, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	call	??$_Find_elem@D$0BL@@std@@YAIAAY0BL@$$CBDD@Z ; std::_Find_elem<char,27>
	add	esp, 8
	mov	DWORD PTR __Idx$4[ebp], eax

; 876  : 			if (_Idx < _Dlen)

	mov	edx, DWORD PTR __Idx$4[ebp]
	cmp	edx, DWORD PTR __Dlen$[ebp]
	jae	SHORT $LN18@Getifld

; 877  : 				{	// got a digit, characterize it and add to group size
; 878  : 				*_Ptr = _Src[_Idx];

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Idx$4[ebp]
	mov	dl, BYTE PTR ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB[ecx]
	mov	BYTE PTR [eax], dl

; 879  : 				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)

	movzx	eax, BYTE PTR __Nonzero$[ebp]
	test	eax, eax
	jne	SHORT $LN21@Getifld
	mov	ecx, DWORD PTR __Ptr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	je	SHORT $LN20@Getifld
$LN21@Getifld:
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR __Pe$3[ebp]
	jae	SHORT $LN20@Getifld

; 880  : 					{
; 881  : 					++_Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 882  : 					_Nonzero = true;

	mov	BYTE PTR __Nonzero$[ebp], 1
$LN20@Getifld:

; 883  : 					}
; 884  : 
; 885  : 				_Seendigit = true;

	mov	BYTE PTR __Seendigit$[ebp], 1

; 886  : 				if (_Groups[_Group] != CHAR_MAX)

	mov	edx, DWORD PTR __Group$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 127				; 0000007fH
	je	SHORT $LN22@Getifld

; 887  : 					++_Groups[_Group];

	mov	ecx, DWORD PTR __Group$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR tv224[ebp], eax
	mov	edx, DWORD PTR tv224[ebp]
	mov	al, BYTE PTR [edx]
	add	al, 1
	mov	ecx, DWORD PTR tv224[ebp]
	mov	BYTE PTR [ecx], al
$LN22@Getifld:

; 888  : 				}
; 889  : 			else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN19@Getifld
$LN18@Getifld:

; 890  : 				|| _Kseparator == (_Elem)0
; 891  : 				|| *_First != _Kseparator)

	mov	edx, DWORD PTR __Group$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN25@Getifld
	movsx	ecx, BYTE PTR __Kseparator$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@Getifld
	mov	ecx, DWORD PTR __First$[ebp]
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	movsx	edx, al
	movsx	eax, BYTE PTR __Kseparator$[ebp]
	cmp	edx, eax
	je	SHORT $LN23@Getifld
$LN25@Getifld:

; 892  : 				break;	// not a group separator, done

	jmp	SHORT $LN3@Getifld

; 893  : 			else

	jmp	SHORT $LN19@Getifld
$LN23@Getifld:

; 894  : 				{	// add a new group to _Groups string
; 895  : 				_Groups.push_back('\0');

	push	0
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 896  : 				++_Group;

	mov	ecx, DWORD PTR __Group$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Group$[ebp], ecx
$LN19@Getifld:

; 897  : 				}
; 898  : 			}

	jmp	$LN2@Getifld
$LN3@Getifld:

; 899  : 
; 900  : 		if (_Group != 0)

	cmp	DWORD PTR __Group$[ebp], 0
	je	SHORT $LN26@Getifld

; 901  : 			{
; 902  : 			if ('\0' < _Groups[_Group])

	mov	edx, DWORD PTR __Group$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jle	SHORT $LN27@Getifld

; 903  : 				{
; 904  : 				++_Group;	// add trailing group to group count

	mov	ecx, DWORD PTR __Group$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Group$[ebp], ecx

; 905  : 				}
; 906  : 			else

	jmp	SHORT $LN26@Getifld
$LN27@Getifld:

; 907  : 				{
; 908  : 				_Seendigit = false;	// trailing separator, fail

	mov	BYTE PTR __Seendigit$[ebp], 0
$LN26@Getifld:

; 909  : 				}
; 910  : 			}
; 911  : 
; 912  : 		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$5[ebp], eax
$LN7@Getifld:
	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	je	SHORT $LN6@Getifld
	cmp	DWORD PTR __Group$[ebp], 0
	jbe	SHORT $LN6@Getifld

; 913  : 			if (*_Pg == CHAR_MAX)

	mov	eax, DWORD PTR __Pg$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jne	SHORT $LN29@Getifld

; 914  : 				break;	// end of grouping constraints to check

	jmp	SHORT $LN6@Getifld

; 915  : 			else if ((0 < --_Group && *_Pg != _Groups[_Group])

	jmp	SHORT $LN30@Getifld
$LN29@Getifld:

; 916  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	mov	edx, DWORD PTR __Group$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Group$[ebp], edx
	je	SHORT $LN34@Getifld
	mov	eax, DWORD PTR __Pg$5[ebp]
	movsx	esi, BYTE PTR [eax]
	mov	ecx, DWORD PTR __Group$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	cmp	esi, edx
	jne	SHORT $LN33@Getifld
$LN34@Getifld:
	cmp	DWORD PTR __Group$[ebp], 0
	jne	SHORT $LN31@Getifld
	mov	eax, DWORD PTR __Pg$5[ebp]
	movsx	esi, BYTE PTR [eax]
	mov	ecx, DWORD PTR __Group$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsx	edx, BYTE PTR [eax]
	cmp	esi, edx
	jge	SHORT $LN31@Getifld
$LN33@Getifld:

; 917  : 				_Seendigit = false;	// bad group size, fail

	mov	BYTE PTR __Seendigit$[ebp], 0
	jmp	SHORT $LN30@Getifld
$LN31@Getifld:

; 918  : 			else if ('\0' < _Pg[1])

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR __Pg$5[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jle	SHORT $LN30@Getifld

; 919  : 				++_Pg;	// group size okay, advance to next test

	mov	eax, DWORD PTR __Pg$5[ebp]
	add	eax, 1
	mov	DWORD PTR __Pg$5[ebp], eax
$LN30@Getifld:

; 920  : 
; 921  : 		if (_Seendigit && !_Nonzero)

	jmp	$LN7@Getifld
$LN6@Getifld:
	movzx	ecx, BYTE PTR __Seendigit$[ebp]
	test	ecx, ecx
	je	SHORT $LN36@Getifld
	movzx	edx, BYTE PTR __Nonzero$[ebp]
	test	edx, edx
	jne	SHORT $LN36@Getifld

; 922  : 			*_Ptr++ = '0';	// zero field, replace stripped zero(s)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN37@Getifld
$LN36@Getifld:

; 923  : 		else if (!_Seendigit)

	movzx	edx, BYTE PTR __Seendigit$[ebp]
	test	edx, edx
	jne	SHORT $LN37@Getifld

; 924  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
$LN37@Getifld:

; 925  : 		*_Ptr = '\0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 0

; 926  : 		return (_Base);

	mov	edx, DWORD PTR __Base$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]

; 927  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1:
	lea	ecx, DWORD PTR __Groups$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
__Ac$ = -76						; size = 32
$T2 = -44						; size = 8
__Errno$3 = -36						; size = 4
__Ep$4 = -32						; size = 4
__Base$ = -28						; size = 4
_this$ = -24						; size = 4
tv128 = -20						; size = 4
tv129 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 775  : 		{	// get void pointer from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 776  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 777  : 		char _Ac[_MAX_INT_DIG];
; 778  : 		const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc());	// gather field

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv129[ebp], eax
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv128[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv128[ebp]
	push	ecx
	push	2048					; 00000800H
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 779  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 780  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 781  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 782  : 			_Val = nullptr;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0

; 783  : 			}
; 784  : 		else

	jmp	SHORT $LN3@do_get
$LN2@do_get:

; 785  : 			{
; 786  : 			int _Errno;
; 787  : 			char * _Ep;
; 788  : #ifdef _WIN64
; 789  : 			_Val = reinterpret_cast<void *>(_CSTD _Stoullx(_Ac, &_Ep, _Base, &_Errno));
; 790  : #else /* ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv */
; 791  : 			_Val = reinterpret_cast<void *>(_CSTD _Stoulx(_Ac, &_Ep, _Base, &_Errno));

	lea	edx, DWORD PTR __Errno$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 792  : #endif /* _WIN64 */
; 793  : 			if (_Ep == _Ac || _Errno != 0)

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	je	SHORT $LN3@do_get
$LN5@do_get:

; 794  : 				{
; 795  : 				_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 796  : 				_Val = nullptr;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0
$LN3@do_get:

; 797  : 				}
; 798  : 			}
; 799  : 
; 800  : 		if (_First == _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@do_get

; 801  : 			{
; 802  : 			_State |= ios_base::eofbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@do_get:

; 803  : 			}
; 804  : 
; 805  : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 806  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
$T1 = -20						; size = 8
__Result$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 763  : 		{	// get long double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 		static_assert(sizeof(double) == sizeof(long double),
; 765  : 			"Bad assumption: sizeof(double) == sizeof(long double).");
; 766  : 		double _Result;
; 767  : 		_First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf

	lea	eax, DWORD PTR __Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[ebp], edx
	mov	DWORD PTR __First$[ebp+4], eax

; 768  : 		_Val = _Result;

	mov	ecx, DWORD PTR __Val$[ebp]
	movsd	xmm0, QWORD PTR __Result$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 769  : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 770  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
__Ac$ = -812						; size = 792
__Errno$1 = -20						; size = 4
__Ep$2 = -16						; size = 4
__Base$ = -12						; size = 4
_this$ = -8						; size = 4
__Hexexp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 725  : 		{	// get double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 812				; 0000032cH
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 727  : 		char _Ac[_FLOATING_BUFFER_SIZE];
; 728  : 		int _Hexexp = _ENABLE_V2_BEHAVIOR;

	mov	DWORD PTR __Hexexp$[ebp], 1000000000	; 3b9aca00H

; 729  : 		const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);	// gather field

	lea	edx, DWORD PTR __Hexexp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax

; 730  : 		if (_Ac[0] == '\0')

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR __Ac$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN2@do_get

; 731  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 732  : 			_State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2

; 733  : 			_Val = 0.0;

	mov	eax, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax], xmm0

; 734  : 			}
; 735  : 		else

	jmp	SHORT $LN7@do_get
$LN2@do_get:

; 736  : 			{
; 737  : 			int _Errno;
; 738  : 			char * _Ep;
; 739  : 			_Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	ecx, DWORD PTR __Errno$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	lea	eax, DWORD PTR __Ep$2[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	?_Stodx_v2@std@@YANPBDPAPADHPAH@Z	; std::_Stodx_v2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR __Val$[ebp]
	fstp	QWORD PTR [edx]

; 740  : 			if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$2[ebp], eax
	je	SHORT $LN6@do_get
	cmp	DWORD PTR __Errno$1[ebp], 0
	je	SHORT $LN4@do_get
$LN6@do_get:

; 741  : 				{
; 742  : 				_State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 743  : 				_Val = 0.0;

	mov	edx, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx], xmm0
	jmp	SHORT $LN7@do_get
$LN4@do_get:

; 744  : 				}
; 745  : 			else if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)

	cmp	DWORD PTR __Hexexp$[ebp], 1000000000	; 3b9aca00H
	je	SHORT $LN7@do_get
	cmp	DWORD PTR __Hexexp$[ebp], 0
	je	SHORT $LN7@do_get

; 746  : 				{
; 747  : 				_Val = _CSTD ldexp(_Val, 4 * _Hexexp);

	mov	eax, DWORD PTR __Hexexp$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR __Val$[ebp]
	fstp	QWORD PTR [edx]
$LN7@do_get:

; 748  : 				}
; 749  : 			}
; 750  : 
; 751  : 		if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@do_get

; 752  : 			{
; 753  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], ecx
$LN8@do_get:

; 754  : 			}
; 755  : 
; 756  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 757  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
__Ac$ = -812						; size = 792
__Errno$1 = -20						; size = 4
__Ep$2 = -16						; size = 4
__Base$ = -12						; size = 4
_this$ = -8						; size = 4
__Hexexp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 688  : 		{	// get float from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 812				; 0000032cH
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 690  : 		char _Ac[_FLOATING_BUFFER_SIZE];
; 691  : 		int _Hexexp = _ENABLE_V2_BEHAVIOR;

	mov	DWORD PTR __Hexexp$[ebp], 1000000000	; 3b9aca00H

; 692  : 		const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);	// gather field

	lea	edx, DWORD PTR __Hexexp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax

; 693  : 		if (_Ac[0] == '\0')

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR __Ac$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN2@do_get

; 694  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 695  : 			_State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2

; 696  : 			_Val = 0.0f;

	mov	eax, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 697  : 			}
; 698  : 		else

	jmp	SHORT $LN7@do_get
$LN2@do_get:

; 699  : 			{
; 700  : 			int _Errno;
; 701  : 			char * _Ep;
; 702  : 			_Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	ecx, DWORD PTR __Errno$1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	lea	eax, DWORD PTR __Ep$2[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	call	?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z	; std::_Stofx_v2
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR __Val$[ebp]
	fstp	DWORD PTR [edx]

; 703  : 			if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$2[ebp], eax
	je	SHORT $LN6@do_get
	cmp	DWORD PTR __Errno$1[ebp], 0
	je	SHORT $LN4@do_get
$LN6@do_get:

; 704  : 				{
; 705  : 				_State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 706  : 				_Val = 0.0f;

	mov	edx, DWORD PTR __Val$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx], xmm0
	jmp	SHORT $LN7@do_get
$LN4@do_get:

; 707  : 				}
; 708  : 			else if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)

	cmp	DWORD PTR __Hexexp$[ebp], 1000000000	; 3b9aca00H
	je	SHORT $LN7@do_get
	cmp	DWORD PTR __Hexexp$[ebp], 0
	je	SHORT $LN7@do_get

; 709  : 				{
; 710  : 				_Val = _CSTD ldexpf(_Val, 4 * _Hexexp);

	mov	eax, DWORD PTR __Hexexp$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	call	_ldexpf
	add	esp, 8
	mov	edx, DWORD PTR __Val$[ebp]
	fstp	DWORD PTR [edx]
$LN7@do_get:

; 711  : 				}
; 712  : 			}
; 713  : 
; 714  : 		if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@do_get

; 715  : 			{
; 716  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], ecx
$LN8@do_get:

; 717  : 			}
; 718  : 
; 719  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 720  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
__Ac$ = -76						; size = 32
$T2 = -44						; size = 8
__Errno$3 = -36						; size = 4
__Ep$4 = -32						; size = 4
__Base$ = -28						; size = 4
_this$ = -24						; size = 4
tv130 = -20						; size = 4
tv131 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 651  : 		{	// get unsigned long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 652  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 653  : 		char _Ac[_MAX_INT_DIG];
; 654  : 		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 655  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 656  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 657  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 658  : 			_Val = 0;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 659  : 			}
; 660  : 		else

	jmp	SHORT $LN3@do_get
$LN2@do_get:

; 661  : 			{
; 662  : 			int _Errno;
; 663  : 			char * _Ep;
; 664  : 			_Val = _CSTD _Stoullx(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	edx, DWORD PTR __Errno$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stoullx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 665  : 			if (_Ep == _Ac || _Errno != 0)

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	je	SHORT $LN3@do_get
$LN5@do_get:

; 666  : 				{
; 667  : 				_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN3@do_get:

; 668  : 				}
; 669  : 			}
; 670  : 
; 671  : 		if (_First == _Last)

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 672  : 			{
; 673  : 			_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 674  : 			}
; 675  : 
; 676  : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 677  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
__Ac$ = -76						; size = 32
$T2 = -44						; size = 8
__Errno$3 = -36						; size = 4
__Ep$4 = -32						; size = 4
__Base$ = -28						; size = 4
_this$ = -24						; size = 4
tv130 = -20						; size = 4
tv131 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 620  : 		{	// get long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 622  : 		char _Ac[_MAX_INT_DIG];
; 623  : 		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 624  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 625  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 626  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 627  : 			_Val = 0;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 628  : 			}
; 629  : 		else

	jmp	SHORT $LN3@do_get
$LN2@do_get:

; 630  : 			{
; 631  : 			char * _Ep;
; 632  : 			int _Errno;
; 633  : 			_Val = _CSTD _Stollx(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	edx, DWORD PTR __Errno$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stollx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 634  : 			if (_Ep == _Ac || _Errno != 0)

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	je	SHORT $LN3@do_get
$LN5@do_get:

; 635  : 				{
; 636  : 				_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN3@do_get:

; 637  : 				}
; 638  : 			}
; 639  : 
; 640  : 		if (_First == _Last)

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 641  : 			{
; 642  : 			_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 643  : 			}
; 644  : 
; 645  : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
__Ac$ = -76						; size = 32
$T2 = -44						; size = 8
__Errno$3 = -36						; size = 4
__Ep$4 = -32						; size = 4
__Base$ = -28						; size = 4
_this$ = -24						; size = 4
tv130 = -20						; size = 4
tv131 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 589  : 		{	// get unsigned long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 591  : 		char _Ac[_MAX_INT_DIG];
; 592  : 		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 593  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 594  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 595  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 596  : 			_Val = 0;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0

; 597  : 			}
; 598  : 		else

	jmp	SHORT $LN3@do_get
$LN2@do_get:

; 599  : 			{
; 600  : 			char * _Ep;
; 601  : 			int _Errno;
; 602  : 			_Val = _CSTD _Stoulx(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	edx, DWORD PTR __Errno$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 603  : 			if (_Ep == _Ac || _Errno != 0)

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	je	SHORT $LN3@do_get
$LN5@do_get:

; 604  : 				{
; 605  : 				_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN3@do_get:

; 606  : 				}
; 607  : 			}
; 608  : 
; 609  : 		if (_First == _Last)

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 610  : 			{
; 611  : 			_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 612  : 			}
; 613  : 
; 614  : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 615  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
__Ac$ = -76						; size = 32
$T2 = -44						; size = 8
__Errno$3 = -36						; size = 4
__Ep$4 = -32						; size = 4
__Base$ = -28						; size = 4
_this$ = -24						; size = 4
tv130 = -20						; size = 4
tv131 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 558  : 		{	// get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 560  : 		char _Ac[_MAX_INT_DIG];
; 561  : 		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 562  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 563  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 564  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 565  : 			_Val = 0;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], 0

; 566  : 			}
; 567  : 		else

	jmp	SHORT $LN3@do_get
$LN2@do_get:

; 568  : 			{
; 569  : 			char * _Ep;
; 570  : 			int _Errno;
; 571  : 			_Val = _CSTD _Stolx(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	edx, DWORD PTR __Errno$3[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$4[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$[ebp]
	push	edx
	call	__Stolx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 572  : 			if (_Ep == _Ac || _Errno != 0)

	lea	edx, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$4[ebp], edx
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	je	SHORT $LN3@do_get
$LN5@do_get:

; 573  : 				{
; 574  : 				_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2
$LN3@do_get:

; 575  : 				}
; 576  : 			}
; 577  : 
; 578  : 		if (_First == _Last)

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@do_get

; 579  : 			{
; 580  : 			_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@do_get:

; 581  : 			}
; 582  : 
; 583  : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 584  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 546  : 		{	// get unsigned int from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 		static_assert(sizeof(unsigned int) == sizeof(unsigned long),
; 548  : 			"Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
; 549  : 		unsigned long _Tmp;
; 550  : 		_First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __First$[ebp], edx
	mov	DWORD PTR __First$[ebp+4], eax

; 551  : 		_Val = _Tmp;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx

; 552  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
__Ac$ = -88						; size = 32
$T2 = -56						; size = 8
__Errno$3 = -48						; size = 4
__Ep$4 = -44						; size = 4
__Base$ = -40						; size = 4
_this$ = -36						; size = 4
tv144 = -32						; size = 4
tv145 = -28						; size = 4
__Tmp$5 = -24						; size = 4
__Digits$6 = -20					; size = 4
__Minus$7 = -14						; size = 1
tv88 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 499  : 		{	// get unsigned short from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 500  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 501  : 		char _Ac[_MAX_INT_DIG];
; 502  : 		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv144[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv144[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 503  : 		if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN2@do_get

; 504  : 			{	// ditto "fails to convert the entire field" / VSO#591516
; 505  : 			_State = ios_base::failbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], 2

; 506  : 			_Val = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	WORD PTR [edx], cx

; 507  : 			}
; 508  : 		else

	jmp	$LN3@do_get
$LN2@do_get:

; 509  : 			{
; 510  : 			const bool _Minus = _Ac[0] == '-';

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$[ebp+ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN11@do_get
	mov	BYTE PTR tv88[ebp], 1
	jmp	SHORT $LN12@do_get
$LN11@do_get:
	mov	BYTE PTR tv88[ebp], 0
$LN12@do_get:
	mov	al, BYTE PTR tv88[ebp]
	mov	BYTE PTR __Minus$7[ebp], al

; 511  : 			const char * _Digits = _Ac;

	lea	ecx, DWORD PTR __Ac$[ebp]
	mov	DWORD PTR __Digits$6[ebp], ecx

; 512  : 			// C11 7.22.1.4/5: the sequence of characters starting with the first digit
; 513  : 			// is interpreted as an integer constant according to the rules of 6.4.4.1
; 514  : 			if (_Minus)

	movzx	edx, BYTE PTR __Minus$7[ebp]
	test	edx, edx
	je	SHORT $LN4@do_get

; 515  : 				{	// skip over minus to start with the first digit
; 516  : 				++_Digits;

	mov	eax, DWORD PTR __Digits$6[ebp]
	add	eax, 1
	mov	DWORD PTR __Digits$6[ebp], eax
$LN4@do_get:

; 517  : 				}
; 518  : 
; 519  : 			char * _Ep;
; 520  : 			int _Errno;
; 521  : 			const unsigned long _Tmp = _CSTD _Stoulx(_Digits, &_Ep, _Base, &_Errno);	// convert

	lea	ecx, DWORD PTR __Errno$3[ebp]
	push	ecx
	mov	edx, DWORD PTR __Base$[ebp]
	push	edx
	lea	eax, DWORD PTR __Ep$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Digits$6[ebp]
	push	ecx
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Tmp$5[ebp], eax

; 522  : 			_Val = static_cast<unsigned short>(_Tmp);

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ax, WORD PTR __Tmp$5[ebp]
	mov	WORD PTR [edx], ax

; 523  : 			if (_Ep == _Digits || _Errno != 0 || _Tmp > USHRT_MAX)

	mov	ecx, DWORD PTR __Ep$4[ebp]
	cmp	ecx, DWORD PTR __Digits$6[ebp]
	je	SHORT $LN7@do_get
	cmp	DWORD PTR __Errno$3[ebp], 0
	jne	SHORT $LN7@do_get
	cmp	DWORD PTR __Tmp$5[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@do_get
$LN7@do_get:

; 524  : 				{
; 525  : 				_State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2

; 526  : 				_Val = USHRT_MAX;

	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	WORD PTR [ecx], ax
	jmp	SHORT $LN3@do_get
$LN5@do_get:

; 527  : 				}
; 528  : 			else if (_Minus)

	movzx	edx, BYTE PTR __Minus$7[ebp]
	test	edx, edx
	je	SHORT $LN3@do_get

; 529  : 				{	// C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,
; 530  : 					// the value resulting from the conversion is negated (in the return type).
; 531  : 				_Val = static_cast<unsigned short>(0 - _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	movzx	ecx, WORD PTR [eax]
	xor	edx, edx
	sub	edx, ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	WORD PTR [eax], dx
$LN3@do_get:

; 532  : 				}
; 533  : 			}
; 534  : 
; 535  : 		if (_First == _Last)

	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@do_get

; 536  : 			{
; 537  : 			_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [eax], edx
$LN9@do_get:

; 538  : 			}
; 539  : 
; 540  : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 541  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
$T2 = -208						; size = 28
$T3 = -180						; size = 28
__Ac$4 = -152						; size = 32
__Str$5 = -120						; size = 28
$T6 = -92						; size = 8
$T7 = -84						; size = 8
__Errno$8 = -76						; size = 4
__Ep$9 = -72						; size = 4
__Base$10 = -68						; size = 4
_this$ = -64						; size = 4
tv184 = -60						; size = 4
tv187 = -56						; size = 4
tv182 = -52						; size = 4
tv186 = -48						; size = 4
tv180 = -44						; size = 4
tv78 = -40						; size = 4
tv177 = -36						; size = 4
tv185 = -32						; size = 4
tv166 = -28						; size = 4
tv137 = -24						; size = 4
__Punct_fac$11 = -20					; size = 4
__Ans$12 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 430  : 		{	// get bool from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 8

; 432  : 		if (_Iosbase.flags() & ios_base::boolalpha)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	je	$LN4@do_get

; 433  : 			{	// get false name or true name
; 434  : 			const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv185[ebp], eax
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR tv177[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv177[ebp]
	push	ecx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 435  : 			basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});

	push	0
	push	1
	lea	ecx, DWORD PTR __Str$5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 436  : 			_Str += _Punct_fac.falsename();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$11[ebp]
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	DWORD PTR tv78[ebp], eax
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv180[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv180[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$5[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 437  : 			_Str.push_back(_Elem{});

	push	0
	lea	ecx, DWORD PTR __Str$5[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 438  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$11[ebp]
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	DWORD PTR tv186[ebp], eax
	mov	eax, DWORD PTR tv186[ebp]
	mov	DWORD PTR tv182[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv182[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$5[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 439  : 			switch (_Getloctxt(_First, _Last, 2, _Str.c_str()))

	lea	ecx, DWORD PTR __Str$5[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	push	2
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv137[ebp], eax
	cmp	DWORD PTR tv137[ebp], 0
	je	SHORT $LN6@do_get
	cmp	DWORD PTR tv137[ebp], 1
	je	SHORT $LN7@do_get
	jmp	SHORT $LN8@do_get
$LN6@do_get:

; 440  : 				{
; 441  : 				case 0:
; 442  : 					_Val = false;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [ecx], 0

; 443  : 					break;

	jmp	SHORT $LN2@do_get
$LN7@do_get:

; 444  : 				case 1:
; 445  : 					_Val = true;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [edx], 1

; 446  : 					break;

	jmp	SHORT $LN2@do_get
$LN8@do_get:

; 447  : 				default:
; 448  : 					_Val = false;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], 0

; 449  : 					_State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2
$LN2@do_get:

; 450  : 					break;
; 451  : 				}
; 452  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 453  : 		else

	jmp	$LN5@do_get
$LN4@do_get:

; 454  : 			{	// get long value
; 455  : 			char _Ac[_MAX_INT_DIG];
; 456  : 			const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field

	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv187[ebp], eax
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv184[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv184[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ac$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Base$10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 457  : 			if (_Ac[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR __Ac$4[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN9@do_get

; 458  : 				{	// Handle N4727 [facet.num.get.virtuals]/3.6:
; 459  : 					//  "zero, if the conversion function does not convert the entire field."
; 460  : 					// We should still do numeric conversion with bad digit separators, instead of
; 461  : 					// setting 0, but we can't distinguish that from _Getifld's interface, and _Getifld's
; 462  : 					// interface can't be changed as it is an exported function. Fixing that when ABI
; 463  : 					// allows is tracked by VSO#591516.
; 464  : 				_Val = false;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [eax], 0

; 465  : 				_State = ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx], 2

; 466  : 				}
; 467  : 			else

	jmp	SHORT $LN5@do_get
$LN9@do_get:

; 468  : 				{
; 469  : 				char * _Ep;
; 470  : 				int _Errno;
; 471  : 				const long _Ans = _CSTD _Stolx(_Ac, &_Ep, _Base, &_Errno);	// convert

	lea	edx, DWORD PTR __Errno$8[ebp]
	push	edx
	mov	eax, DWORD PTR __Base$10[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ep$9[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ac$4[ebp]
	push	edx
	call	__Stolx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ans$12[ebp], eax

; 472  : 				if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$4[ebp]
	cmp	DWORD PTR __Ep$9[ebp], eax
	je	SHORT $LN13@do_get
	cmp	DWORD PTR __Errno$8[ebp], 0
	je	SHORT $LN11@do_get
$LN13@do_get:

; 473  : 					{
; 474  : 					_Val = true;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	BYTE PTR [ecx], 1

; 475  : 					_State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2

; 476  : 					}
; 477  : 				else

	jmp	SHORT $LN5@do_get
$LN11@do_get:

; 478  : 					{
; 479  : 					_Val = _Ans != 0;

	cmp	DWORD PTR __Ans$12[ebp], 0
	je	SHORT $LN17@do_get
	mov	DWORD PTR tv166[ebp], 1
	jmp	SHORT $LN18@do_get
$LN17@do_get:
	mov	DWORD PTR tv166[ebp], 0
$LN18@do_get:
	mov	eax, DWORD PTR __Val$[ebp]
	mov	cl, BYTE PTR tv166[ebp]
	mov	BYTE PTR [eax], cl

; 480  : 					if (_Ans != 0 && _Ans != 1)

	cmp	DWORD PTR __Ans$12[ebp], 0
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Ans$12[ebp], 1
	je	SHORT $LN5@do_get

; 481  : 						{
; 482  : 						_State = ios_base::failbit;

	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], 2
$LN5@do_get:

; 483  : 						}
; 484  : 					}
; 485  : 				}
; 486  : 			}
; 487  : 
; 488  : 		if (_First == _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@do_get

; 489  : 			{
; 490  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [edx], ecx
$LN15@do_get:

; 491  : 			}
; 492  : 
; 493  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 494  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
	lea	ecx, DWORD PTR __Str$5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get, COMDAT
; _this$ = ecx

; 373  : 		{	// get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 375  : 		}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		: locale::facet(_Refs)

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 342  : 		{	// construct from specified locale

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 343  : 		_Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init

; 344  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 328  : 		{	// initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 324  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 325  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv94 = -32						; size = 4
tv131 = -28						; size = 4
tv88 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 313  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR $T5[ebp], 0

; 314  : 		if (_Ppf != nullptr && *_Ppf == nullptr)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN2@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@Getcat

; 315  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	8
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?c_str@locale@std@@QBEPBDXZ		; std::locale::c_str
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	and	ecx, 1
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 316  : 				_Locinfo(_Ploc->c_str()));
; 317  : 		return (_X_NUMERIC);

	mov	eax, 4

; 318  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 12
$T3 = -40						; size = 4
__Lock$4 = -36						; size = 4
__Id$5 = -32						; size = 4
__Psave_guard$6 = -28					; size = 4
__Pf$7 = -24						; size = 4
__Pfmod$8 = -20						; size = 4
__Psave$9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 505  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$9[ebp], eax

; 509  : 
; 510  : 		const size_t _Id = _Facet::id;

	mov	ecx, OFFSET ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$5[ebp], eax

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$7[ebp], eax

; 512  : 
; 513  : 		if (_Pf == nullptr)

	cmp	DWORD PTR __Pf$7[ebp], 0
	jne	$LN2@use_facet

; 514  : 			{
; 515  : 			if (_Psave != nullptr)

	cmp	DWORD PTR __Psave$9[ebp], 0
	je	SHORT $LN3@use_facet

; 516  : 				{
; 517  : 				_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 518  : 				}
; 519  : 			else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$9[ebp]
	push	ecx
	call	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 520  : 				{
; 521  :  #if _HAS_EXCEPTIONS
; 522  : 				_THROW(bad_cast{});	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 				abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 				}
; 527  : 			else

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 528  : 				{	// queue up lazy facet for destruction
; 529  : 				auto _Pfmod = const_cast<locale::facet *>(_Psave);

	mov	eax, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pfmod$8[ebp], eax

; 530  : 				unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base *>(_Pfmod));

	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 531  : 
; 532  :  #if defined(_M_CEE)
; 533  : 				_Facet_Register_m(_Pfmod);
; 534  :  #else /* defined(_M_CEE) */
; 535  : 				_Facet_Register(_Pfmod);

	mov	edx, DWORD PTR __Pfmod$8[ebp]
	push	edx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 536  :  #endif /* defined(_M_CEE) */
; 537  : 
; 538  : 				_Pfmod->_Incref();

	mov	eax, DWORD PTR __Pfmod$8[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 539  : 				_Facetptr<_Facet>::_Psave = _Psave;

	mov	ecx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 540  : 				_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx

; 541  : 
; 542  : 				(void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 543  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 544  : 			}
; 545  : 
; 546  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	mov	eax, DWORD PTR __Pf$7[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T3[ebp]
$LN7@use_facet:

; 547  : 	_END_LOCK()
; 548  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$4[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Odtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 120  : 			{	// test if _Ipfx succeeded

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 122  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 115  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 			: _Sentry_base(_Istr)

	mov	eax, DWORD PTR __Istr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	movzx	ecx, BYTE PTR __Noskip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 117  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -28						; size = 4
tv86 = -24						; size = 4
_this$ = -20						; size = 4
tv72 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			if (_Myistr.rdbuf() != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $LN3@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR tv86[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv92[ebp], eax
	mov	eax, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN3@Sentry_bas:

; 102  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv87 = -12						; size = 4
tv73 = -8						; size = 4
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 93   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 			: _Myistr(_Istr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [eax], ecx

; 94   : 			if (_Myistr.rdbuf() != nullptr)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN1@Sentry_bas:

; 96   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 287  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	add	esp, 4

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 288  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Assign_range@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Newcapacity$1 = -28					; size = 4
__Newlast$2 = -24					; size = 4
__Mid$3 = -20						; size = 4
__Oldsize$ = -16					; size = 4
__Oldcapacity$ = -12					; size = 4
__Newsize$ = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Assign_range<STTriangleMesh * *>, COMDAT
; _this$ = ecx

; 1341 : 		{	// assign [_First, _Last), forward iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1342 : 		const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$distance@PAPAVSTTriangleMesh@@@std@@YAHPAPAVSTTriangleMesh@@0@Z ; std::distance<STTriangleMesh * *>
	add	esp, 8
	push	eax
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	mov	DWORD PTR __Newsize$[ebp], eax

; 1343 : 
; 1344 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all

; 1345 : 
; 1346 : 		const size_type _Oldsize = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	mov	DWORD PTR __Oldsize$[ebp], eax

; 1347 : 		const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1348 : 
; 1349 : 		if (_Newsize > _Oldcapacity)

	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, DWORD PTR __Oldcapacity$[ebp]
	jbe	$LN2@Assign_ran

; 1350 : 			{	// reallocate
; 1351 : 			if (_Newsize > max_size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jbe	SHORT $LN4@Assign_ran

; 1352 : 				{
; 1353 : 				_Xlength();

	call	?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xlength
$LN4@Assign_ran:

; 1354 : 				}
; 1355 : 
; 1356 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@ABEII@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$1[ebp], eax

; 1357 : 
; 1358 : 			if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Assign_ran

; 1359 : 				{	// destroy and deallocate old array
; 1360 : 				_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy

; 1361 : 				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z ; std::allocator<STTriangleMesh *>::deallocate
$LN5@Assign_ran:

; 1362 : 				}
; 1363 : 
; 1364 : 			_Buy(_Newcapacity);

	mov	edx, DWORD PTR __Newcapacity$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAE_NI@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Buy

; 1365 : 
; 1366 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Ucopy<STTriangleMesh * *>
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	DWORD PTR [eax], esi
	jmp	$LN8@Assign_ran
$LN2@Assign_ran:

; 1367 : 			}
; 1368 : 		else if (_Newsize > _Oldsize)

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Oldsize$[ebp]
	jbe	SHORT $LN6@Assign_ran

; 1369 : 			{
; 1370 : 			// performance note: traversing [_First, _Mid) twice
; 1371 : 			const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));

	mov	ecx, DWORD PTR __Oldsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$next@PAPAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@H@Z ; std::next<STTriangleMesh * *>
	add	esp, 8
	mov	DWORD PTR __Mid$3[ebp], eax

; 1372 : 			_Copy_unchecked(_First, _Mid, this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Mid$3[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_unchecked<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 1373 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEPAPAVSTTriangleMesh@@PAPAV2@00@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Ucopy<STTriangleMesh * *>
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	DWORD PTR [eax], esi

; 1374 : 			}
; 1375 : 		else

	jmp	SHORT $LN8@Assign_ran
$LN6@Assign_ran:

; 1376 : 			{
; 1377 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Newlast$2[ebp], edx

; 1378 : 			_Copy_unchecked(_First, _Last, this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_unchecked@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAPAPAVSTTriangleMesh@@PAPAV1@00@Z ; std::_Copy_unchecked<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 1379 : 			_Destroy(_Newlast, this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Newlast$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy

; 1380 : 			this->_Mylast() = _Newlast;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	edx, DWORD PTR __Newlast$2[ebp]
	mov	DWORD PTR [eax], edx
$LN8@Assign_ran:

; 1381 : 			}
; 1382 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Assign_range@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Assign_range<STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z PROC ; std::_Get_unwrapped<STTriangleMesh *>, COMDAT

; 662  : 	{	// special case already-unwrapped pointers

	push	ebp
	mov	ebp, esp

; 663  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 664  : 	}

	pop	ebp
	ret	0
??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ENDP ; std::_Get_unwrapped<STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0@Z PROC ; std::_Adl_verify_range<STTriangleMesh * *,STTriangleMesh * *>, COMDAT

; 615  : 	{	// check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp
	push	ecx

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adl_verify_range1@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0U?$integral_constant@_N$00@0@@Z ; std::_Adl_verify_range1<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 12					; 0000000cH

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0@Z ENDP ; std::_Adl_verify_range<STTriangleMesh * *,STTriangleMesh * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z PROC ; std::forward<STPoint3>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

	pop	ebp
	ret	0
??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z ENDP ; std::forward<STPoint3>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Storage_ptr$ = 12					; size = 4
___formal$ = 16						; size = 4
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z PROC ; std::_Immortalize_impl<std::_Iostream_error_category>, COMDAT

; 600  : 	{	// adapt True Placement New to _Execute_once

	push	ebp
	mov	ebp, esp
	push	ecx

; 601  : 	::new (_Storage_ptr) _Ty();

	mov	eax, DWORD PTR __Storage_ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category

; 602  : 	return (1);

	mov	eax, 1

; 603  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ENDP ; std::_Immortalize_impl<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 2212 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2211 : 			: _Mybase(_Ptr)

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>

; 2213 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 2321 : 		{	// yield ownership of pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2322 : 		pointer _Ans = get();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
	mov	DWORD PTR __Ans$[ebp], eax

; 2323 : 		this->_Myptr() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
	mov	DWORD PTR [eax], 0

; 2324 : 		return (_Ans);

	mov	eax, DWORD PTR __Ans$[ebp]

; 2325 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get, COMDAT
; _this$ = ecx

; 2311 : 		{	// return pointer to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2312 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
	mov	eax, DWORD PTR [eax]

; 2313 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 2293 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2294 : 		if (get() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
	test	eax, eax
	je	SHORT $LN3@unique_ptr

; 2295 : 			{
; 2296 : 			this->get_deleter()(get());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
$LN3@unique_ptr:

; 2297 : 			}
; 2298 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 303  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 293  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2163 : 		{	// return const reference to pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2164 : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second

; 2165 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2158 : 		{	// return reference to pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2159 : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second

; 2160 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter, COMDAT
; _this$ = ecx

; 2148 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2149 : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first

; 2150 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv70 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 2081 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2082 : 		static_assert(0 < sizeof (_Ty),
; 2083 : 			"can't delete an incomplete type");
; 2084 : 		delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@operator
	push	1
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR tv70[ebp], 0
$LN2@operator:

; 2085 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z PROC ; std::_Adl_verify_range1<char const *,char const *>, COMDAT

; 602  : 	{	// check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp

; 603  : 	_Verify_range(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Verify_range@D@std@@YAXQBD0@Z	; std::_Verify_range<char>
	add	esp, 8

; 604  : 	}

	pop	ebp
	ret	0
??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Adl_verify_range1<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Verify_range@D@std@@YAXQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Verify_range@D@std@@YAXQBD0@Z PROC			; std::_Verify_range<char>, COMDAT

; 558  : 	{	// special case range verification for pointers

	push	ebp
	mov	ebp, esp
$LN4@Verify_ran:

; 559  : 	_STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	ja	SHORT $LN7@Verify_ran
	jmp	SHORT $LN2@Verify_ran
$LN7@Verify_ran:
	push	OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	559					; 0000022fH
	push	OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@Verify_ran
	int	3
$LN11@Verify_ran:
	push	0
	push	559					; 0000022fH
	push	OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
	push	OFFSET ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN7@Verify_ran
$LN2@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN4@Verify_ran

; 560  : 	}

	pop	ebp
	ret	0
??$_Verify_range@D@std@@YAXQBD0@Z ENDP			; std::_Verify_range<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Old_ptr$1 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__Al$ = -20						; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3922 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], edx

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3930 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3931 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3935 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 3940 : 			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_2>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Raw_new$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	edx, DWORD PTR __Old_capacity$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 3943 : 			}
; 3944 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3945 : 			{
; 3946 : 			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	eax, BYTE PTR _<_Args_2>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_1>$[ebp]
	push	ecx
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Raw_new$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3947 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3948 : 			}
; 3949 : 
; 3950 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$ = ecx

; 2802 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2803 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2804 : 			_Traits::assign(_New_ptr + _Off, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Off$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2805 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Old_size$[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Off$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2806 : 			}, _Off, _Count, _Ch));

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$ = -8					; size = 4
__Result$ = -4						; size = 4
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$[ebp], 536870911 ; 1fffffffH

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	DWORD PTR __Result$[ebp], eax

; 26   : 	if (_Max_possible < _Count)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	DWORD PTR __Result$[ebp], -1
$LN2@Get_size_o:

; 30   : 		}
; 31   : 
; 32   : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 311  : 		{	// count number of available positions in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		return (*_IPnext != nullptr ? *_IPcount : 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Pnavail
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@Pnavail
$LN3@Pnavail:
	mov	DWORD PTR tv69[ebp], 0
$LN4@Pnavail:
	mov	eax, DWORD PTR tv69[ebp]
	cdq

; 313  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 305  : 		{	// increment current position in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 306  : 		--*_IPcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 307  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 280  : 		{	// count number of available elements in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 281  : 		return (*_IGnext != nullptr ? *_IGcount : 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Gnavail
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@Gnavail
$LN3@Gnavail:
	mov	DWORD PTR tv69[ebp], 0
$LN4@Gnavail:
	mov	eax, DWORD PTR tv69[ebp]
	cdq

; 282  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 274  : 		{	// preincrement current position in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 		--*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx], edx

; 276  : 		return (++(*_IGnext));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv72[ebp]

; 277  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 268  : 		{	// increment current position in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 		--*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx], edx

; 270  : 		return ((*_IGnext)++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 271  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 224  : 		{	// return current position in read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx]

; 226  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 205  : 		{	// put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		return (xsputn(_Ptr, _Count));

	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 207  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv85 = -20						; size = 8
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 197  : 		{	// put a character

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		return (0 < _Pnavail()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	mov	DWORD PTR tv85[ebp], eax
	mov	DWORD PTR tv85[ebp+4], edx
	cmp	DWORD PTR tv85[ebp+4], 0
	jl	SHORT $LN3@sputc
	jg	SHORT $LN5@sputc
	cmp	DWORD PTR tv85[ebp], 0
	jbe	SHORT $LN3@sputc
$LN5@sputc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN4@sputc
$LN3@sputc:
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv78[ebp], eax
$LN4@sputc:
	mov	eax, DWORD PTR tv78[ebp]

; 199  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 200  : 			: overflow(_Traits::to_int_type(_Ch)));
; 201  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv89 = -28						; size = 8
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv83 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 165  : 		{	// point to next character and return it

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		return (1 < _Gnavail()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv89[ebp], eax
	mov	DWORD PTR tv89[ebp+4], edx
	cmp	DWORD PTR tv89[ebp+4], 0
	jl	SHORT $LN5@snextc
	jg	SHORT $LN7@snextc
	cmp	DWORD PTR tv89[ebp], 1
	jbe	SHORT $LN5@snextc
$LN7@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN6@snextc
$LN5@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
	mov	DWORD PTR $T2[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@snextc
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@snextc
$LN3@snextc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv82[ebp], eax
$LN4@snextc:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN6@snextc:
	mov	eax, DWORD PTR tv83[ebp]

; 167  : 			? _Traits::to_int_type(*_Gnpreinc())
; 168  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 169  : 				? _Traits::eof() : sgetc());
; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv82 = -16						; size = 8
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 153  : 		{	// get a character and don't point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		return (0 < _Gnavail()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR tv82[ebp+4], edx
	cmp	DWORD PTR tv82[ebp+4], 0
	jl	SHORT $LN3@sgetc
	jg	SHORT $LN5@sgetc
	cmp	DWORD PTR tv82[ebp], 0
	jbe	SHORT $LN3@sgetc
$LN5@sgetc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@sgetc
$LN3@sgetc:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	DWORD PTR tv75[ebp], eax
$LN4@sgetc:
	mov	eax, DWORD PTR tv75[ebp]

; 155  : 			? _Traits::to_int_type(*gptr()) : underflow());
; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv82 = -16						; size = 8
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 147  : 		{	// get a character and point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		return (0 < _Gnavail()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR tv82[ebp+4], edx
	cmp	DWORD PTR tv82[ebp+4], 0
	jl	SHORT $LN3@sbumpc
	jg	SHORT $LN5@sbumpc
	cmp	DWORD PTR tv82[ebp], 0
	jbe	SHORT $LN3@sbumpc
$LN5@sbumpc:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@sbumpc
$LN3@sbumpc:
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	DWORD PTR tv75[ebp], eax
$LN4@sbumpc:
	mov	eax, DWORD PTR tv75[ebp]

; 149  : 			? _Traits::to_int_type(*_Gninc()) : uflow());
; 150  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 142  : 		{	// synchronize with external agent

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return (sync());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@@Z PROC ; std::_Destroy_range<std::allocator<STTriangleMesh *> >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<STTriangleMesh *> >
	add	esp, 16					; 00000010H

; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<STTriangleMesh *> > >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<STTriangleMesh *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 345  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 346  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><STTriangleMesh *>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum TextureType *> >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H

; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >, COMDAT

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_value_construct_n1@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -16						; size = 4
__UDest$ = -12						; size = 4
__UFirst$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z PROC ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >, COMDAT

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 210  : 		// note: only called internally from elsewhere in the STL
; 211  : 	const auto _UFirst = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z ; std::_Get_unwrapped<enum TextureType *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 212  : 	const auto _ULast = _Get_unwrapped(_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Get_unwrapped@PAW4TextureType@@@std@@YAPAPAW4TextureType@@QAPAW41@@Z ; std::_Get_unwrapped<enum TextureType *>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 213  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	edx, DWORD PTR __ULast$[ebp]
	push	edx
	lea	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$_Idl_distance@PAPAW4TextureType@@PAPAW41@@std@@YAHABQAPAW4TextureType@@0@Z ; std::_Idl_distance<enum TextureType * *,enum TextureType * *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Get_unwrapped_n@PAW4TextureType@@H$0A@@std@@YAPAPAW4TextureType@@QAPAW41@H@Z ; std::_Get_unwrapped_n<enum TextureType *,int,0>
	add	esp, 8
	mov	DWORD PTR __UDest$[ebp], eax

; 214  : 	_Seek_wrapped(_Dest,

	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR __UDest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __UFirst$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Ptr_copy_cat@PAW4TextureType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4TextureType@@0@Z ; std::_Ptr_copy_cat<enum TextureType *,enum TextureType *>
	add	esp, 12					; 0000000cH
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __UDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Uninitialized_copy_al_unchecked@PAW4TextureType@@PAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@00AAV?$allocator@PAW4TextureType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<enum TextureType *,enum TextureType *,std::allocator<enum TextureType *> >
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Seek_wrapped@PAW4TextureType@@@std@@YAXAAPAPAW4TextureType@@QAPAW41@@Z ; std::_Seek_wrapped<enum TextureType *>
	add	esp, 8

; 215  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 216  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 217  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
; 218  : 
; 219  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ENDP ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@W4TextureType@@@std@@QAE@XZ ; std::allocator<enum TextureType>::allocator<enum TextureType>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Deque_val<std::_Deque_simple_types<enum TextureType> >

; 279  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum TextureType>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$ = -8					; size = 4
__Result$ = -4						; size = 4
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$[ebp], 1073741823 ; 3fffffffH

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	DWORD PTR __Result$[ebp], eax

; 26   : 	if (_Max_possible < _Count)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	jbe	SHORT $LN2@Get_size_o

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	DWORD PTR __Result$[ebp], -1
$LN2@Get_size_o:

; 30   : 		}
; 31   : 
; 32   : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum MeshType *> >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H

; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >, COMDAT

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_value_construct_n1@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -16						; size = 4
__UDest$ = -12						; size = 4
__UFirst$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z PROC ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >, COMDAT

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 210  : 		// note: only called internally from elsewhere in the STL
; 211  : 	const auto _UFirst = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z ; std::_Get_unwrapped<enum MeshType *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 212  : 	const auto _ULast = _Get_unwrapped(_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Get_unwrapped@PAW4MeshType@@@std@@YAPAPAW4MeshType@@QAPAW41@@Z ; std::_Get_unwrapped<enum MeshType *>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 213  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

	lea	edx, DWORD PTR __ULast$[ebp]
	push	edx
	lea	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	call	??$_Idl_distance@PAPAW4MeshType@@PAPAW41@@std@@YAHABQAPAW4MeshType@@0@Z ; std::_Idl_distance<enum MeshType * *,enum MeshType * *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Get_unwrapped_n@PAW4MeshType@@H$0A@@std@@YAPAPAW4MeshType@@QAPAW41@H@Z ; std::_Get_unwrapped_n<enum MeshType *,int,0>
	add	esp, 8
	mov	DWORD PTR __UDest$[ebp], eax

; 214  : 	_Seek_wrapped(_Dest,

	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR __UDest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __UFirst$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Ptr_copy_cat@PAW4MeshType@@PAW41@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAW4MeshType@@0@Z ; std::_Ptr_copy_cat<enum MeshType *,enum MeshType *>
	add	esp, 12					; 0000000cH
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __UDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Uninitialized_copy_al_unchecked@PAW4MeshType@@PAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@00AAV?$allocator@PAW4MeshType@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked<enum MeshType *,enum MeshType *,std::allocator<enum MeshType *> >
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Seek_wrapped@PAW4MeshType@@@std@@YAXAAPAPAW4MeshType@@QAPAW41@@Z ; std::_Seek_wrapped<enum MeshType *>
	add	esp, 8

; 215  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 216  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 217  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
; 218  : 
; 219  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ENDP ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@W4MeshType@@@std@@QAE@XZ	; std::allocator<enum MeshType>::allocator<enum MeshType>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Deque_val<std::_Deque_simple_types<enum MeshType> >

; 279  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>, COMDAT

; 1212 : 	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case

	push	ebp
	mov	ebp, esp

; 1213 : 	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 1214 : 	}

	pop	ebp
	ret	0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 871  : 		{	// deallocate _Count elements at _Ptr

	push	ebp
	mov	ebp, esp

; 872  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 874  : 		}

	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum MeshType>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 199  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

	push	ebp
	mov	ebp, esp

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	edx, DWORD PTR __Bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 208  : 	}

	pop	ebp
	ret	0
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 180  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

	push	ebp
	mov	ebp, esp

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Allocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

	cmp	DWORD PTR __Bytes$[ebp], 0
	je	SHORT $LN3@Allocate

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, DWORD PTR __Bytes$[ebp]
	push	ecx
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

	xor	eax, eax
$LN1@Allocate:

; 194  : 	}

	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABQAD@std@@YAABQADABQAD@Z	; std::forward<char * const &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Old_ptr$1 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__Al$ = -20						; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3922 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], edx

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3930 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3931 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3935 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 3940 : 			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old_capacity$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3943 : 			}
; 3944 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3945 : 			{
; 3946 : 			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	edx, DWORD PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3947 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3948 : 			}
; 3949 : 
; 3950 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2583 : 				const _Elem * const _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2584 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2585 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2586 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2587 : 			}, _Ptr, _Count));

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Old_ptr$1 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__Al$ = -20						; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3922 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR __Size_increase$[ebp]
	jae	SHORT $LN2@Reallocate

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Size_increase$[ebp]
	mov	DWORD PTR __New_size$[ebp], edx

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3930 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3931 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3935 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Raw_new$[ebp], eax

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Old_ptr$1[ebp], ecx

; 3940 : 			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old_capacity$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3943 : 			}
; 3944 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3945 : 			{
; 3946 : 			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_1>$[ebp]
	push	edx
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __Raw_new$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3947 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3948 : 			}
; 3949 : 
; 3950 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3951 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 2610 : 				const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2611 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2612 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2613 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2614 : 			}, _Count, _Ch));

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old_capacity$ = -24					; size = 4
__New_capacity$ = -20					; size = 4
__Al$ = -16						; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3887 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3888 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3889 : 		if (_New_size > max_size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __New_size$[ebp], eax
	jbe	SHORT $LN2@Reallocate

; 3890 : 			{
; 3891 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3892 : 			}
; 3893 : 
; 3894 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3895 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3896 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3897 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3899 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3900 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3901 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3902 : 		_Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()

; 3903 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3904 : 			{
; 3905 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	mov	edx, DWORD PTR __Old_capacity$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3906 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3907 : 			}
; 3908 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3909 : 			{
; 3910 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3911 : 			}
; 3912 : 
; 3913 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3914 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2669 : 			_Traits::copy(_New_ptr, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2671 : 			}, _Ptr));

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__Old_capacity$ = -24					; size = 4
__New_capacity$ = -20					; size = 4
__Al$ = -16						; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3887 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3888 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3889 : 		if (_New_size > max_size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __New_size$[ebp], eax
	jbe	SHORT $LN2@Reallocate

; 3890 : 			{
; 3891 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:

; 3892 : 			}
; 3893 : 
; 3894 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3895 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Old_capacity$[ebp], ecx

; 3896 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	edx, DWORD PTR __New_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 3897 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 3899 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3900 : 		_My_data._Mysize = _New_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __New_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3901 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3902 : 		_Fn(_Unfancy(_New_ptr), _New_size, _Args...);

	movzx	edx, BYTE PTR _<_Args_0>$[ebp]
	push	edx
	mov	eax, DWORD PTR __New_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Fn$[ebp]
	call	??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()

; 3903 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old_capacity$[ebp], 16	; 00000010H
	jb	SHORT $LN3@Reallocate

; 3904 : 			{
; 3905 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	mov	edx, DWORD PTR __Old_capacity$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3906 : 			_My_data._Bx._Ptr = _New_ptr;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3907 : 			}
; 3908 : 		else

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3909 : 			{
; 3910 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

	lea	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH
$LN4@Reallocate:

; 3911 : 			}
; 3912 : 
; 3913 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3914 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$ = ecx

; 2691 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2692 : 			_Traits::assign(_New_ptr, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2693 : 			_Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2694 : 			}, _Ch));

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Max_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Max_value
$LN3@Max_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Max_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 34   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 279  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Tag$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1099 : 	{	// (maybe) propagate on container move assignment

	push	ebp
	mov	ebp, esp
	push	ecx

; 1100 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1101 : 	_Pocma(_Left, _Right, _Tag);

	movzx	eax, BYTE PTR __Tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Left$[ebp]
	push	edx
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
	add	esp, 12					; 0000000cH

; 1102 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 1054 : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp

; 1055 : 	return (false);

	xor	al, al

; 1056 : 	}

	pop	ebp
	ret	0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$numpunct@D@std@@MAE@XZ		; std::numpunct<char>::~numpunct<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 254  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		_CSTD free((void *)_Grouping);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_free
	add	esp, 4

; 256  : 		_CSTD free((void *)_Falsename);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_free
	add	esp, 4

; 257  : 		_CSTD free((void *)_Truename);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_free
	add	esp, 4

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 248  : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 249  : 		return (string_type(_Truename));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 243  : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 244  : 		return (string_type(_Falsename));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 245  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 238  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 239  : 		return (string(_Grouping));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 233  : 		{	// return thousands separator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return (_Kseparator);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+13]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 228  : 		{	// return decimal point

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 229  : 		return (_Dp);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+12]

; 230  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -140						; size = 44
__Cvt$ = -96						; size = 44
tv154 = -52						; size = 4
tv153 = -48						; size = 4
tv152 = -44						; size = 4
tv151 = -40						; size = 4
tv150 = -36						; size = 4
tv149 = -32						; size = 4
__Ptr$ = -28						; size = 4
tv81 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 200  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ; std::_Locinfo::_Getlconv
	mov	DWORD PTR __Ptr$[ebp], eax

; 202  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt

; 203  : 
; 204  : 		_Grouping = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 205  : 		_Falsename = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 206  : 		_Truename = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 207  : 
; 208  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 209  : 		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char *>(nullptr), _Lobj._Getcvt());

	movzx	ecx, BYTE PTR __Isdef$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@Init
	mov	DWORD PTR tv81[ebp], OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN7@Init
$LN6@Init:
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv81[ebp], eax
$LN7@Init:
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	DWORD PTR tv149[ebp], eax
	mov	edx, DWORD PTR tv149[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR tv81[ebp]
	push	eax
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR [ecx+8], edx

; 210  : 		_Falsename = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem *>(nullptr), _Cvt);

	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getfalse@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Getfalse
	mov	DWORD PTR tv151[ebp], eax
	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv151[ebp]
	push	ecx
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv152[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv152[ebp]
	mov	DWORD PTR [edx+16], eax

; 211  : 		_Truename = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem *>(nullptr), _Cvt);

	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Gettrue@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Gettrue
	mov	DWORD PTR tv153[ebp], eax
	lea	ecx, DWORD PTR __Cvt$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv153[ebp]
	push	edx
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv154[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR [eax+20], ecx
	jmp	SHORT $LN8@Init
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 212  : 		_CATCH_ALL
; 213  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 214  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 215  : 		_CATCH_END

	mov	eax, $LN11@Init
	ret	0
$LN8@Init:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$1
$LN11@Init:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$1:

; 216  : 
; 217  : 		if (_Isdef)

	movzx	edx, BYTE PTR __Isdef$[ebp]
	test	edx, edx
	je	SHORT $LN3@Init

; 218  : 			{	// apply defaults for required facets
; 219  : //			_Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 220  : 			_Dp = _Maklocchr('.', static_cast<_Elem *>(nullptr), _Cvt);

	lea	eax, DWORD PTR __Cvt$[ebp]
	push	eax
	push	0
	push	46					; 0000002eH
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], al

; 221  : 			_Kseparator = _Maklocchr(',', static_cast<_Elem *>(nullptr), _Cvt);

	lea	edx, DWORD PTR __Cvt$[ebp]
	push	edx
	push	0
	push	44					; 0000002cH
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], al

; 222  : 			}
; 223  : 		else

	jmp	SHORT $LN5@Init
$LN3@Init:

; 224  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

	sub	esp, 44					; 0000002cH
	mov	ecx, 11					; 0000000bH
	lea	esi, DWORD PTR __Cvt$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
$LN5@Init:

; 225  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 174  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$numpunct@D@std@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$numpunct@D@std@@6B@

; 175  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 176  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$numpunct@D@std@@MAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$numpunct@D@std@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv95 = -32						; size = 4
tv132 = -28						; size = 4
tv89 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 165  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR $T5[ebp], 0

; 166  : 		if (_Ppf != nullptr && *_Ppf == nullptr)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN2@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@Getcat

; 167  : 			*_Ppf = new numpunct<_Elem>(

	push	24					; 00000018H
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	1
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?c_str@locale@std@@QBEPBDXZ		; std::locale::c_str
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ; std::numpunct<char>::numpunct<char>
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv89[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	and	ecx, 1
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 168  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 169  : 		return (_X_NUMERIC);

	mov	eax, 4

; 170  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 159  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		: locale::facet(_Refs)

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 159  : 		{	// construct from specified locale

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$numpunct@D@std@@6B@

; 160  : 		_Init(_Lobj, _Isdef);

	movzx	edx, BYTE PTR __Isdef$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lobj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 161  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 142  : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 143  : 		return (do_truename());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 137  : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 138  : 		return (do_falsename());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 139  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 132  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 133  : 		return (do_grouping());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 134  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 127  : 		{	// return thousands separator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		return (do_thousands_sep());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 129  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 122  : 		{	// return decimal point

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		return (do_decimal_point());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 12
$T3 = -40						; size = 4
__Lock$4 = -36						; size = 4
__Id$5 = -32						; size = 4
__Psave_guard$6 = -28					; size = 4
__Pf$7 = -24						; size = 4
__Pfmod$8 = -20						; size = 4
__Psave$9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 505  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __Psave$9[ebp], eax

; 509  : 
; 510  : 		const size_t _Id = _Facet::id;

	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$5[ebp], eax

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$7[ebp], eax

; 512  : 
; 513  : 		if (_Pf == nullptr)

	cmp	DWORD PTR __Pf$7[ebp], 0
	jne	$LN2@use_facet

; 514  : 			{
; 515  : 			if (_Psave != nullptr)

	cmp	DWORD PTR __Psave$9[ebp], 0
	je	SHORT $LN3@use_facet

; 516  : 				{
; 517  : 				_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 518  : 				}
; 519  : 			else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$9[ebp]
	push	ecx
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 520  : 				{
; 521  :  #if _HAS_EXCEPTIONS
; 522  : 				_THROW(bad_cast{});	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 				abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 				}
; 527  : 			else

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 528  : 				{	// queue up lazy facet for destruction
; 529  : 				auto _Pfmod = const_cast<locale::facet *>(_Psave);

	mov	eax, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pfmod$8[ebp], eax

; 530  : 				unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base *>(_Pfmod));

	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 531  : 
; 532  :  #if defined(_M_CEE)
; 533  : 				_Facet_Register_m(_Pfmod);
; 534  :  #else /* defined(_M_CEE) */
; 535  : 				_Facet_Register(_Pfmod);

	mov	edx, DWORD PTR __Pfmod$8[ebp]
	push	edx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 536  :  #endif /* defined(_M_CEE) */
; 537  : 
; 538  : 				_Pfmod->_Incref();

	mov	eax, DWORD PTR __Pfmod$8[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 539  : 				_Facetptr<_Facet>::_Psave = _Psave;

	mov	ecx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::numpunct<char> >::_Psave

; 540  : 				_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx

; 541  : 
; 542  : 				(void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 543  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 544  : 			}
; 545  : 
; 546  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	mov	eax, DWORD PTR __Pf$7[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T3[ebp]
$LN7@use_facet:

; 547  : 	_END_LOCK()
; 548  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$4[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVSTTriangleMesh@@@std@@QAE@XZ ; std::allocator<STTriangleMesh *>::allocator<STTriangleMesh *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<STTriangleMesh *> >::_Vector_val<std::_Simple_types<STTriangleMesh *> >

; 279  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@@Z
_TEXT	SEGMENT
__Tag$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<STTriangleMesh *> >, COMDAT

; 1080 : 	{	// (maybe) propagate on container copy assignment

	push	ebp
	mov	ebp, esp
	push	ecx

; 1081 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1082 : 	_Pocca(_Left, _Right, _Tag);

	movzx	eax, BYTE PTR __Tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Left$[ebp]
	push	edx
	call	??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<STTriangleMesh *> >
	add	esp, 12					; 0000000cH

; 1083 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@W4TextureType@@W41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@$$QAW43@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@W4TextureType@@W41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@$$QAW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@W4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ; std::forward<enum TextureType>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@W4TextureType@@W41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@$$QAW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEAAW4TextureType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEAAW4TextureType@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*, COMDAT
; _this$ = ecx

; 534  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEABW4TextureType@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*

; 536  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEAAW4TextureType@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >, COMDAT
; _this$ = ecx

; 530  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 		: _Mybase(_Off, _Pdeque)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >

; 531  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Setcont, COMDAT
; _this$ = ecx

; 457  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		this->_Adopt(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEABW4TextureType@@XZ
_TEXT	SEGMENT
__Off$ = -16						; size = 4
__Block$ = -12						; size = 4
_this$ = -8						; size = 4
__Mycont$ = -4						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEABW4TextureType@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*, COMDAT
; _this$ = ecx

; 312  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 314  :  #if _ITERATOR_DEBUG_LEVEL != 0
; 315  : 		_STL_VERIFY(_Mycont, "cannot dereference value-initialized deque iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0DE@MANMEIKC@cannot?5dereference?5value?9initia@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	315					; 0000013bH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN19@operator
	int	3
$LN19@operator:
	push	0
	push	315					; 0000013bH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1OG@LMMEOOCI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
	push	OFFSET ??_C@_1GM@HLAFMPGB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	edx, edx
	jne	SHORT $LN4@operator
$LN10@operator:

; 316  : 		_STL_VERIFY(_Mycont->_Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN13@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], ecx
	jae	SHORT $LN13@operator
	jmp	SHORT $LN8@operator
$LN13@operator:
	push	OFFSET ??_C@_0CN@IEPDPKI@cannot?5deference?5out?5of?5range?5d@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	318					; 0000013eH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN20@operator
	int	3
$LN20@operator:
	push	0
	push	318					; 0000013eH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1OG@LMMEOOCI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
	push	OFFSET ??_C@_1FO@KFELHBJF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn@
	call	__invalid_parameter
	add	esp, 20					; 00000014H

; 317  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize,
; 318  : 			"cannot deference out of range deque iterator");

	xor	edx, edx
	jne	SHORT $LN13@operator
$LN8@operator:
	xor	eax, eax
	jne	SHORT $LN10@operator

; 319  :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 320  : 
; 321  : 		_Size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR __Mycont$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 322  : 		_Size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 323  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	edx, DWORD PTR __Mycont$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]

; 324  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEABW4TextureType@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 306  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 308  : 		_Setcont((_Mydeque *)_Pdeque);

	mov	edx, DWORD PTR __Pdeque$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Setcont

; 309  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::destroy<enum TextureType>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::destroy<enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@W4TextureType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@ABW43@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@W4TextureType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@ABW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABW4TextureType@@@std@@YAABW4TextureType@@ABW41@@Z ; std::forward<enum TextureType const &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@W4TextureType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@ABW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z PROC ; std::_Unfancy<enum TextureType>, COMDAT

; 345  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 346  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

	pop	ebp
	ret	0
??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ENDP ; std::_Unfancy<enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAW4TextureType@@@?$_Default_allocator_traits@V?$allocator@PAW4TextureType@@@std@@@std@@SAXAAV?$allocator@PAW4TextureType@@@1@QAPAW4TextureType@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAW4TextureType@@@?$_Default_allocator_traits@V?$allocator@PAW4TextureType@@@std@@@std@@SAXAAV?$allocator@PAW4TextureType@@@1@QAPAW4TextureType@@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum TextureType *> >::destroy<enum TextureType *>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@PAW4TextureType@@@?$_Default_allocator_traits@V?$allocator@PAW4TextureType@@@std@@@std@@SAXAAV?$allocator@PAW4TextureType@@@1@QAPAW4TextureType@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum TextureType *> >::destroy<enum TextureType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAW4TextureType@@@std@@YAPAPAW4TextureType@@AAPAW41@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAW4TextureType@@@std@@YAPAPAW4TextureType@@AAPAW41@@Z PROC ; std::addressof<enum TextureType *>, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@PAW4TextureType@@@std@@YAPAPAW4TextureType@@AAPAW41@@Z ENDP ; std::addressof<enum TextureType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z PROC ; std::allocator<enum TextureType *>::allocator<enum TextureType *><enum TextureType>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ENDP ; std::allocator<enum TextureType *>::allocator<enum TextureType *><enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@W4MeshType@@W41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@$$QAW43@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@W4MeshType@@W41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@$$QAW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@W4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ; std::forward<enum MeshType>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@W4MeshType@@W41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@$$QAW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEAAW4MeshType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEAAW4MeshType@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*, COMDAT
; _this$ = ecx

; 534  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEABW4MeshType@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*

; 536  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEAAW4MeshType@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >, COMDAT
; _this$ = ecx

; 530  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 		: _Mybase(_Off, _Pdeque)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >

; 531  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Setcont, COMDAT
; _this$ = ecx

; 457  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		this->_Adopt(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEABW4MeshType@@XZ
_TEXT	SEGMENT
__Off$ = -16						; size = 4
__Block$ = -12						; size = 4
_this$ = -8						; size = 4
__Mycont$ = -4						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEABW4MeshType@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*, COMDAT
; _this$ = ecx

; 312  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax
$LN4@operator:

; 314  :  #if _ITERATOR_DEBUG_LEVEL != 0
; 315  : 		_STL_VERIFY(_Mycont, "cannot dereference value-initialized deque iterator");

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0DE@MANMEIKC@cannot?5dereference?5value?9initia@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	315					; 0000013bH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN19@operator
	int	3
$LN19@operator:
	push	0
	push	315					; 0000013bH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1OA@EJNJGAHC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
	push	OFFSET ??_C@_1GM@HLAFMPGB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	edx, edx
	jne	SHORT $LN4@operator
$LN10@operator:

; 316  : 		_STL_VERIFY(_Mycont->_Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN13@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Mycont$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], ecx
	jae	SHORT $LN13@operator
	jmp	SHORT $LN8@operator
$LN13@operator:
	push	OFFSET ??_C@_0CN@IEPDPKI@cannot?5deference?5out?5of?5range?5d@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	318					; 0000013eH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN20@operator
	int	3
$LN20@operator:
	push	0
	push	318					; 0000013eH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1OA@EJNJGAHC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn@
	push	OFFSET ??_C@_1FO@KFELHBJF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn@
	call	__invalid_parameter
	add	esp, 20					; 00000014H

; 317  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize,
; 318  : 			"cannot deference out of range deque iterator");

	xor	edx, edx
	jne	SHORT $LN13@operator
$LN8@operator:
	xor	eax, eax
	jne	SHORT $LN10@operator

; 319  :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 320  : 
; 321  : 		_Size_type _Block = _Mycont->_Getblock(_Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR __Mycont$[ebp]
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax

; 322  : 		_Size_type _Off = _Myoff % _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	DWORD PTR __Off$[ebp], edx

; 323  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	edx, DWORD PTR __Mycont$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]

; 324  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEABW4MeshType@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >, COMDAT
; _this$ = ecx

; 307  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 306  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 308  : 		_Setcont((_Mydeque *)_Pdeque);

	mov	edx, DWORD PTR __Pdeque$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Setcont

; 309  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
__ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::destroy<enum MeshType>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::destroy<enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@W4MeshType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@ABW43@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@W4MeshType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@ABW43@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABW4MeshType@@@std@@YAABW4MeshType@@ABW41@@Z ; std::forward<enum MeshType const &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@W4MeshType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@ABW43@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z PROC ; std::_Unfancy<enum MeshType>, COMDAT

; 345  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 346  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

	pop	ebp
	ret	0
??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ENDP ; std::_Unfancy<enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAW4MeshType@@@?$_Default_allocator_traits@V?$allocator@PAW4MeshType@@@std@@@std@@SAXAAV?$allocator@PAW4MeshType@@@1@QAPAW4MeshType@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAW4MeshType@@@?$_Default_allocator_traits@V?$allocator@PAW4MeshType@@@std@@@std@@SAXAAV?$allocator@PAW4MeshType@@@1@QAPAW4MeshType@@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum MeshType *> >::destroy<enum MeshType *>, COMDAT

; 886  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	pop	ebp
	ret	0
??$destroy@PAW4MeshType@@@?$_Default_allocator_traits@V?$allocator@PAW4MeshType@@@std@@@std@@SAXAAV?$allocator@PAW4MeshType@@@1@QAPAW4MeshType@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum MeshType *> >::destroy<enum MeshType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAW4MeshType@@@std@@YAPAPAW4MeshType@@AAPAW41@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAW4MeshType@@@std@@YAPAPAW4MeshType@@AAPAW41@@Z PROC ; std::addressof<enum MeshType *>, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@PAW4MeshType@@@std@@YAPAPAW4MeshType@@AAPAW41@@Z ENDP ; std::addressof<enum MeshType *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z PROC ; std::allocator<enum MeshType *>::allocator<enum MeshType *><enum MeshType>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ENDP ; std::allocator<enum MeshType *>::allocator<enum MeshType *><enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
_TEXT	SEGMENT
$T2 = -72						; size = 8
$T3 = -64						; size = 8
__Ok$ = -56						; size = 8
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
tv185 = -36						; size = 4
tv182 = -32						; size = 4
tv65 = -28						; size = 4
__Err$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>, COMDAT
; _this$ = ecx

; 212  : 		{	// formatted extract with num_get

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		ios_base::iostate _Err = ios_base::goodbit;

	mov	DWORD PTR __Err$[ebp], 0

; 214  : 		const sentry _Ok(*this);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 215  : 
; 216  : 		if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@Common_ext

; 217  : 			{	// state okay, use facet to extract
; 218  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 219  : 			_STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv182[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR tv182[ebp]
	push	ecx
	call	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR tv185[ebp], eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR __Err$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	call	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@AAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR tv185[ebp]
	call	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	jmp	SHORT $LN5@Common_ext
__catch$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$0:

; 220  : 			_CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN10@Common_ext
	ret	0
$LN5@Common_ext:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN2@Common_ext
$LN10@Common_ext:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Common_ext:

; 221  : 			}
; 222  : 
; 223  : 		_Myios::setstate(_Err);

	push	0
	mov	eax, DWORD PTR __Err$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 224  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T6[ebp]

; 225  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 704  : 		{	// return true if any stores failed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 705  : 		return (_Failed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax]

; 706  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 694  : 		{	// pretend to preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 695  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 696  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 689  : 		{	// pretend to get designated element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 690  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 691  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 680  : 		{	// store element and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		if (_Strbuf == nullptr
; 682  : 			|| traits_type::eq_int_type(_Traits::eof(),

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@operator
	movzx	ecx, BYTE PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR $T2[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@operator
$LN3@operator:

; 683  : 				_Strbuf->sputc(_Right)))
; 684  : 			_Failed = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1
$LN2@operator:

; 685  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 686  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 671  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 670  : 		: _Failed(false), _Strbuf(_Sb)

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Sb$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 672  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1828 : 		{	// put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, esp

; 1829 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

	jmp	SHORT $LN4@Rep
$LN2@Rep:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
$LN4@Rep:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Rep

; 1830 : 			*_Dest = _Ch;

	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	jmp	SHORT $LN2@Rep
$LN3@Rep:

; 1831 : 		return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1832 : 		}

	pop	ebp
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1820 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp

; 1821 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

	jmp	SHORT $LN4@Put
$LN2@Put:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN4@Put:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@Put

; 1822 : 			*_Dest = *_Ptr;

	mov	edx, DWORD PTR __Ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	jmp	SHORT $LN2@Put
$LN3@Put:

; 1823 : 		return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1824 : 		}

	pop	ebp
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Grouping$ = -192					; size = 28
$T2 = -164						; size = 8
$T3 = -156						; size = 8
$T4 = -148						; size = 8
$T5 = -140						; size = 8
$T6 = -132						; size = 8
$T7 = -124						; size = 8
$T8 = -116						; size = 8
$T9 = -108						; size = 8
__Groupstring$ = -100					; size = 28
tv322 = -72						; size = 8
tv270 = -64						; size = 4
tv131 = -60						; size = 4
__Ctype_fac$ = -56					; size = 4
tv267 = -52						; size = 4
tv274 = -48						; size = 4
tv197 = -44						; size = 4
__Punct_fac$ = -40					; size = 4
tv69 = -36						; size = 4
__Adjustfield$ = -32					; size = 4
__Fillcount$ = -28					; size = 4
__Kseparator$10 = -21					; size = 1
__Pg$ = -20						; size = 4
__Prefix$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1761 : 		{	// put formatted integer to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 180				; 000000b4H

; 1762 : 		auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN14@Iput
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN13@Iput
	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN14@Iput
$LN13@Iput:
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN15@Iput
$LN14@Iput:
	mov	DWORD PTR tv69[ebp], 0
$LN15@Iput:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR __Prefix$[ebp], ecx

; 1763 : 		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
; 1764 : 			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1765 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 3584				; 00000e00H
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	mov	edx, DWORD PTR __Prefix$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN4@Iput
	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Prefix$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN4@Iput
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Prefix$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN5@Iput
	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Prefix$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1766 : 			{
; 1767 : 			_Prefix += 2;

	mov	eax, DWORD PTR __Prefix$[ebp]
	add	eax, 2
	mov	DWORD PTR __Prefix$[ebp], eax
$LN4@Iput:

; 1768 : 			}
; 1769 : 
; 1770 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv274[ebp], eax
	mov	edx, DWORD PTR tv274[ebp]
	mov	DWORD PTR tv267[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv267[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1771 : 		basic_string<_Elem> _Groupstring(_Count, _Elem(0));	// reserve space

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1772 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	add	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 1773 : 
; 1774 : 		const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv270[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv270[ebp]
	push	ecx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1775 : 		const string _Grouping = _Punct_fac.grouping();

	lea	edx, DWORD PTR __Grouping$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1776 : 		const char *_Pg = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$[ebp], eax

; 1777 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN6@Iput
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $LN6@Iput

; 1778 : 			{	// grouping specified, add thousands separators
; 1779 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR __Kseparator$10[ebp], al
$LN2@Iput:

; 1780 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1781 : 				&& (size_t)*_Pg < _Count - _Prefix)

	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	je	SHORT $LN6@Iput
	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	SHORT $LN6@Iput
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN6@Iput

; 1782 : 				{	// insert thousands separator
; 1783 : 				_Count -= *_Pg;

	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 1784 : 				_Groupstring.insert(_Count, 1, _Kseparator);

	movzx	edx, BYTE PTR __Kseparator$10[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1785 : 				if ('\0' < _Pg[1])

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jle	SHORT $LN7@Iput

; 1786 : 					++_Pg;	// not last group, advance

	mov	ecx, DWORD PTR __Pg$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Pg$[ebp], ecx
$LN7@Iput:

; 1787 : 				}

	jmp	SHORT $LN2@Iput
$LN6@Iput:

; 1788 : 			}
; 1789 : 
; 1790 : 		_Count = _Groupstring.size();

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Count$[ebp], eax

; 1791 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1792 : 			|| (size_t)_Iosbase.width() <= _Count

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv322[ebp], eax
	mov	DWORD PTR tv322[ebp+4], edx
	cmp	DWORD PTR tv322[ebp+4], 0
	jl	SHORT $LN16@Iput
	jg	SHORT $LN22@Iput
	cmp	DWORD PTR tv322[ebp], 0
	jbe	SHORT $LN16@Iput
$LN22@Iput:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN16@Iput
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN17@Iput
$LN16@Iput:
	mov	DWORD PTR tv197[ebp], 0
$LN17@Iput:
	mov	edx, DWORD PTR tv197[ebp]
	mov	DWORD PTR __Fillcount$[ebp], edx

; 1793 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1794 : 
; 1795 : 		ios_base::fmtflags _Adjustfield =
; 1796 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1797 : 		if (_Adjustfield != ios_base::left
; 1798 : 			&& _Adjustfield != ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	SHORT $LN8@Iput
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $LN8@Iput

; 1799 : 			{	// put leading fill
; 1800 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1801 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1802 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	$LN9@Iput
$LN8@Iput:

; 1803 : 			}
; 1804 : 		else if (_Adjustfield == ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $LN10@Iput

; 1805 : 			{	// put internal fill
; 1806 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1807 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1808 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1809 : 			}
; 1810 : 		else

	jmp	SHORT $LN9@Iput
$LN10@Iput:

; 1811 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
$LN9@Iput:

; 1812 : 
; 1813 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prefix$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1814 : 		_Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1815 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1816 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
__Basefield$ = -12					; size = 4
__Ptr$ = -8						; size = 4
tv91 = -3						; size = 1
tv90 = -2						; size = 1
tv89 = -1						; size = 1
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1733 : 		{	// generate sprintf format for integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1734 : 		char *_Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1735 : 		*_Ptr++ = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1736 : 
; 1737 : 		if (_Flags & ios_base::showpos)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@Ifmt

; 1738 : 			*_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN2@Ifmt:

; 1739 : 		if (_Flags & ios_base::showbase)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 8
	je	SHORT $LN3@Ifmt

; 1740 : 			*_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN3@Ifmt:

; 1741 : 		if (_Spec[0] != 'L')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR __Spec$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1742 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Spec$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1743 : 		else

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1744 : 
; 1745 : 			{	/* change L to I64 */
; 1746 : 			*_Ptr++ = 'I';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 73			; 00000049H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1747 : 			*_Ptr++ = '6';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 54			; 00000036H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1748 : 			*_Ptr++ = '4';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 52			; 00000034H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax
$LN5@Ifmt:

; 1749 : 			}
; 1750 : 
; 1751 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	ecx, DWORD PTR __Flags$[ebp]
	and	ecx, 3584				; 00000e00H
	mov	DWORD PTR __Basefield$[ebp], ecx

; 1752 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

	cmp	DWORD PTR __Basefield$[ebp], 1024	; 00000400H
	jne	SHORT $LN11@Ifmt
	mov	BYTE PTR tv91[ebp], 111			; 0000006fH
	jmp	SHORT $LN12@Ifmt
$LN11@Ifmt:
	cmp	DWORD PTR __Basefield$[ebp], 2048	; 00000800H
	je	SHORT $LN9@Ifmt
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR __Spec$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv90[ebp], cl
	jmp	SHORT $LN10@Ifmt
$LN9@Ifmt:
	mov	edx, DWORD PTR __Flags$[ebp]
	and	edx, 4
	je	SHORT $LN7@Ifmt
	mov	BYTE PTR tv89[ebp], 88			; 00000058H
	jmp	SHORT $LN8@Ifmt
$LN7@Ifmt:
	mov	BYTE PTR tv89[ebp], 120			; 00000078H
$LN8@Ifmt:
	mov	al, BYTE PTR tv89[ebp]
	mov	BYTE PTR tv90[ebp], al
$LN10@Ifmt:
	mov	cl, BYTE PTR tv90[ebp]
	mov	BYTE PTR tv91[ebp], cl
$LN12@Ifmt:
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR tv91[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1753 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1754 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1755 : 		*_Ptr = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 1756 : 		return (_Fmt);

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1757 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
__Grouping$ = -216					; size = 28
$T2 = -188						; size = 8
$T3 = -180						; size = 8
$T4 = -172						; size = 8
$T5 = -164						; size = 8
$T6 = -156						; size = 8
$T7 = -148						; size = 8
$T8 = -140						; size = 8
$T9 = -132						; size = 8
__Groupstring$ = -124					; size = 28
tv399 = -96						; size = 8
__Eoff$ = -88						; size = 4
tv297 = -84						; size = 4
tv154 = -80						; size = 4
__Ctype_fac$ = -76					; size = 4
tv294 = -72						; size = 4
tv301 = -68						; size = 4
tv224 = -64						; size = 4
tv189 = -60						; size = 4
__Exps$ = -56						; size = 4
tv69 = -52						; size = 4
__Adjustfield$ = -48					; size = 4
__Punct_fac$ = -44					; size = 4
__Off$ = -40						; size = 4
__Poff$ = -36						; size = 4
__Fillcount$ = -32					; size = 4
__Dp$ = -28						; size = 2
__Pg$ = -24						; size = 4
__Kseparator$ = -17					; size = 1
__Prefix$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1663 : 		{	// put formatted floating-point to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 204				; 000000ccH
	push	ebx

; 1664 : 		auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN16@Fput
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN15@Fput
	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN16@Fput
$LN15@Fput:
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN17@Fput
$LN16@Fput:
	mov	DWORD PTR tv69[ebp], 0
$LN17@Fput:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR __Prefix$[ebp], ecx

; 1665 : 		const char *_Exps;
; 1666 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput

; 1667 : 			_Exps = "eE";

	mov	DWORD PTR __Exps$[ebp], OFFSET ??_C@_02MDKMJEGG@eE@

; 1668 : 		else

	jmp	SHORT $LN5@Fput
$LN4@Fput:

; 1669 : 			{	// correct for hexadecimal floating-point
; 1670 : 			_Exps = "pP";

	mov	DWORD PTR __Exps$[ebp], OFFSET ??_C@_02OOPEBDOJ@pP@

; 1671 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1672 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	mov	edx, DWORD PTR __Prefix$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN5@Fput
	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Prefix$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN5@Fput
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Prefix$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN7@Fput
	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Prefix$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 88					; 00000058H
	jne	SHORT $LN5@Fput
$LN7@Fput:

; 1673 : 				_Prefix += 2;

	mov	eax, DWORD PTR __Prefix$[ebp]
	add	eax, 2
	mov	DWORD PTR __Prefix$[ebp], eax
$LN5@Fput:

; 1674 : 			}
; 1675 : 		const size_t _Eoff =
; 1676 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

	mov	ecx, DWORD PTR __Exps$[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_strcspn
	add	esp, 8
	mov	DWORD PTR __Eoff$[ebp], eax

; 1677 : 		char _Dp[2] = {"."};

	mov	cx, WORD PTR ??_C@_01LFCBOECM@?4@
	mov	WORD PTR __Dp$[ebp], cx

; 1678 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

	call	_localeconv
	mov	edx, 1
	imul	ecx, edx, 0
	mov	edx, DWORD PTR [eax]
	mov	eax, 1
	imul	eax, eax, 0
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Dp$[ebp+eax], cl

; 1679 : 		const size_t _Poff =
; 1680 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR __Dp$[ebp+eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	add	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_strcspn
	add	esp, 8
	mov	DWORD PTR __Poff$[ebp], eax

; 1681 : 
; 1682 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv301[ebp], eax
	mov	edx, DWORD PTR tv301[ebp]
	mov	DWORD PTR tv294[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv294[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1683 : 		basic_string<_Elem> _Groupstring(_Count, _Elem(0));	// reserve space

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1684 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Buf$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	add	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z	; std::ctype<char>::widen

; 1685 : 
; 1686 : 		const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv154[ebp], eax
	mov	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv297[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv297[ebp]
	push	ecx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1687 : 		const string _Grouping = _Punct_fac.grouping();

	lea	edx, DWORD PTR __Grouping$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1688 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR __Kseparator$[ebp], al

; 1689 : 
; 1690 : 		if (_Poff != _Count)

	mov	eax, DWORD PTR __Poff$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	je	SHORT $LN8@Fput

; 1691 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	mov	bl, al
	mov	ecx, DWORD PTR __Poff$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	BYTE PTR [eax], bl
$LN8@Fput:

; 1692 : 
; 1693 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

	mov	edx, DWORD PTR __Poff$[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jne	SHORT $LN18@Fput
	mov	eax, DWORD PTR __Eoff$[ebp]
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN19@Fput
$LN18@Fput:
	mov	ecx, DWORD PTR __Poff$[ebp]
	mov	DWORD PTR tv189[ebp], ecx
$LN19@Fput:
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 1694 : 		const char *_Pg = &_Grouping[0];

	push	0
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Pg$[ebp], eax
$LN2@Fput:

; 1695 : 		while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1696 : 			&& (size_t)*_Pg < _Off - _Prefix)

	mov	eax, DWORD PTR __Pg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $LN3@Fput
	mov	edx, DWORD PTR __Pg$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $LN3@Fput
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$[ebp]
	sub	eax, DWORD PTR __Prefix$[ebp]
	cmp	edx, eax
	jae	SHORT $LN3@Fput

; 1697 : 			{	// add thousands separator
; 1698 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Off$[ebp], eax
	movzx	ecx, BYTE PTR __Kseparator$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1699 : 			if ('\0' < _Pg[1])

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR __Pg$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jle	SHORT $LN9@Fput

; 1700 : 				++_Pg;	// not last group, advance

	mov	eax, DWORD PTR __Pg$[ebp]
	add	eax, 1
	mov	DWORD PTR __Pg$[ebp], eax
$LN9@Fput:

; 1701 : 			}

	jmp	SHORT $LN2@Fput
$LN3@Fput:

; 1702 : 
; 1703 : 		_Count = _Groupstring.size();

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Count$[ebp], eax

; 1704 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1705 : 			|| (size_t)_Iosbase.width() <= _Count

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv399[ebp], eax
	mov	DWORD PTR tv399[ebp+4], edx
	cmp	DWORD PTR tv399[ebp+4], 0
	jl	SHORT $LN20@Fput
	jg	SHORT $LN26@Fput
	cmp	DWORD PTR tv399[ebp], 0
	jbe	SHORT $LN20@Fput
$LN26@Fput:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN20@Fput
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN21@Fput
$LN20@Fput:
	mov	DWORD PTR tv224[ebp], 0
$LN21@Fput:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	DWORD PTR __Fillcount$[ebp], ecx

; 1706 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1707 : 
; 1708 : 		ios_base::fmtflags _Adjustfield =
; 1709 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1710 : 		if (_Adjustfield != ios_base::left
; 1711 : 			&& _Adjustfield != ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	SHORT $LN10@Fput
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $LN10@Fput

; 1712 : 			{	// put leading fill
; 1713 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Fillcount$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 1714 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1715 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx
	jmp	$LN11@Fput
$LN10@Fput:

; 1716 : 			}
; 1717 : 		else if (_Adjustfield == ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $LN12@Fput

; 1718 : 			{	// put internal fill
; 1719 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 1720 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1721 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1722 : 			}
; 1723 : 		else

	jmp	SHORT $LN11@Fput
$LN12@Fput:

; 1724 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
$LN11@Fput:

; 1725 : 
; 1726 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prefix$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1727 : 		_Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1728 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1729 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
__Ffl$ = -16						; size = 4
__Ptr$ = -12						; size = 4
tv92 = -6						; size = 1
tv91 = -5						; size = 1
tv90 = -4						; size = 1
tv85 = -3						; size = 1
tv84 = -2						; size = 1
tv83 = -1						; size = 1
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1633 : 		{	// generate sprintf format for floating-point

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1634 : 		char *_Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1635 : 		*_Ptr++ = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1636 : 
; 1637 : 		if (_Flags & ios_base::showpos)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@Ffmt

; 1638 : 			*_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN2@Ffmt:

; 1639 : 		if (_Flags & ios_base::showpoint)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN3@Ffmt

; 1640 : 			*_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$LN3@Ffmt:

; 1641 : 		*_Ptr++ = '.';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1642 : 		*_Ptr++ = '*';	// for precision argument

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 42			; 0000002aH
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1643 : 		if (_Spec != '\0')

	movsx	ecx, BYTE PTR __Spec$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@Ffmt

; 1644 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR __Spec$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN4@Ffmt:

; 1645 : 
; 1646 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	edx, DWORD PTR __Flags$[ebp]
	and	edx, 12288				; 00003000H
	mov	DWORD PTR __Ffl$[ebp], edx

; 1647 : 		if (_Flags & ios_base::uppercase)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 4
	je	SHORT $LN5@Ffmt

; 1648 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	DWORD PTR __Ffl$[ebp], 8192		; 00002000H
	jne	SHORT $LN12@Ffmt
	mov	BYTE PTR tv85[ebp], 102			; 00000066H
	jmp	SHORT $LN13@Ffmt
$LN12@Ffmt:
	cmp	DWORD PTR __Ffl$[ebp], 12288		; 00003000H
	jne	SHORT $LN10@Ffmt
	mov	BYTE PTR tv84[ebp], 65			; 00000041H
	jmp	SHORT $LN11@Ffmt
$LN10@Ffmt:
	cmp	DWORD PTR __Ffl$[ebp], 4096		; 00001000H
	jne	SHORT $LN8@Ffmt
	mov	BYTE PTR tv83[ebp], 69			; 00000045H
	jmp	SHORT $LN9@Ffmt
$LN8@Ffmt:
	mov	BYTE PTR tv83[ebp], 71			; 00000047H
$LN9@Ffmt:
	mov	cl, BYTE PTR tv83[ebp]
	mov	BYTE PTR tv84[ebp], cl
$LN11@Ffmt:
	mov	dl, BYTE PTR tv84[ebp]
	mov	BYTE PTR tv85[ebp], dl
$LN13@Ffmt:
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	cl, BYTE PTR tv85[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1649 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1650 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1651 : 		else

	jmp	SHORT $LN6@Ffmt
$LN5@Ffmt:

; 1652 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	DWORD PTR __Ffl$[ebp], 8192		; 00002000H
	jne	SHORT $LN18@Ffmt
	mov	BYTE PTR tv92[ebp], 102			; 00000066H
	jmp	SHORT $LN19@Ffmt
$LN18@Ffmt:
	cmp	DWORD PTR __Ffl$[ebp], 12288		; 00003000H
	jne	SHORT $LN16@Ffmt
	mov	BYTE PTR tv91[ebp], 97			; 00000061H
	jmp	SHORT $LN17@Ffmt
$LN16@Ffmt:
	cmp	DWORD PTR __Ffl$[ebp], 4096		; 00001000H
	jne	SHORT $LN14@Ffmt
	mov	BYTE PTR tv90[ebp], 101			; 00000065H
	jmp	SHORT $LN15@Ffmt
$LN14@Ffmt:
	mov	BYTE PTR tv90[ebp], 103			; 00000067H
$LN15@Ffmt:
	mov	al, BYTE PTR tv90[ebp]
	mov	BYTE PTR tv91[ebp], al
$LN17@Ffmt:
	mov	cl, BYTE PTR tv91[ebp]
	mov	BYTE PTR tv92[ebp], cl
$LN19@Ffmt:
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR tv92[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$LN6@Ffmt:

; 1653 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1654 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1655 : 
; 1656 : 		*_Ptr = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 1657 : 		return (_Fmt);

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1658 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1623 : 		{	// put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1624 : 		char _Buf[2 * _MAX_INT_DIG];
; 1625 : 
; 1626 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp@
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1627 : 			static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val))));
; 1628 : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Buf$ = -104						; size = 28
__Fmt$ = -76						; size = 8
tv184 = -68						; size = 8
__Precision$ = -60					; size = 8
tv166 = -52						; size = 8
tv80 = -44						; size = 8
__Ngen$ = -36						; size = 4
__Ptwo$2 = -32						; size = 4
_this$ = -28						; size = 4
tv71 = -24						; size = 4
__Bufsize$ = -20					; size = 4
__Isfixed$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1599 : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1600 : 		string _Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1601 : 		char _Fmt[8];
; 1602 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1603 : 			== ios_base::fixed;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN4@do_put
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	DWORD PTR tv71[ebp], 0
$LN5@do_put:
	mov	al, BYTE PTR tv71[ebp]
	mov	BYTE PTR __Isfixed$[ebp], al

; 1604 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv166[ebp], eax
	mov	DWORD PTR tv166[ebp+4], edx
	cmp	DWORD PTR tv166[ebp+4], 0
	jg	SHORT $LN6@do_put
	jl	SHORT $LN9@do_put
	cmp	DWORD PTR tv166[ebp], 0
	ja	SHORT $LN6@do_put
$LN9@do_put:
	movzx	ecx, BYTE PTR __Isfixed$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@do_put
	mov	DWORD PTR tv80[ebp], 6
	mov	DWORD PTR tv80[ebp+4], 0
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv80[ebp], eax
	mov	DWORD PTR tv80[ebp+4], edx
$LN7@do_put:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR __Precision$[ebp], edx
	mov	eax, DWORD PTR tv80[ebp+4]
	mov	DWORD PTR __Precision$[ebp+4], eax

; 1605 : 			? 6 : _Iosbase.precision();	// desired precision
; 1606 : 		size_t _Bufsize = (size_t)_Precision;

	mov	ecx, DWORD PTR __Precision$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], ecx

; 1607 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

	movzx	edx, BYTE PTR __Isfixed$[ebp]
	test	edx, edx
	je	SHORT $LN2@do_put
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabsl
	add	esp, 8
	fstp	QWORD PTR tv184[ebp]
	movsd	xmm0, QWORD PTR tv184[ebp]
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1608 : 			{	// f or F format
; 1609 : 			int _Ptwo;
; 1610 : 			(void)_CSTD frexpl(_Val, &_Ptwo);

	lea	eax, DWORD PTR __Ptwo$2[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexpl
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 1611 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	ecx, DWORD PTR __Ptwo$2[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	imul	eax, eax, 30103
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	add	eax, DWORD PTR __Bufsize$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1612 : 			}
; 1613 : 
; 1614 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

	push	0
	mov	edx, DWORD PTR __Bufsize$[ebp]
	add	edx, 50					; 00000032H
	push	edx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1615 : 		const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR __Precision$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	76					; 0000004cH
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Ngen$[ebp], eax

; 1616 : 			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val));
; 1617 : 
; 1618 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	eax, DWORD PTR __Ngen$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	add	esp, 32					; 00000020H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1619 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Buf$ = -104						; size = 28
__Fmt$ = -76						; size = 8
tv184 = -68						; size = 8
__Precision$ = -60					; size = 8
tv166 = -52						; size = 8
tv80 = -44						; size = 8
__Ngen$ = -36						; size = 4
__Ptwo$2 = -32						; size = 4
_this$ = -28						; size = 4
tv71 = -24						; size = 4
__Bufsize$ = -20					; size = 4
__Isfixed$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1575 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1576 : 		string _Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1577 : 		char _Fmt[8];
; 1578 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1579 : 			== ios_base::fixed;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN4@do_put
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	DWORD PTR tv71[ebp], 0
$LN5@do_put:
	mov	al, BYTE PTR tv71[ebp]
	mov	BYTE PTR __Isfixed$[ebp], al

; 1580 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv166[ebp], eax
	mov	DWORD PTR tv166[ebp+4], edx
	cmp	DWORD PTR tv166[ebp+4], 0
	jg	SHORT $LN6@do_put
	jl	SHORT $LN9@do_put
	cmp	DWORD PTR tv166[ebp], 0
	ja	SHORT $LN6@do_put
$LN9@do_put:
	movzx	ecx, BYTE PTR __Isfixed$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@do_put
	mov	DWORD PTR tv80[ebp], 6
	mov	DWORD PTR tv80[ebp+4], 0
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBE_JXZ	; std::ios_base::precision
	mov	DWORD PTR tv80[ebp], eax
	mov	DWORD PTR tv80[ebp+4], edx
$LN7@do_put:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR __Precision$[ebp], edx
	mov	eax, DWORD PTR tv80[ebp+4]
	mov	DWORD PTR __Precision$[ebp+4], eax

; 1581 : 			? 6 : _Iosbase.precision();	// desired precision
; 1582 : 		size_t _Bufsize = (size_t)_Precision;

	mov	ecx, DWORD PTR __Precision$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], ecx

; 1583 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

	movzx	edx, BYTE PTR __Isfixed$[ebp]
	test	edx, edx
	je	SHORT $LN2@do_put
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv184[ebp]
	movsd	xmm0, QWORD PTR tv184[ebp]
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1584 : 			{	// f or F format
; 1585 : 			int _Ptwo;
; 1586 : 			(void)_CSTD frexp(_Val, &_Ptwo);

	lea	eax, DWORD PTR __Ptwo$2[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	fstp	ST(0)
	add	esp, 12					; 0000000cH

; 1587 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	ecx, DWORD PTR __Ptwo$2[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	imul	eax, eax, 30103
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	add	eax, DWORD PTR __Bufsize$[ebp]
	mov	DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1588 : 			}
; 1589 : 
; 1590 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

	push	0
	mov	edx, DWORD PTR __Bufsize$[ebp]
	add	edx, 50					; 00000032H
	push	edx
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1591 : 		const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR __Precision$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	0
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_sprintf_s
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Ngen$[ebp], eax

; 1592 : 			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val));
; 1593 : 
; 1594 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	eax, DWORD PTR __Ngen$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	add	esp, 32					; 00000020H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Buf$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1595 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1565 : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1567 : 
; 1568 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02CLHGNPPK@Lu@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1569 : 			static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1570 : 				_Iosbase.flags()), _Val))));
; 1571 : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1555 : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1556 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1557 : 
; 1558 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02HIKPPMOK@Ld@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1559 : 			static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1560 : 				_Iosbase.flags()), _Val))));
; 1561 : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1545 : 		{	// put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1546 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1547 : 
; 1548 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02BDDLJJBK@lu@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1549 : 			static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1550 : 				_Iosbase.flags()), _Val))));
; 1551 : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1535 : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1537 : 
; 1538 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET ??_C@_02EAOCLKAK@ld@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	push	64					; 00000040H
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf_s
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1539 : 			static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1540 : 				_Iosbase.flags()), _Val))));
; 1541 : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T2 = -160						; size = 28
$T3 = -132						; size = 28
$T4 = -104						; size = 8
$T5 = -96						; size = 8
$T6 = -88						; size = 8
__Str$7 = -80						; size = 28
tv220 = -52						; size = 8
tv186 = -44						; size = 4
tv184 = -40						; size = 4
tv181 = -36						; size = 4
tv188 = -32						; size = 4
tv150 = -28						; size = 4
__Punct_fac$8 = -24					; size = 4
__Fillcount$9 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1506 : 		{	// put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1507 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	jne	SHORT $LN2@do_put

; 1508 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

	movzx	eax, BYTE PTR __Val$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN1@do_put

; 1509 : 		else

	jmp	$LN1@do_put
$LN2@do_put:

; 1510 : 			{	// put "false" or "true"
; 1511 : 			const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv188[ebp], eax
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv181[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv181[ebp]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1512 : 			basic_string<_Elem> _Str;

	lea	ecx, DWORD PTR __Str$7[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1513 : 			if (_Val)

	movzx	ecx, BYTE PTR __Val$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@do_put

; 1514 : 				_Str.assign(_Punct_fac.truename());

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR __Punct_fac$8[ebp]
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	DWORD PTR tv184[ebp], eax
	mov	eax, DWORD PTR tv184[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1515 : 			else

	jmp	SHORT $LN5@do_put
$LN4@do_put:

; 1516 : 				_Str.assign(_Punct_fac.falsename());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$8[ebp]
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	DWORD PTR tv186[ebp], eax
	mov	edx, DWORD PTR tv186[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@do_put:

; 1517 : 
; 1518 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1519 : 				|| (size_t)_Iosbase.width() <= _Str.size()

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv220[ebp], eax
	mov	DWORD PTR tv220[ebp+4], edx
	cmp	DWORD PTR tv220[ebp+4], 0
	jl	SHORT $LN8@do_put
	jg	SHORT $LN14@do_put
	cmp	DWORD PTR tv220[ebp], 0
	jbe	SHORT $LN8@do_put
$LN14@do_put:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	esi, eax
	jbe	SHORT $LN8@do_put
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	esi, eax
	mov	DWORD PTR tv150[ebp], esi
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	mov	DWORD PTR tv150[ebp], 0
$LN9@do_put:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR __Fillcount$9[ebp], eax

; 1520 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1521 : 
; 1522 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN6@do_put

; 1523 : 				{	// put leading fill
; 1524 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1525 : 				_Fillcount = 0;

	mov	DWORD PTR __Fillcount$9[ebp], 0
$LN6@do_put:

; 1526 : 				}
; 1527 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1528 : 			_Iosbase.width(0);

	push	0
	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 1529 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, DWORD PTR __Fillcount$9[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@do_put:

; 1530 : 			}
; 1531 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1487 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1488 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1489 : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1448 : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		: locale::facet(_Refs)

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1448 : 		{	// construct from specified locale

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1449 : 		_Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init

; 1450 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1434 : 		{	// initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1435 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1430 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1431 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv94 = -32						; size = 4
tv131 = -28						; size = 4
tv88 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1419 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR $T5[ebp], 0

; 1420 : 		if (_Ppf != nullptr && *_Ppf == nullptr)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN2@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@Getcat

; 1421 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	push	8
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?c_str@locale@std@@QBEPBDXZ		; std::locale::c_str
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	and	ecx, 1
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 1422 : 				_Locinfo(_Ploc->c_str()));
; 1423 : 		return (_X_NUMERIC);

	mov	eax, 4

; 1424 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 12
$T3 = -40						; size = 4
__Lock$4 = -36						; size = 4
__Id$5 = -32						; size = 4
__Psave_guard$6 = -28					; size = 4
__Pf$7 = -24						; size = 4
__Pfmod$8 = -20						; size = 4
__Psave$9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 505  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$9[ebp], eax

; 509  : 
; 510  : 		const size_t _Id = _Facet::id;

	mov	ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$5[ebp], eax

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$7[ebp], eax

; 512  : 
; 513  : 		if (_Pf == nullptr)

	cmp	DWORD PTR __Pf$7[ebp], 0
	jne	$LN2@use_facet

; 514  : 			{
; 515  : 			if (_Psave != nullptr)

	cmp	DWORD PTR __Psave$9[ebp], 0
	je	SHORT $LN3@use_facet

; 516  : 				{
; 517  : 				_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 518  : 				}
; 519  : 			else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$9[ebp]
	push	ecx
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 520  : 				{
; 521  :  #if _HAS_EXCEPTIONS
; 522  : 				_THROW(bad_cast{});	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 				abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 				}
; 527  : 			else

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 528  : 				{	// queue up lazy facet for destruction
; 529  : 				auto _Pfmod = const_cast<locale::facet *>(_Psave);

	mov	eax, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pfmod$8[ebp], eax

; 530  : 				unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base *>(_Pfmod));

	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 531  : 
; 532  :  #if defined(_M_CEE)
; 533  : 				_Facet_Register_m(_Pfmod);
; 534  :  #else /* defined(_M_CEE) */
; 535  : 				_Facet_Register(_Pfmod);

	mov	edx, DWORD PTR __Pfmod$8[ebp]
	push	edx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 536  :  #endif /* defined(_M_CEE) */
; 537  : 
; 538  : 				_Pfmod->_Incref();

	mov	eax, DWORD PTR __Pfmod$8[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 539  : 				_Facetptr<_Facet>::_Psave = _Psave;

	mov	ecx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 540  : 				_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx

; 541  : 
; 542  : 				(void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 543  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 544  : 			}
; 545  : 
; 546  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	mov	eax, DWORD PTR __Pf$7[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T3[ebp]
$LN7@use_facet:

; 547  : 	_END_LOCK()
; 548  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$4[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 152  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 154  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 135  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@sentry

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN1@sentry:

; 140  : 				}
; 141  :  #else /* _HAS_EXCEPTIONS */
; 142  : 			this->_Myostr._Osfx();
; 143  :  #endif /* _HAS_EXCEPTIONS */
; 144  : 			}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 121  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 			: _Sentry_base(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 			if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	cmp	eax, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN2@sentry

; 123  : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN2@sentry:

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 125  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -28						; size = 4
tv86 = -24						; size = 4
_this$ = -20						; size = 4
tv72 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			if (_Myostr.rdbuf() != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $LN3@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR tv86[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv92[ebp], eax
	mov	eax, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN3@Sentry_bas:

; 108  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv87 = -12						; size = 4
tv73 = -8						; size = 4
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			: _Myostr(_Ostr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 100  : 			if (_Myostr.rdbuf() != nullptr)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN1@Sentry_bas:

; 102  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1943 : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	add	esp, 4
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1944 : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 1945 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

	pop	ebp
	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 345  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 346  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$assign@PAPAVSTTriangleMesh@@X@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEXPAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PAPAVSTTriangleMesh@@X@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEXPAPAVSTTriangleMesh@@0@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::assign<STTriangleMesh * *,void>, COMDAT
; _this$ = ecx

; 1388 : 		{	// assign [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1389 : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PAPAVSTTriangleMesh@@PAPAV1@@std@@YAXABQAPAVSTTriangleMesh@@0@Z ; std::_Adl_verify_range<STTriangleMesh * *,STTriangleMesh * *>
	add	esp, 8

; 1390 : 		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Get_unwrapped<STTriangleMesh *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Get_unwrapped@PAVSTTriangleMesh@@@std@@YAPAPAVSTTriangleMesh@@QAPAV1@@Z ; std::_Get_unwrapped<STTriangleMesh *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Assign_range@PAPAVSTTriangleMesh@@@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0Uforward_iterator_tag@1@@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Assign_range<STTriangleMesh * *>

; 1391 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$assign@PAPAVSTTriangleMesh@@X@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEXPAPAVSTTriangleMesh@@0@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::assign<STTriangleMesh * *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> > const >, COMDAT

; 329  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 331  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z PROC ; std::move<enum TextureType &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

	pop	ebp
	ret	0
??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ENDP ; std::move<enum TextureType &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z PROC ; std::move<enum MeshType &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

	pop	ebp
	ret	0
??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ENDP ; std::move<enum MeshType &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
__Ans$ = -44						; size = 28
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4049 : 	{	// return string + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR $T2[ebp], 0

; 4050 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4051 : 	_Ans.reserve(_Left.size() + _Right.size());

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 4052 : 	_Ans += _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4053 : 	_Ans += _Right;

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 4054 : 	return (_Ans);

	lea	edx, DWORD PTR __Ans$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Ans$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4055 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z$0:
	lea	ecx, DWORD PTR __Ans$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 142  : 	{	// extract a string

	push	ebp
	mov	ebp, esp

; 143  : 	return (_STD move(_Istr) >> _Str);

	mov	eax, DWORD PTR __Str$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Istr$[ebp]
	push	ecx
	call	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
	add	esp, 4
	push	eax
	call	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 144  : 	}

	pop	ebp
	ret	0
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T2 = -112						; size = 8
__Ok$ = -104						; size = 8
tv257 = -96						; size = 8
tv256 = -88						; size = 8
tv255 = -80						; size = 8
$T3 = -72						; size = 4
__Ctype_fac$4 = -68					; size = 4
$T5 = -64						; size = 4
tv261 = -60						; size = 4
tv260 = -56						; size = 4
tv259 = -52						; size = 4
tv258 = -48						; size = 4
tv252 = -44						; size = 4
tv65 = -40						; size = 4
tv164 = -36						; size = 4
__Size$6 = -32						; size = 4
__Meta$7 = -28						; size = 4
__State$ = -24						; size = 4
tv262 = -18						; size = 1
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 28   : 	{	// extract a string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 29   : 	typedef ctype<_Elem> _Ctype;
; 30   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 31   : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 32   : 	typedef typename _Mystr::size_type _Mysizt;
; 33   : 
; 34   : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 35   : 	bool _Changed = false;

	mov	BYTE PTR __Changed$[ebp], 0

; 36   : 	const typename _Myis::sentry _Ok(_Istr);

	push	0
	mov	eax, DWORD PTR __Istr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 37   : 
; 38   : 	if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@operator

; 39   : 		{	// state okay, extract characters
; 40   : 		const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv252[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR tv252[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 41   : 		_Str.erase();

	push	0
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 42   : 
; 43   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 44   : 		_Mysizt _Size = 0 < _Istr.width()
; 45   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Istr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv255[ebp], eax
	mov	DWORD PTR tv255[ebp+4], edx
	cmp	DWORD PTR tv255[ebp+4], 0
	jl	SHORT $LN13@operator
	jg	SHORT $LN21@operator
	cmp	DWORD PTR tv255[ebp], 0
	jbe	SHORT $LN13@operator
$LN21@operator:
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Istr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv256[ebp], eax
	mov	DWORD PTR tv256[ebp+4], edx
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR tv256[ebp], eax
	jae	SHORT $LN13@operator
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv257[ebp], eax
	mov	DWORD PTR tv257[ebp+4], edx
	mov	eax, DWORD PTR tv257[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN14@operator
$LN13@operator:
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR tv164[ebp], eax
$LN14@operator:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR __Size$6[ebp], ecx

; 46   : 				? (_Mysizt)_Istr.width() : _Str.max_size();
; 47   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Istr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv258[ebp], eax
	mov	ecx, DWORD PTR tv258[ebp]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv259[ebp], eax
	mov	ecx, DWORD PTR tv259[ebp]
	mov	DWORD PTR __Meta$7[ebp], ecx

; 48   : 
; 49   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	edx, DWORD PTR __Size$6[ebp]
	sub	edx, 1
	mov	DWORD PTR __Size$6[ebp], edx
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv260[ebp], eax
	mov	ecx, DWORD PTR tv260[ebp]
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	mov	DWORD PTR tv261[ebp], eax
	mov	eax, DWORD PTR tv261[ebp]
	mov	DWORD PTR __Meta$7[ebp], eax
$LN4@operator:
	cmp	DWORD PTR __Size$6[ebp], 0
	jbe	SHORT $LN3@operator

; 50   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	ecx, DWORD PTR __Meta$7[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@operator

; 51   : 				{	// end of file, quit
; 52   : 				_State |= ios_base::eofbit;

	mov	ecx, DWORD PTR __State$[ebp]
	or	ecx, 1
	mov	DWORD PTR __State$[ebp], ecx

; 53   : 				break;

	jmp	SHORT $LN3@operator
	jmp	SHORT $LN8@operator
$LN7@operator:

; 54   : 				}
; 55   : 			else if (_Ctype_fac.is(_Ctype::space,

	lea	edx, DWORD PTR __Meta$7[ebp]
	push	edx
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	movzx	eax, al
	push	eax
	push	72					; 00000048H
	mov	ecx, DWORD PTR __Ctype_fac$4[ebp]
	call	?is@?$ctype@D@std@@QBE_NFD@Z		; std::ctype<char>::is
	mov	BYTE PTR tv262[ebp], al
	movzx	ecx, BYTE PTR tv262[ebp]
	test	ecx, ecx
	je	SHORT $LN9@operator

; 56   : 				_Traits::to_char_type(_Meta)))
; 57   : 				break;	// whitespace, quit

	jmp	SHORT $LN3@operator

; 58   : 			else

	jmp	SHORT $LN8@operator
$LN9@operator:

; 59   : 				{	// add character to string
; 60   : 				_Str.push_back(_Traits::to_char_type(_Meta));

	lea	edx, DWORD PTR __Meta$7[ebp]
	push	edx
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 61   : 				_Changed = true;

	mov	BYTE PTR __Changed$[ebp], 1
$LN8@operator:

; 62   : 				}

	jmp	$LN2@operator
$LN3@operator:
	jmp	SHORT $LN15@operator
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 63   : 		_CATCH_IO_(_Istr)

	push	1
	push	4
	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Istr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN20@operator
	ret	0
$LN15@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@operator
$LN20@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN5@operator:

; 64   : 		}
; 65   : 
; 66   : 	_Istr.width(0);

	push	0
	push	0
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width

; 67   : 	if (!_Changed)

	movzx	eax, BYTE PTR __Changed$[ebp]
	test	eax, eax
	jne	SHORT $LN11@operator

; 68   : 		_State |= ios_base::failbit;

	mov	ecx, DWORD PTR __State$[ebp]
	or	ecx, 2
	mov	DWORD PTR __State$[ebp], ecx
$LN11@operator:

; 69   : 	_Istr.setstate(_State);

	push	0
	mov	edx, DWORD PTR __State$[ebp]
	push	edx
	mov	eax, DWORD PTR __Istr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Istr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 70   : 	return (_Istr);

	mov	eax, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]

; 71   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T2 = -264						; size = 28
$T3 = -236						; size = 28
$T4 = -208						; size = 28
$T5 = -180						; size = 28
$T6 = -152						; size = 28
$T7 = -124						; size = 28
_meshpath$ = -96					; size = 28
_meshfilename$ = -68					; size = 28
$T8 = -40						; size = 4
tv198 = -36						; size = 4
tv196 = -32						; size = 4
tv194 = -28						; size = 4
tv192 = -24						; size = 4
tv190 = -20						; size = 4
tv188 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 704  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH

; 705  :     // initialize the mesh file to load
; 706  :     std::string meshpath = std::string("../../data/meshes/");

	push	OFFSET $SG147640
	lea	ecx, DWORD PTR _meshpath$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 707  :     std::string meshfilename;

	lea	ecx, DWORD PTR _meshfilename$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 708  :     std::cout << "Enter OBJ File Name(otherwise press enter none):";

	push	OFFSET $SG147641
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 709  :     std::cin >> meshfilename;

	lea	eax, DWORD PTR _meshfilename$[ebp]
	push	eax
	push	OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
	call	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 710  :     meshOBJ = meshpath + meshfilename;

	lea	ecx, DWORD PTR _meshfilename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _meshpath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	push	ecx
	mov	ecx, OFFSET ?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; meshOBJ
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 711  : 
; 712  : 
; 713  :     // intialize vertex and fragment shaders
; 714  :     vertexShader   = std::string("kernels/default.vert");

	push	OFFSET $SG147642
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv190[ebp], eax
	mov	edx, DWORD PTR tv190[ebp]
	push	edx
	mov	ecx, OFFSET ?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; vertexShader
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 715  :     fragmentShader = std::string("kernels/phong.frag");

	push	OFFSET $SG147643
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv192[ebp], eax
	mov	eax, DWORD PTR tv192[ebp]
	push	eax
	mov	ecx, OFFSET ?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; fragmentShader
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 716  :     normalMap      = std::string("../../data/images/world_map.jpeg");

	push	OFFSET $SG147644
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv194[ebp], eax
	mov	ecx, DWORD PTR tv194[ebp]
	push	ecx
	mov	ecx, OFFSET ?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; normalMap
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 717  :     displacementMap= std::string("../../data/images/world_map.jpeg");

	push	OFFSET $SG147645
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv196[ebp], eax
	mov	edx, DWORD PTR tv196[ebp]
	push	edx
	mov	ecx, OFFSET ?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; displacementMap
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 718  : 	
; 719  : 	//Added
; 720  : 	colorMap = std::string("../../data/images/cactus.jpeg");

	push	OFFSET $SG147646
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv198[ebp], eax
	mov	eax, DWORD PTR tv198[ebp]
	push	eax
	mov	ecx, OFFSET ?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; colorMap
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 721  : 
; 722  : 
; 723  :     // initialize free glut
; 724  :     glutInit(&argc, argv);

	mov	ecx, DWORD PTR _argv$[ebp]
	push	ecx
	lea	edx, DWORD PTR _argc$[ebp]
	push	edx
	call	_glutInit_ATEXIT_HACK
	add	esp, 8

; 725  :     glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);

	push	18					; 00000012H
	call	_glutInitDisplayMode
	add	esp, 4

; 726  :     glutInitWindowPosition(20, 20);

	push	20					; 00000014H
	push	20					; 00000014H
	call	_glutInitWindowPosition
	add	esp, 8

; 727  :     glutInitWindowSize(640, 480);

	push	480					; 000001e0H
	push	640					; 00000280H
	call	_glutInitWindowSize
	add	esp, 8

; 728  :     glutCreateWindow("proj1_mesh");

	push	OFFSET $SG147647
	call	_glutCreateWindow_ATEXIT_HACK
	add	esp, 4

; 729  : 
; 730  : 
; 731  : 	// check that opengl 3.3 is supported for future projects
; 732  : 	if (GL_VERSION_3_3)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@main

; 733  : 		fprintf(stderr, "OpenGL 3.3 is supported!\n\n");

	push	OFFSET $SG147650
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 734  : 	else

	jmp	SHORT $LN3@main
$LN2@main:

; 735  : 		fprintf(stderr, "OpenGL 3.3 NOT supported!\n\n");

	push	OFFSET $SG147651
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@main:

; 736  : 
; 737  :     // initialize GLEW.
; 738  : #ifndef __APPLE__
; 739  :     glewInit();

	call	_glewInit@0

; 740  :     if(!GLEW_VERSION_2_0) {

	movzx	ecx, BYTE PTR ___GLEW_VERSION_2_0
	test	ecx, ecx
	jne	SHORT $LN4@main

; 741  :         printf("Your graphics card or graphics driver does\n"

	push	OFFSET $SG147653
	call	_printf
	add	esp, 4

; 742  :                "\tnot support OpenGL 2.0, trying ARB extensions\n");
; 743  : 
; 744  :         if(!GLEW_ARB_vertex_shader || !GLEW_ARB_fragment_shader) {

	movzx	edx, BYTE PTR ___GLEW_ARB_vertex_shader
	test	edx, edx
	je	SHORT $LN6@main
	movzx	eax, BYTE PTR ___GLEW_ARB_fragment_shader
	test	eax, eax
	jne	SHORT $LN4@main
$LN6@main:

; 745  :             printf("ARB extensions don't work either.\n");

	push	OFFSET $SG147656
	call	_printf
	add	esp, 4

; 746  :             printf("\tYou can try updating your graphics drivers.\n"

	push	OFFSET $SG147657
	call	_printf
	add	esp, 4

; 747  :                    "\tIf that does not work, you will have to find\n");
; 748  :             printf("\ta machine with a newer graphics card.\n");

	push	OFFSET $SG147658
	call	_printf
	add	esp, 4

; 749  :             exit(1);

	push	1
	call	_exit
$LN4@main:

; 750  :         }
; 751  :     }
; 752  : #endif
; 753  : 
; 754  : 
; 755  : 
; 756  : 
; 757  :     // set-up the scene
; 758  :     Setup();

	call	?Setup@@YAXXZ				; Setup

; 759  : 
; 760  :     // add callback functions
; 761  :     glutDisplayFunc(DisplayCallback);

	push	OFFSET ?DisplayCallback@@YAXXZ		; DisplayCallback
	call	_glutDisplayFunc
	add	esp, 4

; 762  :     glutReshapeFunc(ReshapeCallback);

	push	OFFSET ?ReshapeCallback@@YAXHH@Z	; ReshapeCallback
	call	_glutReshapeFunc
	add	esp, 4

; 763  :     glutSpecialFunc(SpecialKeyCallback);

	push	OFFSET ?SpecialKeyCallback@@YAXHHH@Z	; SpecialKeyCallback
	call	_glutSpecialFunc
	add	esp, 4

; 764  :     glutKeyboardFunc(KeyCallback);

	push	OFFSET ?KeyCallback@@YAXEHH@Z		; KeyCallback
	call	_glutKeyboardFunc
	add	esp, 4

; 765  :     glutMouseFunc(MouseCallback);

	push	OFFSET ?MouseCallback@@YAXHHHH@Z	; MouseCallback
	call	_glutMouseFunc
	add	esp, 4

; 766  :     glutMotionFunc(MouseMotionCallback);

	push	OFFSET ?MouseMotionCallback@@YAXHH@Z	; MouseMotionCallback
	call	_glutMotionFunc
	add	esp, 4

; 767  :     glutIdleFunc(DisplayCallback);

	push	OFFSET ?DisplayCallback@@YAXXZ		; DisplayCallback
	call	_glutIdleFunc
	add	esp, 4

; 768  : 
; 769  :     // run OpenGL mainloop
; 770  :     glutMainLoop();

	call	_glutMainLoop

; 771  : 
; 772  :     // clean up
; 773  :     ClearGlobalMesh();

	call	?ClearGlobalMesh@@YAXXZ			; ClearGlobalMesh

; 774  : 
; 775  :     return 0;

	mov	DWORD PTR $T8[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _meshfilename$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshpath$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T8[ebp]
$LN7@main:

; 776  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _meshpath$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR _meshfilename$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_main:
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Result$ = -4						; size = 4
__Val$ = 8						; size = 4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::operator>>, COMDAT
; _this$ = ecx

; 279  : 		{	// extract an int

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 		static_assert(sizeof(int) == sizeof(long),
; 281  : 			"Bad overflow assumptions due to sizeof(int) != sizeof(long)");
; 282  : 		long _Result = _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Result$[ebp], ecx

; 283  : 		_Common_extract_with_num_get(_Result);

	lea	edx, DWORD PTR __Result$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Common_extract_with_num_get@J@?$basic_istream@DU?$char_traits@D@std@@@std@@AAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::_Common_extract_with_num_get<long>

; 284  : 		_Val = _Result;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [eax], ecx

; 285  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 286  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::operator>>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T2 = -68						; size = 8
__Ctype_fac$3 = -60					; size = 4
$T4 = -56						; size = 4
tv260 = -52						; size = 4
tv259 = -48						; size = 4
tv258 = -44						; size = 4
tv257 = -40						; size = 4
tv254 = -36						; size = 4
tv256 = -32						; size = 4
__Meta$5 = -28						; size = 4
_this$ = -24						; size = 4
tv261 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 132  : 		{	// test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		if (this->good())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	$LN5@Ipfx

; 134  : 			{	// state okay, flush tied stream and skip whitespace
; 135  : 			if (_Myios::tie() != nullptr)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	test	eax, eax
	je	SHORT $LN6@Ipfx

; 136  : 				_Myios::tie()->flush();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN6@Ipfx:

; 137  : 
; 138  : 			if (!_Noskip && this->flags() & ios_base::skipws)

	movzx	eax, BYTE PTR __Noskip$[ebp]
	test	eax, eax
	jne	$LN7@Ipfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 1
	je	$LN7@Ipfx

; 139  : 				{	// skip whitespace
; 140  : 				const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv256[ebp], eax
	mov	eax, DWORD PTR tv256[ebp]
	mov	DWORD PTR tv254[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR tv254[ebp]
	push	ecx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 141  : 
; 142  : 				_TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 143  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv257[ebp], eax
	mov	ecx, DWORD PTR tv257[ebp]
	call	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
	mov	DWORD PTR tv258[ebp], eax
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR __Meta$5[ebp], ecx
	jmp	SHORT $LN4@Ipfx
$LN2@Ipfx:

; 144  : 
; 145  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv259[ebp], eax
	mov	ecx, DWORD PTR tv259[ebp]
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	mov	DWORD PTR tv260[ebp], eax
	mov	ecx, DWORD PTR tv260[ebp]
	mov	DWORD PTR __Meta$5[ebp], ecx
$LN4@Ipfx:

; 146  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T4[ebp], eax
	lea	edx, DWORD PTR __Meta$5[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Ipfx

; 147  : 						{	// end of file, quit
; 148  : 						_Myios::setstate(ios_base::eofbit);

	push	0
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 149  : 						break;

	jmp	SHORT $LN3@Ipfx
	jmp	SHORT $LN10@Ipfx
$LN9@Ipfx:

; 150  : 						}
; 151  : 					else if (!_Ctype_fac.is(_Ctype::space,

	lea	ecx, DWORD PTR __Meta$5[ebp]
	push	ecx
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	movzx	edx, al
	push	edx
	push	72					; 00000048H
	mov	ecx, DWORD PTR __Ctype_fac$3[ebp]
	call	?is@?$ctype@D@std@@QBE_NFD@Z		; std::ctype<char>::is
	mov	BYTE PTR tv261[ebp], al
	movzx	eax, BYTE PTR tv261[ebp]
	test	eax, eax
	jne	SHORT $LN10@Ipfx

; 152  : 						_Traits::to_char_type(_Meta)))
; 153  : 						break;	// not whitespace, quit

	jmp	SHORT $LN3@Ipfx
$LN10@Ipfx:

; 154  : 				_CATCH_IO_END

	jmp	$LN2@Ipfx
$LN3@Ipfx:
	jmp	SHORT $LN14@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:
	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN18@Ipfx
	ret	0
$LN14@Ipfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN7@Ipfx
$LN18@Ipfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN7@Ipfx:

; 155  : 				}
; 156  : 
; 157  : 			if (this->good())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Ipfx

; 158  : 				return (true);

	mov	al, 1
	jmp	SHORT $LN1@Ipfx
$LN5@Ipfx:

; 159  : 			}
; 160  : 		_Myios::setstate(ios_base::failbit);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 161  : 		return (false);

	xor	al, al
$LN1@Ipfx:

; 162  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T2 = -352						; size = 24
_sphereObject$3 = -328					; size = 60
_sphereObject$4 = -268					; size = 60
$T5 = -208						; size = 28
$T6 = -180						; size = 12
$T7 = -168						; size = 28
$T8 = -140						; size = 28
$T9 = -112						; size = 28
$T10 = -84						; size = 4
_tempMesh$11 = -80					; size = 16
tv160 = -64						; size = 4
$T12 = -60						; size = 4
$T13 = -56						; size = 4
tv317 = -52						; size = 4
tv310 = -48						; size = 4
tv277 = -44						; size = 4
$T14 = -40						; size = 4
tv147 = -36						; size = 4
$T15 = -32						; size = 4
_screenshot$16 = -28					; size = 4
_id$17 = -24						; size = 4
tv65 = -20						; size = 4
_id$18 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 1
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?KeyCallback@@YAXEHH@Z PROC				; KeyCallback

; 546  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?KeyCallback@@YAXEHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 340				; 00000154H

; 547  : 
; 548  :     switch (key) {

	movzx	eax, BYTE PTR _key$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 97					; 00000061H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 22			; 00000016H
	ja	$LN28@KeyCallbac
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN48@KeyCallbac[edx]
	jmp	DWORD PTR $LN50@KeyCallbac[eax*4]
$LN10@KeyCallbac:

; 549  : 
; 550  :         // create sphere
; 551  :         case 'c':  {
; 552  :             MySphere  sphereObject;

	lea	ecx, DWORD PTR _sphereObject$4[ebp]
	call	??0MySphere@@QAE@XZ			; MySphere::MySphere
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 553  :             std::cout << "Processing..." << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET $SG147542
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 554  :             sphereObject.Create(globallevels); 

	mov	ecx, DWORD PTR ?globallevels@@3HA	; globallevels
	push	ecx
	lea	ecx, DWORD PTR _sphereObject$4[ebp]
	call	?Create@MySphere@@QAEXH@Z		; MySphere::Create

; 555  :             std::cout << "Sphere created!" << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET $SG147543
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 556  :             break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sphereObject$4[ebp]
	call	??1MySphere@@QAE@XZ			; MySphere::~MySphere
	jmp	$LN2@KeyCallbac

; 557  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sphereObject$4[ebp]
	call	??1MySphere@@QAE@XZ			; MySphere::~MySphere
$LN11@KeyCallbac:

; 558  : 
; 559  : 
; 560  :         // toggle the mesh from the createYourOwnMesh on and off
; 561  :         case 'd':{
; 562  :             meshType = meshQueue.front();

	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::front
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?meshType@@3W4MeshType@@A, edx ; meshType

; 563  :             meshQueue.push(meshQueue.front());

	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::front
	push	eax
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXABW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push

; 564  :             meshQueue.pop();

	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?pop@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::pop

; 565  :             break;

	jmp	$LN2@KeyCallbac
$LN12@KeyCallbac:

; 566  :         }
; 567  : 
; 568  : 
; 569  :         // save a screen shot as data/images/screenshot.jpg
; 570  :         case 's': {
; 571  :             STImage* screenshot = new STImage(gWindowSizeX, gWindowSizeY);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T15[ebp], 0
	je	SHORT $LN30@KeyCallbac
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T10[ebp], esp
	push	0
	push	0
	push	0
	push	0
	call	??0STColor4ub@@QAE@EEEE@Z		; STColor4ub::STColor4ub
	mov	eax, DWORD PTR ?gWindowSizeY@@3HA
	push	eax
	mov	ecx, DWORD PTR ?gWindowSizeX@@3HA
	push	ecx
	mov	ecx, DWORD PTR $T15[ebp]
	call	??0STImage@@QAE@HHUSTColor4ub@@@Z	; STImage::STImage
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN31@KeyCallbac
$LN30@KeyCallbac:
	mov	DWORD PTR tv147[ebp], 0
$LN31@KeyCallbac:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR _screenshot$16[ebp], eax

; 572  :             screenshot->Read(0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _screenshot$16[ebp]
	call	?Read@STImage@@QAEXHH@Z			; STImage::Read

; 573  :             screenshot->Save("../../data/images/screenshot.jpg");

	push	OFFSET $SG147547
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _screenshot$16[ebp]
	call	?Save@STImage@@QBE?AW4STStatus@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STImage::Save
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 574  :             delete screenshot;

	mov	edx, DWORD PTR _screenshot$16[ebp]
	mov	DWORD PTR $T12[ebp], edx
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T14[ebp], eax
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN32@KeyCallbac
	push	1
	mov	ecx, DWORD PTR $T14[ebp]
	call	??_GSTImage@@QAEPAXI@Z
	mov	DWORD PTR tv160[ebp], eax
	jmp	SHORT $LN33@KeyCallbac
$LN32@KeyCallbac:
	mov	DWORD PTR tv160[ebp], 0
$LN33@KeyCallbac:

; 575  :             break;

	jmp	$LN2@KeyCallbac
$LN13@KeyCallbac:

; 576  :         }
; 577  : 
; 578  :         // reset the camera
; 579  :         case 'r':
; 580  :             resetCamera();

	call	?resetCamera@@YAXXZ			; resetCamera

; 581  :             break;

	jmp	$LN2@KeyCallbac
$LN14@KeyCallbac:

; 582  : 
; 583  :         // reset camera up vector
; 584  :         case 'u':
; 585  :             resetUp();

	call	?resetUp@@YAXXZ				; resetUp

; 586  :             break;

	jmp	$LN2@KeyCallbac
$LN15@KeyCallbac:

; 587  : 
; 588  :         // replace the current mesh with the latest sphere object
; 589  :         case 'm':{
; 590  :             MySphere sphereObject;

	lea	ecx, DWORD PTR _sphereObject$3[ebp]
	call	??0MySphere@@QAE@XZ			; MySphere::MySphere
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 591  :             std::vector<STTriangleMesh*> tempMesh;

	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	call	??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 592  :             STTriangleMesh::LoadObj(tempMesh,sphereObject.FileName());

	lea	ecx, DWORD PTR _sphereObject$3[ebp]
	call	?FileName@MySphere@@QAEPADXZ		; MySphere::FileName
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	lea	edx, DWORD PTR _tempMesh$11[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?LoadObj@STTriangleMesh@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@ABV23@@Z ; STTriangleMesh::LoadObj
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 593  :             if(tempMesh.size()) {

	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	test	eax, eax
	je	SHORT $LN16@KeyCallbac

; 594  :                 gTriangleMeshes = tempMesh;

	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	push	ecx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??4?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator=

; 595  :                 gMassCenter=STTriangleMesh::GetMassCenter(gTriangleMeshes);

	push	OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	?GetMassCenter@STTriangleMesh@@SA?AUSTPoint3@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@Z ; STTriangleMesh::GetMassCenter
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A+8, eax

; 596  :                 meshType = MeshType::Mesh;

	mov	DWORD PTR ?meshType@@3W4MeshType@@A, 0	; meshType

; 597  :                 gBoundingBox=STTriangleMesh::GetBoundingBox(gTriangleMeshes);

	push	OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?GetBoundingBox@STTriangleMesh@@SA?AU?$pair@USTPoint3@@U1@@std@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@@Z ; STTriangleMesh::GetBoundingBox
	add	esp, 8
	push	eax
	mov	ecx, OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A ; gBoundingBox
	call	??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z ; std::pair<STPoint3,STPoint3>::operator=<STPoint3,STPoint3,0>
$LN16@KeyCallbac:

; 598  :            }
; 599  :             break;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	call	??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sphereObject$3[ebp]
	call	??1MySphere@@QAE@XZ			; MySphere::~MySphere
	jmp	$LN2@KeyCallbac

; 600  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	call	??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sphereObject$3[ebp]
	call	??1MySphere@@QAE@XZ			; MySphere::~MySphere
$LN17@KeyCallbac:

; 601  : 
; 602  :         // switch between color, normalMapping and displacementMapping
; 603  :         case 'n': {
; 604  :             textureType = textureQueue.front();

	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::front
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR ?textureType@@3W4TextureType@@A, edx ; textureType

; 605  :             textureQueue.push(textureQueue.front());

	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::front
	push	eax
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXABW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push

; 606  :             textureQueue.pop();

	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?pop@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::pop

; 607  :             break;

	jmp	$LN2@KeyCallbac
$LN18@KeyCallbac:

; 608  :         }
; 609  :         
; 610  : 	    // TO DO: Call subdivision API
; 611  :         // loop subdivide algorithm
; 612  :         case 'l':
; 613  : 			//Calling the necessary function
; 614  : 			if (gTriangleMeshes.size())

	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	test	eax, eax
	je	SHORT $LN19@KeyCallbac

; 615  : 			{
; 616  : 				gTriangleMeshes.at(0)->LoopSubdivide();

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	call	?LoopSubdivide@STTriangleMesh@@QAEXXZ	; STTriangleMesh::LoopSubdivide
$LN19@KeyCallbac:

; 617  : 			}
; 618  :             break;

	jmp	$LN2@KeyCallbac
$LN20@KeyCallbac:

; 619  : 			
; 620  : 
; 621  : 	     // TO DO: Call texture  API
; 622  :          // texturemapping using a  proxy object
; 623  :          case 't':
; 624  : 
; 625  : 				 //Get texture
; 626  : 				 //normalMap = std::string("../../data/images/cactus.jpeg");
; 627  : 
; 628  : 				 //Change textureType
; 629  : 				 textureType = TextureType::Color;

	mov	DWORD PTR ?textureType@@3W4TextureType@@A, 0 ; textureType

; 630  : 
; 631  : 				 //Calling the necessary function
; 632  : 				 if (gTriangleMeshes.size())

	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	test	eax, eax
	je	$LN21@KeyCallbac

; 633  : 				 {
; 634  : 					 gTriangleMeshes.at(0)->CalculateTextureCoordinatesViaSphericalProxy();

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	call	?CalculateTextureCoordinatesViaSphericalProxy@STTriangleMesh@@QAE_NXZ ; STTriangleMesh::CalculateTextureCoordinatesViaSphericalProxy

; 635  : 
; 636  : 					 gTriangleMeshes.at(0)->Build();

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	call	?Build@STTriangleMesh@@QAE_NXZ		; STTriangleMesh::Build

; 637  : 					 gTriangleMeshes.at(0)->mMaterialAmbient[0] = 0.2f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	eax, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [eax+edx+68], xmm0

; 638  : 					 gTriangleMeshes.at(0)->mMaterialAmbient[1] = 0.2f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	eax, DWORD PTR [eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [eax+ecx+68], xmm0

; 639  : 					 gTriangleMeshes.at(0)->mMaterialAmbient[2] = 0.6f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	edx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+eax+68], xmm0

; 640  : 					 gTriangleMeshes.at(0)->mMaterialDiffuse[0] = 0.2f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+eax+84], xmm0

; 641  : 					 gTriangleMeshes.at(0)->mMaterialDiffuse[1] = 0.2f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+edx+84], xmm0

; 642  : 					 gTriangleMeshes.at(0)->mMaterialDiffuse[2] = 0.6f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	eax, DWORD PTR [eax]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [eax+ecx+84], xmm0

; 643  : 					 gTriangleMeshes.at(0)->mMaterialSpecular[0] = 0.6f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	edx, DWORD PTR [eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+ecx+100], xmm0

; 644  : 					 gTriangleMeshes.at(0)->mMaterialSpecular[1] = 0.6f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	edx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+eax+100], xmm0

; 645  : 					 gTriangleMeshes.at(0)->mMaterialSpecular[2] = 0.6f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	ecx, DWORD PTR [eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [ecx+edx+100], xmm0

; 646  : 					 gTriangleMeshes.at(0)->mShininess = 8.0f;

	push	0
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
	mov	eax, DWORD PTR [eax]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [eax+116], xmm0
$LN21@KeyCallbac:

; 647  : 				 }
; 648  : 
; 649  : 			 /*
; 650  : 			 Steps For Textures Apparently
; 651  : 			 1. Create Path to Texture.
; 652  : 			 2. Use TextureType::Color
; 653  : 			 3. Call CalculateTextureCoordinatesViaSphericalProxy()
; 654  : 			 4. Toggle textureType variable for normal and mapping textures.
; 655  : 			 */
; 656  : 
; 657  :             break;

	jmp	$LN2@KeyCallbac
$LN22@KeyCallbac:

; 658  : 
; 659  :         // switch between smooth shading and flat shading
; 660  :         case 'f': 
; 661  :             smooth = !smooth;

	movzx	ecx, BYTE PTR ?smooth@@3_NA		; smooth
	test	ecx, ecx
	jne	SHORT $LN34@KeyCallbac
	mov	DWORD PTR tv277[ebp], 1
	jmp	SHORT $LN35@KeyCallbac
$LN34@KeyCallbac:
	mov	DWORD PTR tv277[ebp], 0
$LN35@KeyCallbac:
	mov	dl, BYTE PTR tv277[ebp]
	mov	BYTE PTR ?smooth@@3_NA, dl		; smooth

; 662  :             break;

	jmp	$LN2@KeyCallbac
$LN23@KeyCallbac:

; 663  : 
; 664  :         // save the triangle mesh
; 665  :         case 'w':
; 666  :             for (unsigned int id = 0; id<gTriangleMeshes.size(); id++)

	mov	DWORD PTR _id$17[ebp], 0
	jmp	SHORT $LN6@KeyCallbac
$LN4@KeyCallbac:
	mov	eax, DWORD PTR _id$17[ebp]
	add	eax, 1
	mov	DWORD PTR _id$17[ebp], eax
$LN6@KeyCallbac:
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR _id$17[ebp], eax
	jae	SHORT $LN5@KeyCallbac

; 667  :                 gTriangleMeshes[id]->Write("output.obj");

	push	OFFSET $SG147559
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	edx, DWORD PTR _id$17[ebp]
	push	edx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Write@STTriangleMesh@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STTriangleMesh::Write
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN4@KeyCallbac
$LN5@KeyCallbac:

; 668  :             break;

	jmp	$LN2@KeyCallbac
$LN24@KeyCallbac:

; 669  : 
; 670  :         // set levels
; 671  :         case 'v':  {
; 672  :             std::cout << "Enter the number of levels:";

	push	OFFSET $SG147561
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 673  :             std::cin >> globallevels;

	push	OFFSET ?globallevels@@3HA		; globallevels
	mov	ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>

; 674  :             break;

	jmp	$LN2@KeyCallbac
$LN25@KeyCallbac:

; 675  :         }
; 676  : 
; 677  :         // draw corrdinate axis
; 678  :         case 'a':
; 679  :             for (int id = 0; id < (int) gTriangleMeshes.size(); id++)

	mov	DWORD PTR _id$18[ebp], 0
	jmp	SHORT $LN9@KeyCallbac
$LN7@KeyCallbac:
	mov	eax, DWORD PTR _id$18[ebp]
	add	eax, 1
	mov	DWORD PTR _id$18[ebp], eax
$LN9@KeyCallbac:
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR _id$18[ebp], eax
	jge	SHORT $LN8@KeyCallbac

; 680  :                 gTriangleMeshes[id]->mDrawAxis = !gTriangleMeshes[id]->mDrawAxis;

	mov	ecx, DWORD PTR _id$18[ebp]
	push	ecx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx+168]
	test	eax, eax
	jne	SHORT $LN36@KeyCallbac
	mov	DWORD PTR tv310[ebp], 1
	jmp	SHORT $LN37@KeyCallbac
$LN36@KeyCallbac:
	mov	DWORD PTR tv310[ebp], 0
$LN37@KeyCallbac:
	mov	ecx, DWORD PTR _id$18[ebp]
	push	ecx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	al, BYTE PTR tv310[ebp]
	mov	BYTE PTR [edx+168], al
	jmp	SHORT $LN7@KeyCallbac
$LN8@KeyCallbac:

; 681  :             if (gCoordAxisTriangleMesh != 0)

	cmp	DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A, 0 ; gCoordAxisTriangleMesh
	je	SHORT $LN26@KeyCallbac

; 682  :                 gCoordAxisTriangleMesh->mDrawAxis = !gCoordAxisTriangleMesh->mDrawAxis;

	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movzx	edx, BYTE PTR [ecx+168]
	test	edx, edx
	jne	SHORT $LN38@KeyCallbac
	mov	DWORD PTR tv317[ebp], 1
	jmp	SHORT $LN39@KeyCallbac
$LN38@KeyCallbac:
	mov	DWORD PTR tv317[ebp], 0
$LN39@KeyCallbac:
	mov	eax, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	mov	cl, BYTE PTR tv317[ebp]
	mov	BYTE PTR [eax+168], cl
$LN26@KeyCallbac:

; 683  :             break;

	jmp	SHORT $LN2@KeyCallbac
$LN27@KeyCallbac:

; 684  : 
; 685  :         // quit
; 686  :         case 'q':
; 687  :             exit(0);

	push	0
	call	_exit
$LN28@KeyCallbac:
$LN2@KeyCallbac:

; 688  : 
; 689  :         default:
; 690  :             break;
; 691  :     }
; 692  : 
; 693  :     // redraw scene
; 694  :     glutPostRedisplay();

	call	_glutPostRedisplay
$LN1@KeyCallbac:

; 695  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN50@KeyCallbac:
	DD	$LN25@KeyCallbac
	DD	$LN10@KeyCallbac
	DD	$LN11@KeyCallbac
	DD	$LN22@KeyCallbac
	DD	$LN18@KeyCallbac
	DD	$LN15@KeyCallbac
	DD	$LN17@KeyCallbac
	DD	$LN27@KeyCallbac
	DD	$LN13@KeyCallbac
	DD	$LN12@KeyCallbac
	DD	$LN20@KeyCallbac
	DD	$LN14@KeyCallbac
	DD	$LN24@KeyCallbac
	DD	$LN23@KeyCallbac
	DD	$LN28@KeyCallbac
$LN48@KeyCallbac:
	DB	0
	DB	14					; 0000000eH
	DB	1
	DB	2
	DB	14					; 0000000eH
	DB	3
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	4
	DB	5
	DB	6
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?KeyCallback@@YAXEHH@Z$0:
	lea	ecx, DWORD PTR _sphereObject$4[ebp]
	jmp	??1MySphere@@QAE@XZ			; MySphere::~MySphere
__unwindfunclet$?KeyCallback@@YAXEHH@Z$1:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?KeyCallback@@YAXEHH@Z$2:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?KeyCallback@@YAXEHH@Z$3:
	lea	ecx, DWORD PTR _sphereObject$3[ebp]
	jmp	??1MySphere@@QAE@XZ			; MySphere::~MySphere
__unwindfunclet$?KeyCallback@@YAXEHH@Z$4:
	lea	ecx, DWORD PTR _tempMesh$11[ebp]
	jmp	??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
__unwindfunclet$?KeyCallback@@YAXEHH@Z$5:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?KeyCallback@@YAXEHH@Z$7:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?KeyCallback@@YAXEHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?KeyCallback@@YAXEHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?KeyCallback@@YAXEHH@Z ENDP				; KeyCallback
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
_deltaX$1 = -8						; size = 4
_deltaY$2 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?MouseMotionCallback@@YAXHH@Z PROC			; MouseMotionCallback

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 509  :     if (gPreviousMouseX >= 0 && gPreviousMouseY >= 0)

	cmp	DWORD PTR ?gPreviousMouseX@@3HA, 0	; gPreviousMouseX
	jl	$LN2@MouseMotio
	cmp	DWORD PTR ?gPreviousMouseY@@3HA, 0	; gPreviousMouseY
	jl	$LN2@MouseMotio

; 510  :     {
; 511  :         //compute delta
; 512  :         float deltaX = x-gPreviousMouseX;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR ?gPreviousMouseX@@3HA	; gPreviousMouseX
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _deltaX$1[ebp], xmm0

; 513  :         float deltaY = y-gPreviousMouseY;

	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR ?gPreviousMouseY@@3HA	; gPreviousMouseY
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _deltaY$2[ebp], xmm0

; 514  :         gPreviousMouseX = x;

	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR ?gPreviousMouseX@@3HA, edx	; gPreviousMouseX

; 515  :         gPreviousMouseY = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR ?gPreviousMouseY@@3HA, eax	; gPreviousMouseY

; 516  : 
; 517  :         //orbit, strafe, or zoom
; 518  :         if (gMouseButton == GLUT_LEFT_BUTTON)

	cmp	DWORD PTR ?gMouseButton@@3HA, 0		; gMouseButton
	jne	SHORT $LN4@MouseMotio

; 519  :         {
; 520  :             RotateCamera(deltaX, deltaY);

	push	ecx
	movss	xmm0, DWORD PTR _deltaY$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _deltaX$1[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?RotateCamera@@YAXMM@Z			; RotateCamera
	add	esp, 8
	jmp	SHORT $LN8@MouseMotio
$LN4@MouseMotio:

; 521  :         }
; 522  :         else if (gMouseButton == GLUT_MIDDLE_BUTTON)

	cmp	DWORD PTR ?gMouseButton@@3HA, 1		; gMouseButton
	jne	SHORT $LN6@MouseMotio

; 523  :         {
; 524  :             StrafeCamera(deltaX, deltaY);

	push	ecx
	movss	xmm0, DWORD PTR _deltaY$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _deltaX$1[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?StrafeCamera@@YAXMM@Z			; StrafeCamera
	add	esp, 8
	jmp	SHORT $LN8@MouseMotio
$LN6@MouseMotio:

; 525  :         }
; 526  :         else if (gMouseButton == GLUT_RIGHT_BUTTON)

	cmp	DWORD PTR ?gMouseButton@@3HA, 2		; gMouseButton
	jne	SHORT $LN8@MouseMotio

; 527  :         {
; 528  :             ZoomCamera(deltaY);

	push	ecx
	movss	xmm0, DWORD PTR _deltaY$2[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ZoomCamera@@YAXM@Z			; ZoomCamera
	add	esp, 4
$LN8@MouseMotio:

; 529  :         }
; 530  : 
; 531  :     } else

	jmp	SHORT $LN3@MouseMotio
$LN2@MouseMotio:

; 532  :     {
; 533  :         gPreviousMouseX = x;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR ?gPreviousMouseX@@3HA, ecx	; gPreviousMouseX

; 534  :         gPreviousMouseY = y;

	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR ?gPreviousMouseY@@3HA, edx	; gPreviousMouseY
$LN3@MouseMotio:

; 535  :     }
; 536  : 
; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MouseMotionCallback@@YAXHH@Z ENDP			; MouseMotionCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?MouseCallback@@YAXHHHH@Z PROC				; MouseCallback

; 484  : {

	push	ebp
	mov	ebp, esp

; 485  :     if (button == GLUT_LEFT_BUTTON
; 486  :         || button == GLUT_RIGHT_BUTTON
; 487  :         || button == GLUT_MIDDLE_BUTTON)

	cmp	DWORD PTR _button$[ebp], 0
	je	SHORT $LN4@MouseCallb
	cmp	DWORD PTR _button$[ebp], 2
	je	SHORT $LN4@MouseCallb
	cmp	DWORD PTR _button$[ebp], 1
	jne	SHORT $LN2@MouseCallb
$LN4@MouseCallb:

; 488  :     {
; 489  :         gMouseButton = button;

	mov	eax, DWORD PTR _button$[ebp]
	mov	DWORD PTR ?gMouseButton@@3HA, eax	; gMouseButton

; 490  :     } else

	jmp	SHORT $LN3@MouseCallb
$LN2@MouseCallb:

; 491  :     {
; 492  :         gMouseButton = -1;

	mov	DWORD PTR ?gMouseButton@@3HA, -1	; gMouseButton
$LN3@MouseCallb:

; 493  :     }
; 494  : 
; 495  :     if (state == GLUT_UP)

	cmp	DWORD PTR _state$[ebp], 1
	jne	SHORT $LN1@MouseCallb

; 496  :     {
; 497  :         gPreviousMouseX = -1;

	mov	DWORD PTR ?gPreviousMouseX@@3HA, -1	; gPreviousMouseX

; 498  :         gPreviousMouseY = -1;

	mov	DWORD PTR ?gPreviousMouseY@@3HA, -1	; gPreviousMouseY
$LN1@MouseCallb:

; 499  :     }
; 500  : }

	pop	ebp
	ret	0
?MouseCallback@@YAXHHHH@Z ENDP				; MouseCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_key$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?SpecialKeyCallback@@YAXHHH@Z PROC			; SpecialKeyCallback

; 458  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 459  :     switch(key) {

	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 100				; 00000064H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	$LN8@SpecialKey
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@SpecialKey[edx*4]
$LN4@SpecialKey:

; 460  :         case GLUT_KEY_LEFT:
; 461  :             StrafeCamera(10,0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	call	?StrafeCamera@@YAXMM@Z			; StrafeCamera
	add	esp, 8

; 462  :             break;

	jmp	SHORT $LN2@SpecialKey
$LN5@SpecialKey:

; 463  :         case GLUT_KEY_RIGHT:
; 464  :             StrafeCamera(-10,0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	?StrafeCamera@@YAXMM@Z			; StrafeCamera
	add	esp, 8

; 465  :             break;

	jmp	SHORT $LN2@SpecialKey
$LN6@SpecialKey:

; 466  :         case GLUT_KEY_DOWN:
; 467  :             StrafeCamera(0,-10);

	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	?StrafeCamera@@YAXMM@Z			; StrafeCamera
	add	esp, 8

; 468  :             break;

	jmp	SHORT $LN2@SpecialKey
$LN7@SpecialKey:

; 469  :         case GLUT_KEY_UP:
; 470  :             StrafeCamera(0,10);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	?StrafeCamera@@YAXMM@Z			; StrafeCamera
	add	esp, 8
$LN8@SpecialKey:
$LN2@SpecialKey:

; 471  :             break;
; 472  :         default:
; 473  :             break;
; 474  :     }
; 475  :     glutPostRedisplay();

	call	_glutPostRedisplay

; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@SpecialKey:
	DD	$LN4@SpecialKey
	DD	$LN7@SpecialKey
	DD	$LN5@SpecialKey
	DD	$LN6@SpecialKey
?SpecialKeyCallback@@YAXHHH@Z ENDP			; SpecialKeyCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
_aspectRatio$ = -4					; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
?ReshapeCallback@@YAXHH@Z PROC				; ReshapeCallback

; 436  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 437  :     gWindowSizeX = w;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR ?gWindowSizeX@@3HA, eax

; 438  :     gWindowSizeY = h;

	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR ?gWindowSizeY@@3HA, ecx

; 439  : 
; 440  :     glViewport(0, 0, gWindowSizeX, gWindowSizeY);

	mov	edx, DWORD PTR ?gWindowSizeY@@3HA
	push	edx
	mov	eax, DWORD PTR ?gWindowSizeX@@3HA
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16

; 441  : 
; 442  :     glMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 443  :     glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 444  :     // Set up a perspective projection
; 445  :     float aspectRatio = (float) gWindowSizeX / (float) gWindowSizeY;

	cvtsi2ss xmm0, DWORD PTR ?gWindowSizeX@@3HA
	cvtsi2ss xmm1, DWORD PTR ?gWindowSizeY@@3HA
	divss	xmm0, xmm1
	movss	DWORD PTR _aspectRatio$[ebp], xmm0

; 446  :     gluPerspective(30.0f, aspectRatio, .1f, 10000.0f);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40c3880000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3fb99999a0000000
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _aspectRatio$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@403e000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_gluPerspective@32

; 447  : 
; 448  :     glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 449  :     glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 450  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReshapeCallback@@YAXHH@Z ENDP				; ReshapeCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T2 = -764						; size = 28
$T3 = -736						; size = 28
$T4 = -708						; size = 28
$T5 = -680						; size = 28
$T6 = -652						; size = 28
$T7 = -624						; size = 28
$T8 = -596						; size = 28
$T9 = -568						; size = 28
$T10 = -540						; size = 28
$T11 = -512						; size = 28
$T12 = -484						; size = 28
$T13 = -456						; size = 28
$T14 = -428						; size = 28
$T15 = -400						; size = 28
$T16 = -372						; size = 28
$T17 = -344						; size = 28
$T18 = -316						; size = 28
$T19 = -288						; size = 28
$T20 = -260						; size = 28
$T21 = -232						; size = 28
$T22 = -204						; size = 28
$T23 = -176						; size = 28
$T24 = -148						; size = 28
$T25 = -120						; size = 28
$T26 = -92						; size = 28
$T27 = -64						; size = 28
_size_vector$28 = -36					; size = 12
_maxSize$29 = -24					; size = 4
_id$30 = -20						; size = 4
_id$31 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?DisplayCallback@@YAXXZ PROC				; DisplayCallback

; 305  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayCallback@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 752				; 000002f0H

; 306  :     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4

; 307  : 
; 308  :     glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 309  :     glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 310  : 
; 311  :     SetUpAndRight();

	call	?SetUpAndRight@@YAXXZ			; SetUpAndRight

; 312  : 
; 313  :     gluLookAt(mPosition.x,mPosition.y,mPosition.z,

	cvtss2sd xmm0, DWORD PTR ?mUp@@3USTVector3@@A+8
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mUp@@3USTVector3@@A+4
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mUp@@3USTVector3@@A
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mLookAt@@3USTVector3@@A+8
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mLookAt@@3USTVector3@@A+4
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mLookAt@@3USTVector3@@A
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mPosition@@3USTVector3@@A+8
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mPosition@@3USTVector3@@A+4
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR ?mPosition@@3USTVector3@@A
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_gluLookAt@72

; 314  :               mLookAt.x,mLookAt.y,mLookAt.z,
; 315  :               mUp.x,mUp.y,mUp.z);
; 316  : 
; 317  :     glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);

	push	OFFSET ?lightPosition@@3PAMA		; lightPosition
	push	4611					; 00001203H
	push	16384					; 00004000H
	call	DWORD PTR __imp__glLightfv@12

; 318  : 
; 319  :     // Texture 0: surface normal map
; 320  :     glActiveTexture(GL_TEXTURE0);

	push	33984					; 000084c0H
	call	DWORD PTR ___glewActiveTexture

; 321  :     surfaceNormTex->Bind();

	mov	ecx, DWORD PTR ?surfaceNormTex@@3PAVSTTexture@@A ; surfaceNormTex
	call	?Bind@STTexture@@QAEXXZ			; STTexture::Bind

; 322  : 
; 323  :     // Texture 1: surface normal map
; 324  :     glActiveTexture(GL_TEXTURE1);

	push	33985					; 000084c1H
	call	DWORD PTR ___glewActiveTexture

; 325  :     surfaceDisplaceTex->Bind();

	mov	ecx, DWORD PTR ?surfaceDisplaceTex@@3PAVSTTexture@@A ; surfaceDisplaceTex
	call	?Bind@STTexture@@QAEXXZ			; STTexture::Bind

; 326  : 
; 327  : 	// Texture 2: Color texture Added
; 328  : 	glActiveTexture(GL_TEXTURE2);

	push	33986					; 000084c2H
	call	DWORD PTR ___glewActiveTexture

; 329  : 	surfaceColorTex->Bind();

	mov	ecx, DWORD PTR ?surfaceColorTex@@3PAVSTTexture@@A ; surfaceColorTex
	call	?Bind@STTexture@@QAEXXZ			; STTexture::Bind

; 330  : 
; 331  :     // Bind the textures we've loaded into openGl to
; 332  :     // the variable names we specify in the fragment
; 333  :     // shader.
; 334  :     shader->SetTexture("normalTex", 0);

	push	OFFSET $SG147220
	lea	ecx, DWORD PTR $T27[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetTexture@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; STShaderProgram::SetTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T27[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 335  :     shader->SetTexture("displacementTex", 1);

	push	OFFSET $SG147221
	lea	ecx, DWORD PTR $T26[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	1
	lea	ecx, DWORD PTR $T26[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetTexture@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; STShaderProgram::SetTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T26[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 336  :       shader->SetTexture("colorTex", 2);

	push	OFFSET $SG147222
	lea	ecx, DWORD PTR $T25[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	2
	lea	edx, DWORD PTR $T25[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetTexture@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; STShaderProgram::SetTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T25[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 337  : 
; 338  :     // Invoke the shader.  Now OpenGL will call our
; 339  :     // shader programs on anything we draw.
; 340  :     shader->Bind();

	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?Bind@STShaderProgram@@QAEXXZ		; STShaderProgram::Bind

; 341  : 
; 342  :     if(meshType == MeshType::Mesh)

	cmp	DWORD PTR ?meshType@@3W4MeshType@@A, 0	; meshType
	jne	$LN8@DisplayCal

; 343  :     {
; 344  : 		shader->SetUniform("normalMapping", -1.0);

	push	OFFSET $SG147225
	lea	ecx, DWORD PTR $T24[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T24[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 345  :         shader->SetUniform("displacementMapping", -1.0);

	push	OFFSET $SG147226
	lea	ecx, DWORD PTR $T23[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T23[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T23[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  :         shader->SetUniform("colorMapping", 1.0);

	push	OFFSET $SG147227
	lea	ecx, DWORD PTR $T22[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T22[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T22[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 347  : 
; 348  : 		//ADDED THIS HERE
; 349  : 		// set up shader textures
; 350  : 		if (textureType == TextureType::Color) {

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 0 ; textureType
	jne	$LN10@DisplayCal

; 351  : 			shader->SetUniform("displacementMapping", -1.0);

	push	OFFSET $SG147230
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 352  : 			shader->SetUniform("normalMapping", -1.0);

	push	OFFSET $SG147231
	lea	ecx, DWORD PTR $T20[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T20[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 353  : 			shader->SetUniform("colorMapping", 1.0);

	push	OFFSET $SG147232
	lea	ecx, DWORD PTR $T19[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T19[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN14@DisplayCal
$LN10@DisplayCal:

; 354  : 		}
; 355  : 		else if (textureType == TextureType::NormalMapping) {

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 1 ; textureType
	jne	$LN12@DisplayCal

; 356  : 			shader->SetUniform("displacementMapping", -1.0);

	push	OFFSET $SG147235
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T18[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 357  : 			shader->SetUniform("normalMapping", 1.0);

	push	OFFSET $SG147236
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T17[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T17[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 358  : 			shader->SetUniform("colorMapping", -1.0);

	push	OFFSET $SG147237
	lea	ecx, DWORD PTR $T16[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T16[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN14@DisplayCal
$LN12@DisplayCal:

; 359  : 		}
; 360  : 		else if (textureType == TextureType::DisplacementMapping) {

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 2 ; textureType
	jne	$LN14@DisplayCal

; 361  : 			shader->SetUniform("displacementMapping", 1.0);

	push	OFFSET $SG147239
	lea	ecx, DWORD PTR $T15[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T15[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 362  : 			shader->SetUniform("normalMapping", -1.0);

	push	OFFSET $SG147240
	lea	ecx, DWORD PTR $T14[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T14[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 363  : 			shader->SetUniform("colorMapping", -1.0);

	push	OFFSET $SG147241
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T13[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T13[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 364  : 			shader->SetUniform("TesselationDepth", TesselationDepth);

	push	OFFSET $SG147242
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cvtsi2ss xmm0, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN14@DisplayCal:

; 365  : 		}
; 366  : 
; 367  :         glPushMatrix();

	call	DWORD PTR __imp__glPushMatrix@0

; 368  :         // Pay attention to scale
; 369  :         STVector3 size_vector=gBoundingBox.second-gBoundingBox.first;

	push	OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A ; gBoundingBox
	push	OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A+12
	lea	ecx, DWORD PTR _size_vector$28[ebp]
	push	ecx
	call	??G@YA?AUSTVector3@@ABUSTPoint3@@0@Z	; operator-
	add	esp, 12					; 0000000cH

; 370  :         float maxSize=(std::max)((std::max)(size_vector.x,size_vector.y),size_vector.z);

	lea	edx, DWORD PTR _size_vector$28[ebp+8]
	push	edx
	lea	eax, DWORD PTR _size_vector$28[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _size_vector$28[ebp]
	push	ecx
	call	??$max@M@std@@YAABMABM0@Z		; std::max<float>
	add	esp, 8
	push	eax
	call	??$max@M@std@@YAABMABM0@Z		; std::max<float>
	add	esp, 8
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _maxSize$29[ebp], xmm0

; 371  :         glScalef(3.0f/maxSize,3.0f/maxSize,3.0f/maxSize);

	movss	xmm0, DWORD PTR __real@40400000
	divss	xmm0, DWORD PTR _maxSize$29[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@40400000
	divss	xmm0, DWORD PTR _maxSize$29[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR __real@40400000
	divss	xmm0, DWORD PTR _maxSize$29[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glScalef@12

; 372  :         glTranslatef(-gMassCenter.x,-gMassCenter.y,-gMassCenter.z);

	movss	xmm0, DWORD PTR ?gMassCenter@@3USTPoint3@@A+8
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?gMassCenter@@3USTPoint3@@A+4
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR ?gMassCenter@@3USTPoint3@@A
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glTranslatef@12

; 373  :         for(int id=0; id < (int)gTriangleMeshes.size(); id++) {

	mov	DWORD PTR _id$31[ebp], 0
	jmp	SHORT $LN4@DisplayCal
$LN2@DisplayCal:
	mov	edx, DWORD PTR _id$31[ebp]
	add	edx, 1
	mov	DWORD PTR _id$31[ebp], edx
$LN4@DisplayCal:
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR _id$31[ebp], eax
	jge	SHORT $LN3@DisplayCal

; 374  :                    gTriangleMeshes[id]->Draw(smooth);

	movzx	eax, BYTE PTR ?smooth@@3_NA		; smooth
	push	eax
	mov	ecx, DWORD PTR _id$31[ebp]
	push	ecx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Draw@STTriangleMesh@@QBEX_N@Z		; STTriangleMesh::Draw

; 375  :         }

	jmp	SHORT $LN2@DisplayCal
$LN3@DisplayCal:

; 376  :         glPopMatrix();

	call	DWORD PTR __imp__glPopMatrix@0
	jmp	$LN6@DisplayCal
$LN8@DisplayCal:

; 377  :     }
; 378  :     else if(meshType == MeshType::Axis)

	cmp	DWORD PTR ?meshType@@3W4MeshType@@A, 1	; meshType
	jne	$LN6@DisplayCal

; 379  :     {
; 380  :         // set up shader textures
; 381  :         if(textureType == TextureType::Color) {

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 0 ; textureType
	jne	$LN16@DisplayCal

; 382  :             shader->SetUniform("displacementMapping", -1.0);

	push	OFFSET $SG147246
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 383  :             shader->SetUniform("normalMapping", -1.0);

	push	OFFSET $SG147247
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 384  :             shader->SetUniform("colorMapping", 1.0);

	push	OFFSET $SG147248
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN20@DisplayCal
$LN16@DisplayCal:

; 385  :         }
; 386  :         else if(textureType == TextureType::NormalMapping){

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 1 ; textureType
	jne	$LN18@DisplayCal

; 387  :             shader->SetUniform("displacementMapping", -1.0);

	push	OFFSET $SG147251
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 388  :             shader->SetUniform("normalMapping", 1.0);

	push	OFFSET $SG147252
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 389  :             shader->SetUniform("colorMapping", -1.0);

	push	OFFSET $SG147253
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN20@DisplayCal
$LN18@DisplayCal:

; 390  :         }
; 391  :         else if(textureType == TextureType::DisplacementMapping){

	cmp	DWORD PTR ?textureType@@3W4TextureType@@A, 2 ; textureType
	jne	$LN20@DisplayCal

; 392  :             shader->SetUniform("displacementMapping", 1.0);

	push	OFFSET $SG147255
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 22		; 00000016H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 393  :             shader->SetUniform("normalMapping", -1.0);

	push	OFFSET $SG147256
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 23		; 00000017H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 394  :             shader->SetUniform("colorMapping", -1.0);

	push	OFFSET $SG147257
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 24		; 00000018H
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 395  :             shader->SetUniform("TesselationDepth", TesselationDepth);

	push	OFFSET $SG147258
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 25		; 00000019H
	cvtsi2ss xmm0, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?SetUniform@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; STShaderProgram::SetUniform
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN20@DisplayCal:

; 396  :         }
; 397  : 
; 398  :         // draw the geometry here
; 399  :         if(gCoordAxisTriangleMesh)

	cmp	DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A, 0 ; gCoordAxisTriangleMesh
	je	SHORT $LN21@DisplayCal

; 400  :             gCoordAxisTriangleMesh->Draw(smooth);

	movzx	eax, BYTE PTR ?smooth@@3_NA		; smooth
	push	eax
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	call	?Draw@STTriangleMesh@@QBEX_N@Z		; STTriangleMesh::Draw
$LN21@DisplayCal:

; 401  :         if(gTriangleMeshes.size()) {

	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	test	eax, eax
	je	SHORT $LN6@DisplayCal

; 402  :             for(unsigned int id=0;id<gTriangleMeshes.size();id++) {

	mov	DWORD PTR _id$30[ebp], 0
	jmp	SHORT $LN7@DisplayCal
$LN5@DisplayCal:
	mov	ecx, DWORD PTR _id$30[ebp]
	add	ecx, 1
	mov	DWORD PTR _id$30[ebp], ecx
$LN7@DisplayCal:
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR _id$30[ebp], eax
	jae	SHORT $LN6@DisplayCal

; 403  :                 gTriangleMeshes[id]->Draw(smooth);

	movzx	edx, BYTE PTR ?smooth@@3_NA		; smooth
	push	edx
	mov	eax, DWORD PTR _id$30[ebp]
	push	eax
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Draw@STTriangleMesh@@QBEX_N@Z		; STTriangleMesh::Draw

; 404  :             }

	jmp	SHORT $LN5@DisplayCal
$LN6@DisplayCal:

; 405  :         }
; 406  :     }
; 407  : 
; 408  : 
; 409  : 
; 410  :     // must bind the shader
; 411  :     shader->UnBind();

	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?UnBind@STShaderProgram@@QAEXXZ		; STShaderProgram::UnBind

; 412  : 
; 413  :     // set textures
; 414  :     glActiveTexture(GL_TEXTURE0);

	push	33984					; 000084c0H
	call	DWORD PTR ___glewActiveTexture

; 415  :     surfaceNormTex->UnBind();

	mov	ecx, DWORD PTR ?surfaceNormTex@@3PAVSTTexture@@A ; surfaceNormTex
	call	?UnBind@STTexture@@QAEXXZ		; STTexture::UnBind

; 416  : 
; 417  :     // set textures
; 418  :     glActiveTexture(GL_TEXTURE1);

	push	33985					; 000084c1H
	call	DWORD PTR ___glewActiveTexture

; 419  :     surfaceDisplaceTex->UnBind();

	mov	ecx, DWORD PTR ?surfaceDisplaceTex@@3PAVSTTexture@@A ; surfaceDisplaceTex
	call	?UnBind@STTexture@@QAEXXZ		; STTexture::UnBind

; 420  : 
; 421  : 	//Added
; 422  : 	glActiveTexture(GL_TEXTURE2);

	push	33986					; 000084c2H
	call	DWORD PTR ___glewActiveTexture

; 423  : 	surfaceColorTex->UnBind();

	mov	ecx, DWORD PTR ?surfaceColorTex@@3PAVSTTexture@@A ; surfaceColorTex
	call	?UnBind@STTexture@@QAEXXZ		; STTexture::UnBind

; 424  : 
; 425  :     // swap buffers
; 426  :     glutSwapBuffers();

	call	_glutSwapBuffers

; 427  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DisplayCallback@@YAXXZ$0:
	lea	ecx, DWORD PTR $T27[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$1:
	lea	ecx, DWORD PTR $T26[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$2:
	lea	ecx, DWORD PTR $T25[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$3:
	lea	ecx, DWORD PTR $T24[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$4:
	lea	ecx, DWORD PTR $T23[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$5:
	lea	ecx, DWORD PTR $T22[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$6:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$7:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$8:
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$9:
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$10:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$11:
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$12:
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$13:
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$14:
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$15:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$16:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$17:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$18:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$19:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$20:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$21:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$22:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$23:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$24:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?DisplayCallback@@YAXXZ$25:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?DisplayCallback@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DisplayCallback@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayCallback@@YAXXZ ENDP				; DisplayCallback
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T1 = -52						; size = 12
$T2 = -40						; size = 12
$T3 = -28						; size = 12
$T4 = -16						; size = 12
_strafe_rate$ = -4					; size = 4
_delta_x$ = 8						; size = 4
_delta_y$ = 12						; size = 4
?StrafeCamera@@YAXMM@Z PROC				; StrafeCamera

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 291  :     float strafe_rate = 0.05f;

	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _strafe_rate$[ebp], xmm0

; 292  : 
; 293  :     mPosition -= strafe_rate * delta_x * mRight;

	push	OFFSET ?mRight@@3USTVector3@@A		; mRight
	movss	xmm0, DWORD PTR _strafe_rate$[ebp]
	mulss	xmm0, DWORD PTR _delta_x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??D@YA?AUSTVector3@@MABU0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??ZSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator-=

; 294  :     mLookAt   -= strafe_rate * delta_x * mRight;

	push	OFFSET ?mRight@@3USTVector3@@A		; mRight
	movss	xmm0, DWORD PTR _strafe_rate$[ebp]
	mulss	xmm0, DWORD PTR _delta_x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??D@YA?AUSTVector3@@MABU0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mLookAt@@3USTVector3@@A	; mLookAt
	call	??ZSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator-=

; 295  :     mPosition += strafe_rate * delta_y * mUp;

	push	OFFSET ?mUp@@3USTVector3@@A		; mUp
	movss	xmm0, DWORD PTR _strafe_rate$[ebp]
	mulss	xmm0, DWORD PTR _delta_y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??D@YA?AUSTVector3@@MABU0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??YSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator+=

; 296  :     mLookAt   += strafe_rate * delta_y * mUp;

	push	OFFSET ?mUp@@3USTVector3@@A		; mUp
	movss	xmm0, DWORD PTR _strafe_rate$[ebp]
	mulss	xmm0, DWORD PTR _delta_y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??D@YA?AUSTVector3@@MABU0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mLookAt@@3USTVector3@@A	; mLookAt
	call	??YSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator+=

; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StrafeCamera@@YAXMM@Z ENDP				; StrafeCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 12
_direction$ = -24					; size = 12
_zoom_rate$ = -12					; size = 4
tv73 = -8						; size = 4
_magnitude$ = -4					; size = 4
_delta_y$ = 8						; size = 4
?ZoomCamera@@YAXM@Z PROC				; ZoomCamera

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 279  :     STVector3 direction = mLookAt - mPosition;

	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	lea	eax, DWORD PTR _direction$[ebp]
	push	eax
	call	??G@YA?AUSTVector3@@ABU0@0@Z		; operator-
	add	esp, 12					; 0000000cH

; 280  :     float magnitude = direction.Length();

	lea	ecx, DWORD PTR _direction$[ebp]
	call	?Length@STVector3@@QBEMXZ		; STVector3::Length
	fstp	DWORD PTR _magnitude$[ebp]

; 281  :     direction.Normalize();

	lea	ecx, DWORD PTR _direction$[ebp]
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 282  :     float zoom_rate = 0.1f*magnitude < 0.5f ? .1f*magnitude : .5f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _magnitude$[ebp]
	movss	xmm1, DWORD PTR __real@3f000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@ZoomCamera
	movss	xmm0, DWORD PTR __real@3dcccccd
	mulss	xmm0, DWORD PTR _magnitude$[ebp]
	movss	DWORD PTR tv73[ebp], xmm0
	jmp	SHORT $LN5@ZoomCamera
$LN4@ZoomCamera:
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv73[ebp], xmm0
$LN5@ZoomCamera:
	movss	xmm0, DWORD PTR tv73[ebp]
	movss	DWORD PTR _zoom_rate$[ebp], xmm0

; 283  :     if(delta_y * zoom_rate + magnitude > 0)

	movss	xmm0, DWORD PTR _delta_y$[ebp]
	mulss	xmm0, DWORD PTR _zoom_rate$[ebp]
	addss	xmm0, DWORD PTR _magnitude$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@ZoomCamera

; 284  :     {
; 285  :         mPosition += (delta_y * zoom_rate) * direction;

	lea	ecx, DWORD PTR _direction$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _delta_y$[ebp]
	mulss	xmm0, DWORD PTR _zoom_rate$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YA?AUSTVector3@@MABU0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??YSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator+=
$LN2@ZoomCamera:

; 286  :     }
; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ZoomCamera@@YAXM@Z ENDP				; ZoomCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
_m$ = -96						; size = 64
$T1 = -32						; size = 12
$T2 = -20						; size = 12
_pitch_rate$ = -8					; size = 4
_yaw_rate$ = -4						; size = 4
_delta_x$ = 8						; size = 4
_delta_y$ = 12						; size = 4
?RotateCamera@@YAXMM@Z PROC				; RotateCamera

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 264  :     float yaw_rate=1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _yaw_rate$[ebp], xmm0

; 265  :     float pitch_rate=1.f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _pitch_rate$[ebp], xmm0

; 266  : 
; 267  :     mPosition -= mLookAt;

	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??ZSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator-=

; 268  :     STMatrix4 m;

	lea	ecx, DWORD PTR _m$[ebp]
	call	??0STMatrix4@@QAE@XZ			; STMatrix4::STMatrix4

; 269  :     m.EncodeR(-1*delta_x*yaw_rate, mUp);

	push	OFFSET ?mUp@@3USTVector3@@A		; mUp
	movss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _delta_x$[ebp]
	mulss	xmm0, DWORD PTR _yaw_rate$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _m$[ebp]
	call	?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z ; STMatrix4::EncodeR

; 270  :     mPosition = m * mPosition;

	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z	; STMatrix4::operator*
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 271  :     m.EncodeR(-1*delta_y*pitch_rate, mRight);

	push	OFFSET ?mRight@@3USTVector3@@A		; mRight
	movss	xmm0, DWORD PTR __real@bf800000
	mulss	xmm0, DWORD PTR _delta_y$[ebp]
	mulss	xmm0, DWORD PTR _pitch_rate$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _m$[ebp]
	call	?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z ; STMatrix4::EncodeR

; 272  :     mPosition = m * mPosition;

	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$[ebp]
	call	??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z	; STMatrix4::operator*
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 273  : 
; 274  :     mPosition += mLookAt;

	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??YSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator+=

; 275  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RotateCamera@@YAXMM@Z ENDP				; RotateCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::pair<STPoint3,STPoint3>::operator=<STPoint3,STPoint3,0>, COMDAT
; _this$ = ecx

; 302  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 303  : 		first = _STD forward<_Other1>(_Right.first);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z ; std::forward<STPoint3>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 304  : 		second = _STD forward<_Other2>(_Right.second);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	??$forward@USTPoint3@@@std@@YA$$QAUSTPoint3@@AAU1@@Z ; std::forward<STPoint3>
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 305  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::pair<STPoint3,STPoint3>::operator=<STPoint3,STPoint3,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1019 : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp

; 1020 : 	_Ostr.put(_Ostr.widen('\n'));

	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 1021 : 	_Ostr.flush();

	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 1022 : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 1023 : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T2 = -188						; size = 24
$T3 = -164						; size = 28
$T4 = -136						; size = 12
$T5 = -124						; size = 4
$T6 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
$T16 = -80						; size = 4
$T17 = -76						; size = 4
$T18 = -72						; size = 4
tv193 = -68						; size = 4
$T19 = -64						; size = 4
tv182 = -60						; size = 4
$T20 = -56						; size = 4
tv169 = -52						; size = 4
$T21 = -48						; size = 4
tv157 = -44						; size = 4
$T22 = -40						; size = 4
tv144 = -36						; size = 4
$T23 = -32						; size = 4
tv132 = -28						; size = 4
$T24 = -24						; size = 4
tv87 = -20						; size = 4
$T25 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Setup@@YAXXZ PROC					; Setup

; 198  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Setup@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 176				; 000000b0H

; 199  :     // Set up lighting variables in OpenGL
; 200  :     // Once we do this, we will be able to access them as built-in
; 201  :     // attributes in the shader (see examples of this in normalmap.frag)
; 202  :     glEnable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	DWORD PTR __imp__glEnable@4

; 203  :     glEnable(GL_LIGHT0);

	push	16384					; 00004000H
	call	DWORD PTR __imp__glEnable@4

; 204  :     glLightfv(GL_LIGHT0, GL_SPECULAR,  specularLight);

	push	OFFSET ?specularLight@@3PAMA
	push	4610					; 00001202H
	push	16384					; 00004000H
	call	DWORD PTR __imp__glLightfv@12

; 205  :     glLightfv(GL_LIGHT0, GL_AMBIENT,   ambientLight);

	push	OFFSET ?ambientLight@@3PAMA
	push	4608					; 00001200H
	push	16384					; 00004000H
	call	DWORD PTR __imp__glLightfv@12

; 206  :     glLightfv(GL_LIGHT0, GL_DIFFUSE,   diffuseLight);

	push	OFFSET ?diffuseLight@@3PAMA
	push	4609					; 00001201H
	push	16384					; 00004000H
	call	DWORD PTR __imp__glLightfv@12

; 207  : 
; 208  : 	surfaceNormImg = new STImage(normalMap);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN5@Setup
	push	OFFSET ?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; normalMap
	mov	ecx, DWORD PTR $T25[ebp]
	call	??0STImage@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STImage::STImage
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN6@Setup
$LN5@Setup:
	mov	DWORD PTR tv87[ebp], 0
$LN6@Setup:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T18[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR ?surfaceNormImg@@3PAVSTImage@@A, ecx ; surfaceNormImg

; 209  :     surfaceNormTex = new STTexture(surfaceNormImg);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN7@Setup
	push	1
	mov	edx, DWORD PTR ?surfaceNormImg@@3PAVSTImage@@A ; surfaceNormImg
	push	edx
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0STTexture@@QAE@PBVSTImage@@W4ImageOptions@0@@Z ; STTexture::STTexture
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN8@Setup
$LN7@Setup:
	mov	DWORD PTR tv132[ebp], 0
$LN8@Setup:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T17[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR ?surfaceNormTex@@3PAVSTTexture@@A, ecx ; surfaceNormTex

; 210  : 
; 211  :     surfaceDisplaceImg = new STImage(displacementMap);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T23[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN9@Setup
	push	OFFSET ?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; displacementMap
	mov	ecx, DWORD PTR $T23[ebp]
	call	??0STImage@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STImage::STImage
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN10@Setup
$LN9@Setup:
	mov	DWORD PTR tv144[ebp], 0
$LN10@Setup:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T16[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR ?surfaceDisplaceImg@@3PAVSTImage@@A, eax ; surfaceDisplaceImg

; 212  :     surfaceDisplaceTex = new STTexture(surfaceDisplaceImg);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN11@Setup
	push	1
	mov	ecx, DWORD PTR ?surfaceDisplaceImg@@3PAVSTImage@@A ; surfaceDisplaceImg
	push	ecx
	mov	ecx, DWORD PTR $T22[ebp]
	call	??0STTexture@@QAE@PBVSTImage@@W4ImageOptions@0@@Z ; STTexture::STTexture
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN12@Setup
$LN11@Setup:
	mov	DWORD PTR tv157[ebp], 0
$LN12@Setup:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T15[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR ?surfaceDisplaceTex@@3PAVSTTexture@@A, eax ; surfaceDisplaceTex

; 213  : 
; 214  : 	//Added
; 215  : 
; 216  : 	surfaceColorImg = new STImage(colorMap);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T21[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T21[ebp], 0
	je	SHORT $LN13@Setup
	push	OFFSET ?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; colorMap
	mov	ecx, DWORD PTR $T21[ebp]
	call	??0STImage@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STImage::STImage
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN14@Setup
$LN13@Setup:
	mov	DWORD PTR tv169[ebp], 0
$LN14@Setup:
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR $T14[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T14[ebp]
	mov	DWORD PTR ?surfaceColorImg@@3PAVSTImage@@A, edx ; surfaceColorImg

; 217  : 	surfaceColorTex = new STTexture(surfaceColorImg);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T20[ebp], 0
	je	SHORT $LN15@Setup
	push	1
	mov	eax, DWORD PTR ?surfaceColorImg@@3PAVSTImage@@A ; surfaceColorImg
	push	eax
	mov	ecx, DWORD PTR $T20[ebp]
	call	??0STTexture@@QAE@PBVSTImage@@W4ImageOptions@0@@Z ; STTexture::STTexture
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN16@Setup
$LN15@Setup:
	mov	DWORD PTR tv182[ebp], 0
$LN16@Setup:
	mov	ecx, DWORD PTR tv182[ebp]
	mov	DWORD PTR $T13[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR ?surfaceColorTex@@3PAVSTTexture@@A, edx ; surfaceColorTex

; 218  : 
; 219  :     shader = new STShaderProgram();

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T19[ebp], 0
	je	SHORT $LN17@Setup
	mov	ecx, DWORD PTR $T19[ebp]
	call	??0STShaderProgram@@QAE@XZ		; STShaderProgram::STShaderProgram
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN18@Setup
$LN17@Setup:
	mov	DWORD PTR tv193[ebp], 0
$LN18@Setup:
	mov	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR ?shader@@3PAVSTShaderProgram@@A, ecx ; shader

; 220  :     shader->LoadVertexShader(vertexShader);

	push	OFFSET ?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; vertexShader
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?LoadVertexShader@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STShaderProgram::LoadVertexShader

; 221  :     shader->LoadFragmentShader(fragmentShader);

	push	OFFSET ?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; fragmentShader
	mov	ecx, DWORD PTR ?shader@@3PAVSTShaderProgram@@A ; shader
	call	?LoadFragmentShader@STShaderProgram@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; STShaderProgram::LoadFragmentShader

; 222  : 
; 223  :     resetCamera();

	call	?resetCamera@@YAXXZ			; resetCamera

; 224  : 
; 225  :     glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__glClearColor@16

; 226  :     glEnable(GL_DEPTH_TEST);

	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4

; 227  : 
; 228  :     // textures
; 229  :     textureQueue.push(TextureType::NormalMapping); 

	mov	DWORD PTR $T11[ebp], 1
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push

; 230  :     textureQueue.push(TextureType::DisplacementMapping);

	mov	DWORD PTR $T10[ebp], 2
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push

; 231  :     textureQueue.push(TextureType::Color);

	mov	DWORD PTR $T9[ebp], 0
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push

; 232  : 
; 233  : 
; 234  :     // load the mesh
; 235  :     STTriangleMesh::LoadObj(gTriangleMeshes,meshOBJ);

	push	OFFSET ?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; meshOBJ
	push	OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	?LoadObj@STTriangleMesh@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@ABV23@@Z ; STTriangleMesh::LoadObj
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 236  : 
; 237  :     // set bounding box
; 238  :     if(gTriangleMeshes.size()) {

	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	test	eax, eax
	je	$LN2@Setup

; 239  :         meshType = MeshType::Mesh;

	mov	DWORD PTR ?meshType@@3W4MeshType@@A, 0	; meshType

; 240  :         meshQueue.push(MeshType::Axis);

	mov	DWORD PTR $T8[ebp], 1
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push

; 241  :         meshQueue.push(MeshType::Mesh);

	mov	DWORD PTR $T7[ebp], 0
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push

; 242  :         gMassCenter=STTriangleMesh::GetMassCenter(gTriangleMeshes);

	push	OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	?GetMassCenter@STTriangleMesh@@SA?AUSTPoint3@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@Z ; STTriangleMesh::GetMassCenter
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR ?gMassCenter@@3USTPoint3@@A+8, eax

; 243  :         std::cout<<"Mass Center: "<<gMassCenter<<std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ?gMassCenter@@3USTPoint3@@A	; gMassCenter
	push	OFFSET $SG147150
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z ; operator<<
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 244  :         gBoundingBox=STTriangleMesh::GetBoundingBox(gTriangleMeshes);

	push	OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?GetBoundingBox@STTriangleMesh@@SA?AU?$pair@USTPoint3@@U1@@std@@ABV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@3@@Z ; STTriangleMesh::GetBoundingBox
	add	esp, 8
	push	eax
	mov	ecx, OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A ; gBoundingBox
	call	??$?4USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAEAAU01@$$QAU01@@Z ; std::pair<STPoint3,STPoint3>::operator=<STPoint3,STPoint3,0>

; 245  :         std::cout<<"Bounding Box: "<<gBoundingBox.first<<" - "<<gBoundingBox.second<<std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A+12
	push	OFFSET $SG147151
	push	OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A ; gBoundingBox
	push	OFFSET $SG147152
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z ; operator<<
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z ; operator<<
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 246  :     }
; 247  :     else {

	jmp	SHORT $LN3@Setup
$LN2@Setup:

; 248  :         meshType = MeshType::Axis; // no mesh to draw in this case

	mov	DWORD PTR ?meshType@@3W4MeshType@@A, 1	; meshType

; 249  :         meshQueue.push(MeshType::Mesh);

	mov	DWORD PTR $T6[ebp], 0
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push

; 250  :         meshQueue.push(MeshType::Axis);

	mov	DWORD PTR $T5[ebp], 1
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push
$LN3@Setup:

; 251  :     }
; 252  :     CreateYourOwnMesh();

	call	?CreateYourOwnMesh@@YAXXZ		; CreateYourOwnMesh

; 253  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Setup@@YAXXZ$0:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$1:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$2:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$3:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$4:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T21[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$5:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Setup@@YAXXZ$6:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Setup@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?Setup@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Setup@@YAXXZ ENDP					; Setup
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
_id3$2 = -88						; size = 4
_id1$3 = -84						; size = 4
_farZ$ = -80						; size = 4
_rightX$ = -76						; size = 4
$T4 = -72						; size = 4
_id0$5 = -68						; size = 4
_id2$6 = -64						; size = 4
_s0$7 = -60						; size = 4
_t0$8 = -56						; size = 4
tv77 = -52						; size = 4
$T9 = -48						; size = 4
_x0$10 = -44						; size = 4
_z0$11 = -40						; size = 4
_nearZ$ = -36						; size = 4
_leftX$ = -32						; size = 4
_j$12 = -28						; size = 4
_i$13 = -24						; size = 4
_j$14 = -20						; size = 4
_i$15 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateYourOwnMesh@@YAXXZ PROC				; CreateYourOwnMesh

; 151  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateYourOwnMesh@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 152  :     float leftX   = -2.0f;

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _leftX$[ebp], xmm0

; 153  :     float rightX  = -leftX;

	movss	xmm0, DWORD PTR _leftX$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _rightX$[ebp], xmm0

; 154  :     float nearZ   = -2.0f;

	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _nearZ$[ebp], xmm0

; 155  :     float farZ    = -nearZ;

	movss	xmm0, DWORD PTR _nearZ$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _farZ$[ebp], xmm0

; 156  : 
; 157  :     gCoordAxisTriangleMesh= new STTriangleMesh();

	push	172					; 000000acH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN15@CreateYour
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0STTriangleMesh@@QAE@XZ		; STTriangleMesh::STTriangleMesh
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN16@CreateYour
$LN15@CreateYour:
	mov	DWORD PTR tv77[ebp], 0
$LN16@CreateYour:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A, ecx ; gCoordAxisTriangleMesh

; 158  :     for (int i = 0; i < TesselationDepth+1; i++){

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN4@CreateYour
$LN2@CreateYour:
	mov	edx, DWORD PTR _i$13[ebp]
	add	edx, 1
	mov	DWORD PTR _i$13[ebp], edx
$LN4@CreateYour:
	mov	eax, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	eax, 1
	cmp	DWORD PTR _i$13[ebp], eax
	jge	$LN3@CreateYour

; 159  :         for (int j = 0; j < TesselationDepth+1; j++) {

	mov	DWORD PTR _j$12[ebp], 0
	jmp	SHORT $LN7@CreateYour
$LN5@CreateYour:
	mov	ecx, DWORD PTR _j$12[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$12[ebp], ecx
$LN7@CreateYour:
	mov	edx, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	edx, 1
	cmp	DWORD PTR _j$12[ebp], edx
	jge	$LN6@CreateYour

; 160  :             float s0 = (float) i / (float) TesselationDepth;

	cvtsi2ss xmm0, DWORD PTR _i$13[ebp]
	cvtsi2ss xmm1, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	divss	xmm0, xmm1
	movss	DWORD PTR _s0$7[ebp], xmm0

; 161  :             float x0 =  s0 * (rightX - leftX) + leftX;

	movss	xmm0, DWORD PTR _rightX$[ebp]
	subss	xmm0, DWORD PTR _leftX$[ebp]
	mulss	xmm0, DWORD PTR _s0$7[ebp]
	addss	xmm0, DWORD PTR _leftX$[ebp]
	movss	DWORD PTR _x0$10[ebp], xmm0

; 162  :             float t0 = (float) j / (float) TesselationDepth;

	cvtsi2ss xmm0, DWORD PTR _j$12[ebp]
	cvtsi2ss xmm1, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	divss	xmm0, xmm1
	movss	DWORD PTR _t0$8[ebp], xmm0

; 163  :             float z0 = t0 * (farZ - nearZ) + nearZ;

	movss	xmm0, DWORD PTR _farZ$[ebp]
	subss	xmm0, DWORD PTR _nearZ$[ebp]
	mulss	xmm0, DWORD PTR _t0$8[ebp]
	addss	xmm0, DWORD PTR _nearZ$[ebp]
	movss	DWORD PTR _z0$11[ebp], xmm0

; 164  : 
; 165  :             gCoordAxisTriangleMesh->AddVertex(x0,(x0*x0+z0*z0)*0.0f,z0,s0,t0);

	push	ecx
	movss	xmm0, DWORD PTR _t0$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s0$7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _z0$11[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x0$10[ebp]
	mulss	xmm0, DWORD PTR _x0$10[ebp]
	movss	xmm1, DWORD PTR _z0$11[ebp]
	mulss	xmm1, DWORD PTR _z0$11[ebp]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@00000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x0$10[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	call	?AddVertex@STTriangleMesh@@QAEIMMMMM@Z	; STTriangleMesh::AddVertex

; 166  :         }

	jmp	$LN5@CreateYour
$LN6@CreateYour:

; 167  :     }

	jmp	$LN2@CreateYour
$LN3@CreateYour:

; 168  :     for (int i = 0; i < TesselationDepth; i++){

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN10@CreateYour
$LN8@CreateYour:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN10@CreateYour:
	mov	ecx, DWORD PTR _i$15[ebp]
	cmp	ecx, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	jge	$LN9@CreateYour

; 169  :         for (int j = 0; j < TesselationDepth; j++) {

	mov	DWORD PTR _j$14[ebp], 0
	jmp	SHORT $LN13@CreateYour
$LN11@CreateYour:
	mov	edx, DWORD PTR _j$14[ebp]
	add	edx, 1
	mov	DWORD PTR _j$14[ebp], edx
$LN13@CreateYour:
	mov	eax, DWORD PTR _j$14[ebp]
	cmp	eax, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	jge	$LN12@CreateYour

; 170  :             unsigned int id0=i*(TesselationDepth+1)+j;

	mov	ecx, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	ecx, 1
	imul	ecx, DWORD PTR _i$15[ebp]
	add	ecx, DWORD PTR _j$14[ebp]
	mov	DWORD PTR _id0$5[ebp], ecx

; 171  :             unsigned int id1=(i+1)*(TesselationDepth+1)+j;

	mov	edx, DWORD PTR _i$15[ebp]
	add	edx, 1
	mov	eax, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	eax, 1
	imul	edx, eax
	add	edx, DWORD PTR _j$14[ebp]
	mov	DWORD PTR _id1$3[ebp], edx

; 172  :             unsigned int id2=(i+1)*(TesselationDepth+1)+j+1;

	mov	ecx, DWORD PTR _i$15[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	edx, 1
	imul	ecx, edx
	mov	eax, DWORD PTR _j$14[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _id2$6[ebp], ecx

; 173  :             unsigned int id3=i*(TesselationDepth+1)+j+1;

	mov	edx, DWORD PTR ?TesselationDepth@@3HA	; TesselationDepth
	add	edx, 1
	imul	edx, DWORD PTR _i$15[ebp]
	mov	eax, DWORD PTR _j$14[ebp]
	lea	ecx, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _id3$2[ebp], ecx

; 174  :             gCoordAxisTriangleMesh->AddFace(id0,id2,id1);

	mov	edx, DWORD PTR _id1$3[ebp]
	push	edx
	mov	eax, DWORD PTR _id2$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _id0$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	call	?AddFace@STTriangleMesh@@QAEIIII@Z	; STTriangleMesh::AddFace

; 175  :             gCoordAxisTriangleMesh->AddFace(id0,id3,id2);

	mov	edx, DWORD PTR _id2$6[ebp]
	push	edx
	mov	eax, DWORD PTR _id3$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _id0$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	call	?AddFace@STTriangleMesh@@QAEIIII@Z	; STTriangleMesh::AddFace

; 176  :         }

	jmp	$LN11@CreateYour
$LN12@CreateYour:

; 177  :     }

	jmp	$LN8@CreateYour
$LN9@CreateYour:

; 178  :     gCoordAxisTriangleMesh->Build();

	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	call	?Build@STTriangleMesh@@QAE_NXZ		; STTriangleMesh::Build

; 179  :     gCoordAxisTriangleMesh->mMaterialAmbient[0]=0.2f;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+eax+68], xmm0

; 180  :     gCoordAxisTriangleMesh->mMaterialAmbient[1]=0.2f;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [eax+edx+68], xmm0

; 181  :     gCoordAxisTriangleMesh->mMaterialAmbient[2]=0.6f;

	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+ecx+68], xmm0

; 182  :     gCoordAxisTriangleMesh->mMaterialDiffuse[0]=0.2f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [edx+ecx+84], xmm0

; 183  :     gCoordAxisTriangleMesh->mMaterialDiffuse[1]=0.2f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR [ecx+eax+84], xmm0

; 184  :     gCoordAxisTriangleMesh->mMaterialDiffuse[2]=0.6f;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [eax+edx+84], xmm0

; 185  :     gCoordAxisTriangleMesh->mMaterialSpecular[0]=0.6f;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [eax+edx+100], xmm0

; 186  :     gCoordAxisTriangleMesh->mMaterialSpecular[1]=0.6f;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [edx+ecx+100], xmm0

; 187  :     gCoordAxisTriangleMesh->mMaterialSpecular[2]=0.6f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR [ecx+eax+100], xmm0

; 188  :     gCoordAxisTriangleMesh->mShininess=8.0f;

	mov	edx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [edx+116], xmm0

; 189  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateYourOwnMesh@@YAXXZ$0:
	push	172					; 000000acH
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?CreateYourOwnMesh@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?CreateYourOwnMesh@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateYourOwnMesh@@YAXXZ ENDP				; CreateYourOwnMesh
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 12
$T2 = -48						; size = 12
$T3 = -36						; size = 12
$T4 = -24						; size = 12
$T5 = -12						; size = 12
?resetUp@@YAXXZ PROC					; resetUp

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 138  :     mUp = STVector3(0.f,1.f,0.f);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	push	eax
	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 139  :     mRight = STVector3::Cross(mLookAt - mPosition, mUp);

	push	OFFSET ?mUp@@3USTVector3@@A		; mUp
	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??G@YA?AUSTVector3@@ABU0@0@Z		; operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?Cross@STVector3@@SA?AU1@ABU1@0@Z	; STVector3::Cross
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mRight@@3USTVector3@@A	; mRight
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 140  :     mRight.Normalize();

	mov	ecx, OFFSET ?mRight@@3USTVector3@@A	; mRight
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 141  :     mUp = STVector3::Cross(mRight, mLookAt - mPosition);

	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??G@YA?AUSTVector3@@ABU0@0@Z		; operator-
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ?mRight@@3USTVector3@@A		; mRight
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?Cross@STVector3@@SA?AU1@ABU1@0@Z	; STVector3::Cross
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 142  :     mUp.Normalize();

	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?resetUp@@YAXXZ ENDP					; resetUp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 12
$T2 = -24						; size = 12
$T3 = -12						; size = 12
?resetCamera@@YAXXZ PROC				; resetCamera

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 129  :     mLookAt=STVector3(0.f,0.f,0.f);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	push	eax
	mov	ecx, OFFSET ?mLookAt@@3USTVector3@@A	; mLookAt
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 130  :     mPosition=STVector3(0.f,5.f,15.f);

	push	ecx
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	push	eax
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 131  :     mUp=STVector3(0.f,1.f,0.f);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	push	eax
	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 132  : 
; 133  :     SetUpAndRight();

	call	?SetUpAndRight@@YAXXZ			; SetUpAndRight

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?resetCamera@@YAXXZ ENDP				; resetCamera
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 12
$T2 = -36						; size = 12
$T3 = -24						; size = 12
$T4 = -12						; size = 12
?SetUpAndRight@@YAXXZ PROC				; SetUpAndRight

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 121  :     mRight = STVector3::Cross(mLookAt - mPosition, mUp);

	push	OFFSET ?mUp@@3USTVector3@@A		; mUp
	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??G@YA?AUSTVector3@@ABU0@0@Z		; operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	?Cross@STVector3@@SA?AU1@ABU1@0@Z	; STVector3::Cross
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mRight@@3USTVector3@@A	; mRight
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 122  :     mRight.Normalize();

	mov	ecx, OFFSET ?mRight@@3USTVector3@@A	; mRight
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 123  :     mUp = STVector3::Cross(mRight, mLookAt - mPosition);

	push	OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	push	OFFSET ?mLookAt@@3USTVector3@@A		; mLookAt
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??G@YA?AUSTVector3@@ABU0@0@Z		; operator-
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ?mRight@@3USTVector3@@A		; mRight
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?Cross@STVector3@@SA?AU1@ABU1@0@Z	; STVector3::Cross
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	??4STVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator=

; 124  :     mUp.Normalize();

	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetUpAndRight@@YAXXZ ENDP				; SetUpAndRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
_TEXT	SEGMENT
tv81 = -28						; size = 4
$T1 = -24						; size = 4
tv75 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_id$5 = -4						; size = 4
?ClearGlobalMesh@@YAXXZ PROC				; ClearGlobalMesh

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 110  :     // remove the mesh
; 111  :     for(int id=0; id < (int)gTriangleMeshes.size();id++)

	mov	DWORD PTR _id$5[ebp], 0
	jmp	SHORT $LN4@ClearGloba
$LN2@ClearGloba:
	mov	eax, DWORD PTR _id$5[ebp]
	add	eax, 1
	mov	DWORD PTR _id$5[ebp], eax
$LN4@ClearGloba:
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR _id$5[ebp], eax
	jge	SHORT $LN3@ClearGloba

; 112  :         delete gTriangleMeshes[id];

	mov	ecx, DWORD PTR _id$5[ebp]
	push	ecx
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN7@ClearGloba
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GSTTriangleMesh@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN8@ClearGloba
$LN7@ClearGloba:
	mov	DWORD PTR tv75[ebp], 0
$LN8@ClearGloba:
	jmp	SHORT $LN2@ClearGloba
$LN3@ClearGloba:

; 113  :     if(gCoordAxisTriangleMesh != NULL)

	cmp	DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A, 0 ; gCoordAxisTriangleMesh
	je	SHORT $LN1@ClearGloba

; 114  :         delete gCoordAxisTriangleMesh;

	mov	ecx, DWORD PTR ?gCoordAxisTriangleMesh@@3PAVSTTriangleMesh@@A ; gCoordAxisTriangleMesh
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@ClearGloba
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSTTriangleMesh@@QAEPAXI@Z
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN1@ClearGloba
$LN9@ClearGloba:
	mov	DWORD PTR tv81[ebp], 0
$LN1@ClearGloba:

; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearGlobalMesh@@YAXXZ ENDP				; ClearGlobalMesh
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FmeshQueue@@YAXXZ
text$yd	SEGMENT
??__FmeshQueue@@YAXXZ PROC				; `dynamic atexit destructor for 'meshQueue'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	??1?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
	pop	ebp
	ret	0
??__FmeshQueue@@YAXXZ ENDP				; `dynamic atexit destructor for 'meshQueue''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmeshQueue@@YAXXZ
text$di	SEGMENT
??__EmeshQueue@@YAXXZ PROC				; `dynamic initializer for 'meshQueue'', COMDAT

; 101  : std::queue<MeshType> meshQueue;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?meshQueue@@3V?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@A ; meshQueue
	call	??0?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >
	push	OFFSET ??__FmeshQueue@@YAXXZ		; `dynamic atexit destructor for 'meshQueue''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EmeshQueue@@YAXXZ ENDP				; `dynamic initializer for 'meshQueue''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::~queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::~deque<enum MeshType,std::allocator<enum MeshType> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::~queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?pop@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::pop, COMDAT
; _this$ = ecx

; 136  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		c.pop_front();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_front

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXABW4MeshType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXABW4MeshType@@@Z PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push, COMDAT
; _this$ = ecx

; 131  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		c.push_back(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXABW4MeshType@@@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back

; 133  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXABW4MeshType@@@Z ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::front, COMDAT
; _this$ = ecx

; 111  : 		{	// return first element of mutable queue

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (c.front());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::front

; 113  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?front@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAW4MeshType@@XZ ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::front
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push, COMDAT
; _this$ = ecx

; 86   : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		c.push_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ; std::move<enum MeshType &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ??0?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 		: c()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::deque<enum MeshType,std::allocator<enum MeshType> >

; 34   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$queue@W4MeshType@@V?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >::queue<enum MeshType,std::deque<enum MeshType,std::allocator<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
__Offhigh$ = -28					; size = 4
tv79 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Offlo$ = 8						; size = 4
?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Orphan_off, COMDAT
; _this$ = ecx

; 1896 : 		{	// orphan iterators with specified offset(s)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1897 : 		size_type _Offhigh = this->_Myoff() + this->_Mysize() <= _Offlo + 1

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Offlo$[ebp]
	add	edx, 1
	cmp	ecx, edx
	ja	SHORT $LN10@Orphan_off
	mov	DWORD PTR tv79[ebp], -1
	jmp	SHORT $LN11@Orphan_off
$LN10@Orphan_off:
	mov	eax, DWORD PTR __Offlo$[ebp]
	mov	DWORD PTR tv79[ebp], eax
$LN11@Orphan_off:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR __Offhigh$[ebp], ecx

; 1898 : 			? (size_type)(-1) : _Offlo;
; 1899 : 		if (_Offlo == this->_Myoff())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	edx, DWORD PTR __Offlo$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Orphan_off

; 1900 : 			{
; 1901 : 			_Offlo = 0;

	mov	DWORD PTR __Offlo$[ebp], 0
$LN4@Orphan_off:

; 1902 : 			}
; 1903 : 
; 1904 : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1905 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getpfirst
	mov	DWORD PTR __Pnext$[ebp], eax

; 1906 : 		if (_Pnext != nullptr)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN5@Orphan_off
$LN2@Orphan_off:

; 1907 : 			{
; 1908 : 			while (*_Pnext != nullptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_off

; 1909 : 				{
; 1910 : 				if ((*_Pnext)->_Myoff < _Offlo
; 1911 : 					|| _Offhigh < (*_Pnext)->_Myoff)

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR __Offlo$[ebp]
	jb	SHORT $LN8@Orphan_off
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Offhigh$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN6@Orphan_off
$LN8@Orphan_off:

; 1912 : 					{
; 1913 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1914 : 					}
; 1915 : 				else

	jmp	SHORT $LN7@Orphan_off
$LN6@Orphan_off:

; 1916 : 					{	// orphan the iterator
; 1917 : 					(*_Pnext)->_Clrcont();

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1918 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN7@Orphan_off:

; 1919 : 					}
; 1920 : 				}

	jmp	SHORT $LN2@Orphan_off
$LN5@Orphan_off:

; 1921 : 			}
; 1922 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z$0:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Orphan_off
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Tidy@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Block$1 = -12						; size = 4
_this$ = -8						; size = 4
__Almap$ = -1						; size = 1
?_Tidy@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Tidy, COMDAT
; _this$ = ecx

; 1869 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1870 : 		_Alpty _Almap(this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<enum MeshType *>::allocator<enum MeshType *><enum MeshType>
$LN2@Tidy:

; 1871 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Tidy

; 1872 : 			{
; 1873 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_back

; 1874 : 			}

	jmp	SHORT $LN2@Tidy
$LN3@Tidy:

; 1875 : 
; 1876 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Block$1[ebp], ecx
$LN6@Tidy:
	cmp	DWORD PTR __Block$1[ebp], 0
	jbe	SHORT $LN5@Tidy

; 1877 : 			{	// free storage for a block and destroy pointer
; 1878 : 			if (this->_Map()[--_Block] != pointer())

	mov	edx, DWORD PTR __Block$1[ebp]
	sub	edx, 1
	mov	DWORD PTR __Block$1[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$1[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN7@Tidy

; 1879 : 				{	// free block and destroy its pointer
; 1880 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@W4MeshType@@@std@@QAEXQAW4MeshType@@I@Z ; std::allocator<enum MeshType>::deallocate

; 1881 : 				_Alpty_traits::destroy(_Almap, _STD addressof(this->_Map()[_Block]));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$1[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$addressof@PAW4MeshType@@@std@@YAPAPAW4MeshType@@AAPAW41@@Z ; std::addressof<enum MeshType *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __Almap$[ebp]
	push	edx
	call	??$destroy@PAW4MeshType@@@?$_Default_allocator_traits@V?$allocator@PAW4MeshType@@@std@@@std@@SAXAAV?$allocator@PAW4MeshType@@@1@QAPAW4MeshType@@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType *> >::destroy<enum MeshType *>
	add	esp, 8
$LN7@Tidy:

; 1882 : 				}
; 1883 : 			}

	jmp	SHORT $LN6@Tidy
$LN5@Tidy:

; 1884 : 
; 1885 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Tidy

; 1886 : 			{
; 1887 : 			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for map

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z ; std::allocator<enum MeshType *>::deallocate
$LN8@Tidy:

; 1888 : 			}
; 1889 : 
; 1890 : 		this->_Mapsize() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	DWORD PTR [eax], 0

; 1891 : 		this->_Map() = _Mapptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	DWORD PTR [eax], 0

; 1892 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv318 = -32						; size = 4
tv85 = -28						; size = 4
__Newmap$ = -24						; size = 4
__Newsize$ = -20					; size = 4
__Myboff$ = -16						; size = 4
__Myptr$ = -12						; size = 4
_this$ = -8						; size = 4
__Almap$ = -1						; size = 1
__Count$ = 8						; size = 4
?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Growmap, COMDAT
; _this$ = ecx

; 1811 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1812 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1813 : 			"The _Xlen() test should always be performed.");
; 1814 : 
; 1815 : 		_Alpty _Almap(this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0W4MeshType@@@?$allocator@PAW4MeshType@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<enum MeshType *>::allocator<enum MeshType *><enum MeshType>

; 1816 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	cmp	DWORD PTR [eax], 0
	jbe	SHORT $LN10@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN11@Growmap
$LN10@Growmap:
	mov	DWORD PTR tv85[ebp], 1
$LN11@Growmap:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR __Newsize$[ebp], ecx
$LN2@Growmap:

; 1817 : 		while (_Newsize - this->_Mapsize() < _Count
; 1818 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Count$[ebp]
	jb	SHORT $LN4@Growmap
	cmp	DWORD PTR __Newsize$[ebp], 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1819 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1820 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBEIXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::max_size
	shr	eax, 2
	sub	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Growmap

; 1821 : 				{
; 1822 : 				_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Xlen
$LN5@Growmap:

; 1823 : 				}
; 1824 : 
; 1825 : 			_Newsize *= 2;

	mov	eax, DWORD PTR __Newsize$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1826 : 			}

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1827 : 		_Count = _Newsize - this->_Mapsize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Count$[ebp], ecx

; 1828 : 
; 1829 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	edx, DWORD PTR [eax]
	shr	edx, 2
	mov	DWORD PTR __Myboff$[ebp], edx

; 1830 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$allocator@PAW4MeshType@@@std@@QAEPAPAW4MeshType@@I@Z ; std::allocator<enum MeshType *>::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1831 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	ecx, DWORD PTR __Myboff$[ebp]
	mov	edx, DWORD PTR __Newmap$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Myptr$[ebp], eax

; 1832 : 
; 1833 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1834 : 			this->_Map() + this->_Mapsize(),
; 1835 : 			_Myptr, _Almap);	// copy initial to end
; 1836 : 		if (_Myboff <= _Count)

	mov	eax, DWORD PTR __Myboff$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN6@Growmap

; 1837 : 			{	// increment greater than offset of initial block
; 1838 : 			_Myptr = _Uninitialized_copy(this->_Map(),

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1839 : 				this->_Map() + _Myboff,
; 1840 : 				_Myptr, _Almap);	// copy rest of old
; 1841 : 			_Uninitialized_value_construct_n(_Myptr, _Count - _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Myboff$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	call	??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
	add	esp, 12					; 0000000cH

; 1842 : 				_Almap);	// clear suffix of new
; 1843 : 			_Uninitialized_value_construct_n(_Newmap, _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myboff$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newmap$[ebp]
	push	eax
	call	??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
	add	esp, 12					; 0000000cH

; 1844 : 				_Almap);	// clear prefix of new
; 1845 : 			}
; 1846 : 		else

	jmp	SHORT $LN7@Growmap
$LN6@Growmap:

; 1847 : 			{	// increment not greater than offset of initial block
; 1848 : 			_Uninitialized_copy(this->_Map(),

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H

; 1849 : 				this->_Map() + _Count,
; 1850 : 				_Myptr, _Almap);	// copy more old
; 1851 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$_Uninitialized_copy@PAPAW4MeshType@@PAPAW41@V?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_copy<enum MeshType * *,enum MeshType * *,std::allocator<enum MeshType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1852 : 				this->_Map() + _Myboff,
; 1853 : 				_Newmap, _Almap);	// copy rest of old
; 1854 : 			_Uninitialized_value_construct_n(_Myptr, _Count,

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_value_construct_n@PAPAW4MeshType@@IV?$allocator@PAW4MeshType@@@std@@@std@@YAPAPAW4MeshType@@PAPAW41@IAAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum MeshType * *,unsigned int,std::allocator<enum MeshType *> >
	add	esp, 12					; 0000000cH
$LN7@Growmap:

; 1855 : 				_Almap);	// clear rest to initial block
; 1856 : 			}
; 1857 : 
; 1858 : 		_Destroy_range(this->_Map() + _Myboff, this->_Map() + this->_Mapsize(), _Almap);

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Destroy_range@V?$allocator@PAW4MeshType@@@std@@@std@@YAXPAPAW4MeshType@@0AAV?$allocator@PAW4MeshType@@@0@@Z ; std::_Destroy_range<std::allocator<enum MeshType *> >
	add	esp, 12					; 0000000cH

; 1859 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Growmap

; 1860 : 			{
; 1861 : 			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for old

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z ; std::allocator<enum MeshType *>::deallocate
$LN8@Growmap:

; 1862 : 			}
; 1863 : 
; 1864 : 		this->_Map() = _Newmap;	// point at new

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [eax], ecx

; 1865 : 		this->_Mapsize() += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	DWORD PTR tv318[ebp], eax
	mov	edx, DWORD PTR tv318[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR tv318[ebp]
	mov	DWORD PTR [ecx], eax
$LN9@Growmap:

; 1866 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Xlen@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Xlen, COMDAT
; _this$ = ecx

; 1801 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1802 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1803 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?pop_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -16						; size = 4
tv165 = -12						; size = 4
__Newoff$2 = -8						; size = 4
_this$ = -4						; size = 4
?pop_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_back
$LN4@pop_back:

; 1497 : 			{
; 1498 : 			_STL_REPORT_ERROR("deque empty before pop");

	push	OFFSET ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1498					; 000005daH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN9@pop_back
	int	3
$LN9@pop_back:
	push	0
	push	1498					; 000005daH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1JC@FMAFMAOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
	push	OFFSET ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN4@pop_back

; 1499 : 			}
; 1500 : 		else

	jmp	$LN1@pop_back
$LN5@pop_back:

; 1501 : 			{	// something to erase, do it
; 1502 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx-1]
	mov	DWORD PTR __Newoff$2[ebp], eax

; 1503 : 			_Orphan_off(_Newoff);

	mov	ecx, DWORD PTR __Newoff$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Orphan_off

; 1504 : 			size_type _Block = this->_Getblock(_Newoff);

	mov	edx, DWORD PTR __Newoff$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
	mov	DWORD PTR __Block$1[ebp], eax

; 1505 : 			_Alty_traits::destroy(this->_Getal(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$2[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ; std::_Unfancy<enum MeshType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	call	??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::destroy<enum MeshType>
	add	esp, 8

; 1506 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1507 : 			if (--this->_Mysize() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	DWORD PTR tv165[ebp], eax
	mov	eax, DWORD PTR tv165[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR tv165[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@pop_back

; 1508 : 				{
; 1509 : 				this->_Myoff() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	DWORD PTR [eax], 0
$LN1@pop_back:

; 1510 : 				}
; 1511 : 			}
; 1512 : 
; 1513 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1514 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1515 : 		size_type _Block = this->_Getblock(_Newoff);
; 1516 : 		_Alty_traits::destroy(this->_Getal(),
; 1517 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1518 : 		if (--this->_Mysize() == 0)
; 1519 : 			{
; 1520 : 			this->_Myoff() = 0;
; 1521 : 			}
; 1522 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1523 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXABW4MeshType@@@Z
_TEXT	SEGMENT
tv226 = -20						; size = 4
__Newoff$ = -16						; size = 4
tv147 = -12						; size = 4
__Block$ = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXABW4MeshType@@@Z PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back, COMDAT
; _this$ = ecx

; 1485 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all

; 1487 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	edx, DWORD PTR [eax]
	add	edx, 4
	shr	edx, 2
	cmp	DWORD PTR [esi], edx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Growmap
$LN2@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*4-1]
	mov	edx, DWORD PTR tv147[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	edx, DWORD PTR __Newoff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN3@push_back
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z ; std::allocator<enum MeshType>::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+eax*4], esi
$LN3@push_back:

; 1488 : 		_Alty_traits::construct(this->_Getal(),

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ; std::_Unfancy<enum MeshType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	call	??$construct@W4MeshType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@ABW43@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType const &>
	add	esp, 12					; 0000000cH

; 1489 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ), _Val);
; 1490 : 		_PUSH_BACK_END;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	DWORD PTR tv226[ebp], eax
	mov	eax, DWORD PTR tv226[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR [edx], ecx

; 1491 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXABW4MeshType@@@Z ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?pop_front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -16						; size = 4
tv184 = -12						; size = 4
tv169 = -8						; size = 4
_this$ = -4						; size = 4
?pop_front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_front, COMDAT
; _this$ = ecx

; 1447 : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1448 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1449 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_front
$LN4@pop_front:

; 1450 : 			{
; 1451 : 			_STL_REPORT_ERROR("deque empty before pop");

	push	OFFSET ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1451					; 000005abH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN10@pop_front
	int	3
$LN10@pop_front:
	push	0
	push	1451					; 000005abH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1JE@GOCCMDDF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
	push	OFFSET ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN4@pop_front

; 1452 : 			}
; 1453 : 		else

	jmp	$LN1@pop_front
$LN5@pop_front:

; 1454 : 			{	// something to erase, do it
; 1455 : 			_Orphan_off(this->_Myoff());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IBEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Orphan_off

; 1456 : 			size_type _Block = this->_Getblock(this->_Myoff());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
	mov	DWORD PTR __Block$1[ebp], eax

; 1457 : 			_Alty_traits::destroy(this->_Getal(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [esi+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ; std::_Unfancy<enum MeshType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	call	??$destroy@W4MeshType@@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::destroy<enum MeshType>
	add	esp, 8

; 1458 : 				_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1459 : 			if (--this->_Mysize() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR tv169[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@pop_front

; 1460 : 				{
; 1461 : 				this->_Myoff() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	DWORD PTR [eax], 0

; 1462 : 				}
; 1463 : 			else

	jmp	SHORT $LN1@pop_front
$LN7@pop_front:

; 1464 : 				{
; 1465 : 				++this->_Myoff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR tv184[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR [eax], edx
$LN1@pop_front:

; 1466 : 				}
; 1467 : 			}
; 1468 : 
; 1469 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1470 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1471 : 		_Alty_traits::destroy(this->_Getal(),
; 1472 : 			_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1473 : 		if (--this->_Mysize() == 0)
; 1474 : 			{
; 1475 : 			this->_Myoff() = 0;
; 1476 : 			}
; 1477 : 		else
; 1478 : 			{
; 1479 : 			++this->_Myoff();
; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEXXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::pop_front
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 12
$T3 = -28						; size = 4
tv72 = -24						; size = 4
tv73 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::front, COMDAT
; _this$ = ecx

; 1418 : 		{	// return first element of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1419 : 		return (*begin());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::begin
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv72[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QBEAAW4MeshType@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::operator*
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]

; 1420 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?front@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEAAW4MeshType@@XZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::front
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty, COMDAT
; _this$ = ecx

; 1376 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1377 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv71[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv71[ebp]

; 1378 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBE_NXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?max_size@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBEIXZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::max_size, COMDAT
; _this$ = ecx

; 1371 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1372 : 		return (_Alty_traits::max_size(this->_Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAIABV?$allocator@W4MeshType@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::max_size
	add	esp, 4

; 1373 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QBEIXZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::begin, COMDAT
; _this$ = ecx

; 1233 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1234 : 		return (iterator(this->_Myoff(), _STD addressof(this->_Get_data())));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	push	eax
	call	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1235 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ:
	mov	eax, OFFSET __ehfuncinfo$?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@2@XZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::begin
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::~deque<enum MeshType,std::allocator<enum MeshType> >, COMDAT
; _this$ = ecx

; 1192 : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1193 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXXZ ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Tidy

; 1194 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::~_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::~deque<enum MeshType,std::allocator<enum MeshType> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEX$$QAW4MeshType@@@Z
_TEXT	SEGMENT
tv228 = -20						; size = 4
__Newoff$ = -16						; size = 4
tv147 = -12						; size = 4
__Block$ = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEX$$QAW4MeshType@@@Z PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back, COMDAT
; _this$ = ecx

; 1103 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all

; 1105 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	edx, DWORD PTR [eax]
	add	edx, 4
	shr	edx, 2
	cmp	DWORD PTR [esi], edx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@IAEXI@Z ; std::deque<enum MeshType,std::allocator<enum MeshType> >::_Growmap
$LN2@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*4-1]
	mov	edx, DWORD PTR tv147[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	edx, DWORD PTR __Newoff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN3@push_back
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z ; std::allocator<enum MeshType>::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+eax*4], esi
$LN3@push_back:

; 1106 : 		_Alty_traits::construct(this->_Getal(),

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$move@AAW4MeshType@@@std@@YA$$QAW4MeshType@@AAW41@@Z ; std::move<enum MeshType &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4MeshType@@@std@@YAPAW4MeshType@@PAW41@@Z ; std::_Unfancy<enum MeshType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	call	??$construct@W4MeshType@@W41@@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAXAAV?$allocator@W4MeshType@@@1@QAW4MeshType@@$$QAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::construct<enum MeshType,enum MeshType>
	add	esp, 12					; 0000000cH

; 1107 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ),
; 1108 : 			_STD move(_Val));
; 1109 : 		_PUSH_BACK_END;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
	mov	DWORD PTR tv228[ebp], eax
	mov	eax, DWORD PTR tv228[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv228[ebp]
	mov	DWORD PTR [edx], ecx

; 1110 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAEX$$QAW4MeshType@@@Z ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ PROC ; std::deque<enum MeshType,std::allocator<enum MeshType> >::deque<enum MeshType,std::allocator<enum MeshType> >, COMDAT
; _this$ = ecx

; 930  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >

; 931  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@QAE@XZ ENDP ; std::deque<enum MeshType,std::allocator<enum MeshType> >::deque<enum MeshType,std::allocator<enum MeshType> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 303  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$allocator@W4MeshType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$allocator@W4MeshType@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 298  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 293  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Getblock, COMDAT
; _this$ = ecx

; 688  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 690  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Off$[ebp]
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	and	eax, edx

; 691  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Deque_val<std::_Deque_simple_types<enum MeshType> >, COMDAT
; _this$ = ecx

; 684  : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 680  : 		: _Map(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 681  : 		_Mapsize(0),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 682  : 		_Myoff(0),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 683  : 		_Mysize(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 685  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Deque_val<std::_Deque_simple_types<enum MeshType> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize, COMDAT
; _this$ = ecx

; 882  : 		{	// return const reference to _Mysize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 883  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 16					; 00000010H

; 884  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize, COMDAT
; _this$ = ecx

; 877  : 		{	// return reference to _Mysize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 16					; 00000010H

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff, COMDAT
; _this$ = ecx

; 872  : 		{	// return const reference to _Myoff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 		return (_Get_data()._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 12					; 0000000cH

; 874  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff, COMDAT
; _this$ = ecx

; 867  : 		{	// return reference to _Myoff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 868  : 		return (_Get_data()._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 12					; 0000000cH

; 869  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize, COMDAT
; _this$ = ecx

; 857  : 		{	// return reference to _Mapsize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		return (_Get_data()._Mapsize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 8

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map, COMDAT
; _this$ = ecx

; 847  : 		{	// return reference to _Map

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 848  : 		return (_Get_data()._Map);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	add	eax, 4

; 849  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAPAW4MeshType@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Map
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data, COMDAT
; _this$ = ecx

; 842  : 		{	// return const reference to _Deque_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second

; 844  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data, COMDAT
; _this$ = ecx

; 837  : 		{	// return reference to _Deque_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 838  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_second

; 839  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$allocator@W4MeshType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$allocator@W4MeshType@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal, COMDAT
; _this$ = ecx

; 832  : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 833  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first

; 834  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$allocator@W4MeshType@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal, COMDAT
; _this$ = ecx

; 827  : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Get_first

; 829  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 817  : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 818  : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 819  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy, COMDAT
; _this$ = ecx

; 807  : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 808  : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data

; 809  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 802  : 		{	// get address of iterator chain

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 803  : 		return (_Get_data()._Getpfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	mov	ecx, eax
	call	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 804  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum MeshType>

; 795  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Orphan_all

; 796  : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 797  : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Proxy_allocator$[ebp]
	push	eax
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
	add	esp, 8

; 798  : 		_Myproxy() = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 799  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 785  : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$allocator@W4MeshType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0W4MeshType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4MeshType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum MeshType>

; 787  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 788  : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 789  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	push	eax
	call	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum MeshType> > >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi

; 790  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::~_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >, COMDAT
; _this$ = ecx

; 744  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Free_proxy

; 746  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::~_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >, COMDAT
; _this$ = ecx

; 730  : 		{	// default construct allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 		: _Mypair(_Zero_then_variadic_args_t())

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@W4MeshType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1>::_Compressed_pair<std::allocator<enum MeshType>,std::_Deque_val<std::_Deque_simple_types<enum MeshType> >,1><>

; 731  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Alloc_proxy

; 732  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock, COMDAT
; _this$ = ecx

; 724  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 		return (_Get_data()._Getblock(_Off));

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Get_data
	mov	ecx, eax
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4MeshType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum MeshType> >::_Getblock

; 726  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4MeshType@@V?$allocator@W4MeshType@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum MeshType,std::allocator<enum MeshType> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAW4MeshType@@@std@@QAEPAPAW4MeshType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAW4MeshType@@@std@@QAEPAPAW4MeshType@@I@Z PROC ; std::allocator<enum MeshType *>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAW4MeshType@@@std@@QAEPAPAW4MeshType@@I@Z ENDP ; std::allocator<enum MeshType *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z PROC ; std::allocator<enum MeshType *>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAW4MeshType@@@std@@QAEXQAPAW4MeshType@@I@Z ENDP ; std::allocator<enum MeshType *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAIABV?$allocator@W4MeshType@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAIABV?$allocator@W4MeshType@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::max_size, COMDAT

; 891  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	eax, 1073741823				; 3fffffffH

; 893  : 		}

	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@W4MeshType@@@std@@@std@@SAIABV?$allocator@W4MeshType@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum MeshType> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z PROC ; std::allocator<enum MeshType>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@W4MeshType@@@std@@QAEPAW4MeshType@@I@Z ENDP ; std::allocator<enum MeshType>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@W4MeshType@@@std@@QAEXQAW4MeshType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@W4MeshType@@@std@@QAEXQAW4MeshType@@I@Z PROC ; std::allocator<enum MeshType>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@W4MeshType@@@std@@QAEXQAW4MeshType@@I@Z ENDP ; std::allocator<enum MeshType>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@W4MeshType@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@W4MeshType@@@std@@QAE@XZ PROC		; std::allocator<enum MeshType>::allocator<enum MeshType>, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@W4MeshType@@@std@@QAE@XZ ENDP		; std::allocator<enum MeshType>::allocator<enum MeshType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EgBoundingBox@@YAXXZ
text$di	SEGMENT
??__EgBoundingBox@@YAXXZ PROC				; `dynamic initializer for 'gBoundingBox'', COMDAT

; 97   : std::pair<STPoint3,STPoint3> gBoundingBox;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gBoundingBox@@3U?$pair@USTPoint3@@U1@@std@@A ; gBoundingBox
	call	??$?0USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAE@XZ ; std::pair<STPoint3,STPoint3>::pair<STPoint3,STPoint3><STPoint3,STPoint3,0>
	pop	ebp
	ret	0
??__EgBoundingBox@@YAXXZ ENDP				; `dynamic initializer for 'gBoundingBox''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$?0USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?0USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAE@XZ PROC ; std::pair<STPoint3,STPoint3>::pair<STPoint3,STPoint3><STPoint3,STPoint3,0>, COMDAT
; _this$ = ecx

; 111  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 		: first(), second()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0STPoint3@@QAE@XZ			; STPoint3::STPoint3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0STPoint3@@QAE@XZ			; STPoint3::STPoint3

; 112  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??$?0USTPoint3@@U0@$0A@@?$pair@USTPoint3@@U1@@std@@QAE@XZ ENDP ; std::pair<STPoint3,STPoint3>::pair<STPoint3,STPoint3><STPoint3,STPoint3,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EgMassCenter@@YAXXZ
text$di	SEGMENT
??__EgMassCenter@@YAXXZ PROC				; `dynamic initializer for 'gMassCenter'', COMDAT

; 96   : STPoint3 gMassCenter;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gMassCenter@@3USTPoint3@@A	; gMassCenter
	call	??0STPoint3@@QAE@XZ			; STPoint3::STPoint3
	pop	ebp
	ret	0
??__EgMassCenter@@YAXXZ ENDP				; `dynamic initializer for 'gMassCenter''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FgTriangleMeshes@@YAXXZ
text$yd	SEGMENT
??__FgTriangleMeshes@@YAXXZ PROC			; `dynamic atexit destructor for 'gTriangleMeshes'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
	pop	ebp
	ret	0
??__FgTriangleMeshes@@YAXXZ ENDP			; `dynamic atexit destructor for 'gTriangleMeshes''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EgTriangleMeshes@@YAXXZ
text$di	SEGMENT
??__EgTriangleMeshes@@YAXXZ PROC			; `dynamic initializer for 'gTriangleMeshes'', COMDAT

; 95   : std::vector<STTriangleMesh*> gTriangleMeshes;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?gTriangleMeshes@@3V?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@A ; gTriangleMeshes
	call	??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
	push	OFFSET ??__FgTriangleMeshes@@YAXXZ	; `dynamic atexit destructor for 'gTriangleMeshes''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EgTriangleMeshes@@YAXXZ ENDP			; `dynamic initializer for 'gTriangleMeshes''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FtextureQueue@@YAXXZ
text$yd	SEGMENT
??__FtextureQueue@@YAXXZ PROC				; `dynamic atexit destructor for 'textureQueue'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	??1?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
	pop	ebp
	ret	0
??__FtextureQueue@@YAXXZ ENDP				; `dynamic atexit destructor for 'textureQueue''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EtextureQueue@@YAXXZ
text$di	SEGMENT
??__EtextureQueue@@YAXXZ PROC				; `dynamic initializer for 'textureQueue'', COMDAT

; 92   : std::queue<TextureType> textureQueue;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?textureQueue@@3V?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@A ; textureQueue
	call	??0?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >
	push	OFFSET ??__FtextureQueue@@YAXXZ		; `dynamic atexit destructor for 'textureQueue''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EtextureQueue@@YAXXZ ENDP				; `dynamic initializer for 'textureQueue''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::~queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::~deque<enum TextureType,std::allocator<enum TextureType> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::~queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?pop@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::pop, COMDAT
; _this$ = ecx

; 136  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		c.pop_front();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_front

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::pop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXABW4TextureType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXABW4TextureType@@@Z PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push, COMDAT
; _this$ = ecx

; 131  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		c.push_back(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXABW4TextureType@@@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back

; 133  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXABW4TextureType@@@Z ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::front, COMDAT
; _this$ = ecx

; 111  : 		{	// return first element of mutable queue

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (c.front());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::front

; 113  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?front@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAW4TextureType@@XZ ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::front
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push, COMDAT
; _this$ = ecx

; 86   : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		c.push_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ; std::move<enum TextureType &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\queue
;	COMDAT ??0?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 		: c()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::deque<enum TextureType,std::allocator<enum TextureType> >

; 34   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$queue@W4TextureType@@V?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >::queue<enum TextureType,std::deque<enum TextureType,std::allocator<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z
_TEXT	SEGMENT
__Lock$ = -32						; size = 4
__Offhigh$ = -28					; size = 4
tv79 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Offlo$ = 8						; size = 4
?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Orphan_off, COMDAT
; _this$ = ecx

; 1896 : 		{	// orphan iterators with specified offset(s)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1897 : 		size_type _Offhigh = this->_Myoff() + this->_Mysize() <= _Offlo + 1

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Offlo$[ebp]
	add	edx, 1
	cmp	ecx, edx
	ja	SHORT $LN10@Orphan_off
	mov	DWORD PTR tv79[ebp], -1
	jmp	SHORT $LN11@Orphan_off
$LN10@Orphan_off:
	mov	eax, DWORD PTR __Offlo$[ebp]
	mov	DWORD PTR tv79[ebp], eax
$LN11@Orphan_off:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR __Offhigh$[ebp], ecx

; 1898 : 			? (size_type)(-1) : _Offlo;
; 1899 : 		if (_Offlo == this->_Myoff())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	edx, DWORD PTR __Offlo$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Orphan_off

; 1900 : 			{
; 1901 : 			_Offlo = 0;

	mov	DWORD PTR __Offlo$[ebp], 0
$LN4@Orphan_off:

; 1902 : 			}
; 1903 : 
; 1904 : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1905 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getpfirst
	mov	DWORD PTR __Pnext$[ebp], eax

; 1906 : 		if (_Pnext != nullptr)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN5@Orphan_off
$LN2@Orphan_off:

; 1907 : 			{
; 1908 : 			while (*_Pnext != nullptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_off

; 1909 : 				{
; 1910 : 				if ((*_Pnext)->_Myoff < _Offlo
; 1911 : 					|| _Offhigh < (*_Pnext)->_Myoff)

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR __Offlo$[ebp]
	jb	SHORT $LN8@Orphan_off
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Offhigh$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN6@Orphan_off
$LN8@Orphan_off:

; 1912 : 					{
; 1913 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1914 : 					}
; 1915 : 				else

	jmp	SHORT $LN7@Orphan_off
$LN6@Orphan_off:

; 1916 : 					{	// orphan the iterator
; 1917 : 					(*_Pnext)->_Clrcont();

	mov	edx, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1918 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN7@Orphan_off:

; 1919 : 					}
; 1920 : 				}

	jmp	SHORT $LN2@Orphan_off
$LN5@Orphan_off:

; 1921 : 			}
; 1922 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z$0:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Orphan_off
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Tidy@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Block$1 = -12						; size = 4
_this$ = -8						; size = 4
__Almap$ = -1						; size = 1
?_Tidy@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Tidy, COMDAT
; _this$ = ecx

; 1869 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1870 : 		_Alpty _Almap(this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<enum TextureType *>::allocator<enum TextureType *><enum TextureType>
$LN2@Tidy:

; 1871 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Tidy

; 1872 : 			{
; 1873 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_back

; 1874 : 			}

	jmp	SHORT $LN2@Tidy
$LN3@Tidy:

; 1875 : 
; 1876 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Block$1[ebp], ecx
$LN6@Tidy:
	cmp	DWORD PTR __Block$1[ebp], 0
	jbe	SHORT $LN5@Tidy

; 1877 : 			{	// free storage for a block and destroy pointer
; 1878 : 			if (this->_Map()[--_Block] != pointer())

	mov	edx, DWORD PTR __Block$1[ebp]
	sub	edx, 1
	mov	DWORD PTR __Block$1[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$1[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $LN7@Tidy

; 1879 : 				{	// free block and destroy its pointer
; 1880 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@W4TextureType@@@std@@QAEXQAW4TextureType@@I@Z ; std::allocator<enum TextureType>::deallocate

; 1881 : 				_Alpty_traits::destroy(_Almap, _STD addressof(this->_Map()[_Block]));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$1[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$addressof@PAW4TextureType@@@std@@YAPAPAW4TextureType@@AAPAW41@@Z ; std::addressof<enum TextureType *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __Almap$[ebp]
	push	edx
	call	??$destroy@PAW4TextureType@@@?$_Default_allocator_traits@V?$allocator@PAW4TextureType@@@std@@@std@@SAXAAV?$allocator@PAW4TextureType@@@1@QAPAW4TextureType@@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType *> >::destroy<enum TextureType *>
	add	esp, 8
$LN7@Tidy:

; 1882 : 				}
; 1883 : 			}

	jmp	SHORT $LN6@Tidy
$LN5@Tidy:

; 1884 : 
; 1885 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Tidy

; 1886 : 			{
; 1887 : 			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for map

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z ; std::allocator<enum TextureType *>::deallocate
$LN8@Tidy:

; 1888 : 			}
; 1889 : 
; 1890 : 		this->_Mapsize() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	DWORD PTR [eax], 0

; 1891 : 		this->_Map() = _Mapptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	DWORD PTR [eax], 0

; 1892 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv318 = -32						; size = 4
tv85 = -28						; size = 4
__Newmap$ = -24						; size = 4
__Newsize$ = -20					; size = 4
__Myboff$ = -16						; size = 4
__Myptr$ = -12						; size = 4
_this$ = -8						; size = 4
__Almap$ = -1						; size = 1
__Count$ = 8						; size = 4
?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Growmap, COMDAT
; _this$ = ecx

; 1811 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1812 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1813 : 			"The _Xlen() test should always be performed.");
; 1814 : 
; 1815 : 		_Alpty _Almap(this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	??$?0W4TextureType@@@?$allocator@PAW4TextureType@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<enum TextureType *>::allocator<enum TextureType *><enum TextureType>

; 1816 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	cmp	DWORD PTR [eax], 0
	jbe	SHORT $LN10@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN11@Growmap
$LN10@Growmap:
	mov	DWORD PTR tv85[ebp], 1
$LN11@Growmap:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR __Newsize$[ebp], ecx
$LN2@Growmap:

; 1817 : 		while (_Newsize - this->_Mapsize() < _Count
; 1818 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Count$[ebp]
	jb	SHORT $LN4@Growmap
	cmp	DWORD PTR __Newsize$[ebp], 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1819 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1820 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBEIXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::max_size
	shr	eax, 2
	sub	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Growmap

; 1821 : 				{
; 1822 : 				_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Xlen
$LN5@Growmap:

; 1823 : 				}
; 1824 : 
; 1825 : 			_Newsize *= 2;

	mov	eax, DWORD PTR __Newsize$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 1826 : 			}

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1827 : 		_Count = _Newsize - this->_Mapsize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Count$[ebp], ecx

; 1828 : 
; 1829 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	edx, DWORD PTR [eax]
	shr	edx, 2
	mov	DWORD PTR __Myboff$[ebp], edx

; 1830 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?allocate@?$allocator@PAW4TextureType@@@std@@QAEPAPAW4TextureType@@I@Z ; std::allocator<enum TextureType *>::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1831 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	ecx, DWORD PTR __Myboff$[ebp]
	mov	edx, DWORD PTR __Newmap$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Myptr$[ebp], eax

; 1832 : 
; 1833 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1834 : 			this->_Map() + this->_Mapsize(),
; 1835 : 			_Myptr, _Almap);	// copy initial to end
; 1836 : 		if (_Myboff <= _Count)

	mov	eax, DWORD PTR __Myboff$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN6@Growmap

; 1837 : 			{	// increment greater than offset of initial block
; 1838 : 			_Myptr = _Uninitialized_copy(this->_Map(),

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1839 : 				this->_Map() + _Myboff,
; 1840 : 				_Myptr, _Almap);	// copy rest of old
; 1841 : 			_Uninitialized_value_construct_n(_Myptr, _Count - _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Myboff$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	call	??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
	add	esp, 12					; 0000000cH

; 1842 : 				_Almap);	// clear suffix of new
; 1843 : 			_Uninitialized_value_construct_n(_Newmap, _Myboff,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myboff$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newmap$[ebp]
	push	eax
	call	??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
	add	esp, 12					; 0000000cH

; 1844 : 				_Almap);	// clear prefix of new
; 1845 : 			}
; 1846 : 		else

	jmp	SHORT $LN7@Growmap
$LN6@Growmap:

; 1847 : 			{	// increment not greater than offset of initial block
; 1848 : 			_Uninitialized_copy(this->_Map(),

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H

; 1849 : 				this->_Map() + _Count,
; 1850 : 				_Myptr, _Almap);	// copy more old
; 1851 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	ecx, DWORD PTR __Almap$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Myboff$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$_Uninitialized_copy@PAPAW4TextureType@@PAPAW41@V?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@QAPAW41@0PAPAW41@AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_copy<enum TextureType * *,enum TextureType * *,std::allocator<enum TextureType *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1852 : 				this->_Map() + _Myboff,
; 1853 : 				_Newmap, _Almap);	// copy rest of old
; 1854 : 			_Uninitialized_value_construct_n(_Myptr, _Count,

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Myptr$[ebp]
	push	edx
	call	??$_Uninitialized_value_construct_n@PAPAW4TextureType@@IV?$allocator@PAW4TextureType@@@std@@@std@@YAPAPAW4TextureType@@PAPAW41@IAAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Uninitialized_value_construct_n<enum TextureType * *,unsigned int,std::allocator<enum TextureType *> >
	add	esp, 12					; 0000000cH
$LN7@Growmap:

; 1855 : 				_Almap);	// clear rest to initial block
; 1856 : 			}
; 1857 : 
; 1858 : 		_Destroy_range(this->_Map() + _Myboff, this->_Map() + this->_Mapsize(), _Almap);

	lea	eax, DWORD PTR __Almap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$_Destroy_range@V?$allocator@PAW4TextureType@@@std@@@std@@YAXPAPAW4TextureType@@0AAV?$allocator@PAW4TextureType@@@0@@Z ; std::_Destroy_range<std::allocator<enum TextureType *> >
	add	esp, 12					; 0000000cH

; 1859 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Growmap

; 1860 : 			{
; 1861 : 			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for old

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR __Almap$[ebp]
	call	?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z ; std::allocator<enum TextureType *>::deallocate
$LN8@Growmap:

; 1862 : 			}
; 1863 : 
; 1864 : 		this->_Map() = _Newmap;	// point at new

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [eax], ecx

; 1865 : 		this->_Mapsize() += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	DWORD PTR tv318[ebp], eax
	mov	edx, DWORD PTR tv318[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR tv318[ebp]
	mov	DWORD PTR [ecx], eax
$LN9@Growmap:

; 1866 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Xlen@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Xlen, COMDAT
; _this$ = ecx

; 1801 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1802 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1803 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?pop_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -16						; size = 4
tv165 = -12						; size = 4
__Newoff$2 = -8						; size = 4
_this$ = -4						; size = 4
?pop_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_back
$LN4@pop_back:

; 1497 : 			{
; 1498 : 			_STL_REPORT_ERROR("deque empty before pop");

	push	OFFSET ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1498					; 000005daH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN9@pop_back
	int	3
$LN9@pop_back:
	push	0
	push	1498					; 000005daH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1JO@BIGKCEFI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
	push	OFFSET ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN4@pop_back

; 1499 : 			}
; 1500 : 		else

	jmp	$LN1@pop_back
$LN5@pop_back:

; 1501 : 			{	// something to erase, do it
; 1502 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx-1]
	mov	DWORD PTR __Newoff$2[ebp], eax

; 1503 : 			_Orphan_off(_Newoff);

	mov	ecx, DWORD PTR __Newoff$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Orphan_off

; 1504 : 			size_type _Block = this->_Getblock(_Newoff);

	mov	edx, DWORD PTR __Newoff$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
	mov	DWORD PTR __Block$1[ebp], eax

; 1505 : 			_Alty_traits::destroy(this->_Getal(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$2[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ; std::_Unfancy<enum TextureType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	call	??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::destroy<enum TextureType>
	add	esp, 8

; 1506 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1507 : 			if (--this->_Mysize() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	DWORD PTR tv165[ebp], eax
	mov	eax, DWORD PTR tv165[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR tv165[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@pop_back

; 1508 : 				{
; 1509 : 				this->_Myoff() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	DWORD PTR [eax], 0
$LN1@pop_back:

; 1510 : 				}
; 1511 : 			}
; 1512 : 
; 1513 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1514 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1515 : 		size_type _Block = this->_Getblock(_Newoff);
; 1516 : 		_Alty_traits::destroy(this->_Getal(),
; 1517 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1518 : 		if (--this->_Mysize() == 0)
; 1519 : 			{
; 1520 : 			this->_Myoff() = 0;
; 1521 : 			}
; 1522 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1523 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXABW4TextureType@@@Z
_TEXT	SEGMENT
tv226 = -20						; size = 4
__Newoff$ = -16						; size = 4
tv147 = -12						; size = 4
__Block$ = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXABW4TextureType@@@Z PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back, COMDAT
; _this$ = ecx

; 1485 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all

; 1487 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	edx, DWORD PTR [eax]
	add	edx, 4
	shr	edx, 2
	cmp	DWORD PTR [esi], edx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Growmap
$LN2@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*4-1]
	mov	edx, DWORD PTR tv147[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	edx, DWORD PTR __Newoff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN3@push_back
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z ; std::allocator<enum TextureType>::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+eax*4], esi
$LN3@push_back:

; 1488 : 		_Alty_traits::construct(this->_Getal(),

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ; std::_Unfancy<enum TextureType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	call	??$construct@W4TextureType@@ABW41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@ABW43@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType const &>
	add	esp, 12					; 0000000cH

; 1489 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ), _Val);
; 1490 : 		_PUSH_BACK_END;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	DWORD PTR tv226[ebp], eax
	mov	eax, DWORD PTR tv226[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR [edx], ecx

; 1491 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXABW4TextureType@@@Z ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?pop_front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -16						; size = 4
tv184 = -12						; size = 4
tv169 = -8						; size = 4
_this$ = -4						; size = 4
?pop_front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_front, COMDAT
; _this$ = ecx

; 1447 : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1448 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1449 : 		if (empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@pop_front
$LN4@pop_front:

; 1450 : 			{
; 1451 : 			_STL_REPORT_ERROR("deque empty before pop");

	push	OFFSET ??_C@_0BH@EDKEEENI@deque?5empty?5before?5pop@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1451					; 000005abH
	push	OFFSET ??_C@_0GG@PDGBPBNH@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN10@pop_front
	int	3
$LN10@pop_front:
	push	0
	push	1451					; 000005abH
	push	OFFSET ??_C@_1MM@CBBKNAMM@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1KA@GCMBJJEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?$DM?$AAe?$AAn?$AAu?$AAm@
	push	OFFSET ??_C@_1DC@NJAACHCD@?$AA?$CC?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN4@pop_front

; 1452 : 			}
; 1453 : 		else

	jmp	$LN1@pop_front
$LN5@pop_front:

; 1454 : 			{	// something to erase, do it
; 1455 : 			_Orphan_off(this->_Myoff());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_off@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IBEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Orphan_off

; 1456 : 			size_type _Block = this->_Getblock(this->_Myoff());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
	mov	DWORD PTR __Block$1[ebp], eax

; 1457 : 			_Alty_traits::destroy(this->_Getal(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, DWORD PTR __Block$1[ebp]
	mov	ecx, DWORD PTR [esi+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ; std::_Unfancy<enum TextureType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	call	??$destroy@W4TextureType@@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::destroy<enum TextureType>
	add	esp, 8

; 1458 : 				_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1459 : 			if (--this->_Mysize() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR tv169[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@pop_front

; 1460 : 				{
; 1461 : 				this->_Myoff() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	DWORD PTR [eax], 0

; 1462 : 				}
; 1463 : 			else

	jmp	SHORT $LN1@pop_front
$LN7@pop_front:

; 1464 : 				{
; 1465 : 				++this->_Myoff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR tv184[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR [eax], edx
$LN1@pop_front:

; 1466 : 				}
; 1467 : 			}
; 1468 : 
; 1469 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1470 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1471 : 		_Alty_traits::destroy(this->_Getal(),
; 1472 : 			_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1473 : 		if (--this->_Mysize() == 0)
; 1474 : 			{
; 1475 : 			this->_Myoff() = 0;
; 1476 : 			}
; 1477 : 		else
; 1478 : 			{
; 1479 : 			++this->_Myoff();
; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEXXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::pop_front
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 12
$T3 = -28						; size = 4
tv72 = -24						; size = 4
tv73 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::front, COMDAT
; _this$ = ecx

; 1418 : 		{	// return first element of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1419 : 		return (*begin());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::begin
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv72[ebp]
	call	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QBEAAW4TextureType@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::operator*
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]

; 1420 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?front@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEAAW4TextureType@@XZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::front
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty, COMDAT
; _this$ = ecx

; 1376 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1377 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv71[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv71[ebp]

; 1378 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBE_NXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?max_size@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBEIXZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::max_size, COMDAT
; _this$ = ecx

; 1371 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1372 : 		return (_Alty_traits::max_size(this->_Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAIABV?$allocator@W4TextureType@@@2@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::max_size
	add	esp, 4

; 1373 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QBEIXZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::begin, COMDAT
; _this$ = ecx

; 1233 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1234 : 		return (iterator(this->_Myoff(), _STD addressof(this->_Get_data())));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	push	eax
	call	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1235 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ:
	mov	eax, OFFSET __ehfuncinfo$?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@2@XZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::begin
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::~deque<enum TextureType,std::allocator<enum TextureType> >, COMDAT
; _this$ = ecx

; 1192 : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1193 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXXZ ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Tidy

; 1194 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::~_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::~deque<enum TextureType,std::allocator<enum TextureType> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEX$$QAW4TextureType@@@Z
_TEXT	SEGMENT
tv228 = -20						; size = 4
__Newoff$ = -16						; size = 4
tv147 = -12						; size = 4
__Block$ = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEX$$QAW4TextureType@@@Z PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back, COMDAT
; _this$ = ecx

; 1103 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all

; 1105 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_back
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	edx, DWORD PTR [eax]
	add	edx, 4
	shr	edx, 2
	cmp	DWORD PTR [esi], edx
	ja	SHORT $LN2@push_back
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@IAEXI@Z ; std::deque<enum TextureType,std::allocator<enum TextureType> >::_Growmap
$LN2@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax*4-1]
	mov	edx, DWORD PTR tv147[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Newoff$[ebp], ecx
	mov	edx, DWORD PTR __Newoff$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
	mov	DWORD PTR __Block$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	jne	SHORT $LN3@push_back
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z ; std::allocator<enum TextureType>::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+eax*4], esi
$LN3@push_back:

; 1106 : 		_Alty_traits::construct(this->_Getal(),

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$move@AAW4TextureType@@@std@@YA$$QAW4TextureType@@AAW41@@Z ; std::move<enum TextureType &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	call	??$_Unfancy@W4TextureType@@@std@@YAPAW4TextureType@@PAW41@@Z ; std::_Unfancy<enum TextureType>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	call	??$construct@W4TextureType@@W41@@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAXAAV?$allocator@W4TextureType@@@1@QAW4TextureType@@$$QAW43@@Z ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::construct<enum TextureType,enum TextureType>
	add	esp, 12					; 0000000cH

; 1107 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ),
; 1108 : 			_STD move(_Val));
; 1109 : 		_PUSH_BACK_END;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
	mov	DWORD PTR tv228[ebp], eax
	mov	eax, DWORD PTR tv228[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv228[ebp]
	mov	DWORD PTR [edx], ecx

; 1110 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAEX$$QAW4TextureType@@@Z ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ PROC ; std::deque<enum TextureType,std::allocator<enum TextureType> >::deque<enum TextureType,std::allocator<enum TextureType> >, COMDAT
; _this$ = ecx

; 930  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >

; 931  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@QAE@XZ ENDP ; std::deque<enum TextureType,std::allocator<enum TextureType> >::deque<enum TextureType,std::allocator<enum TextureType> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 303  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$allocator@W4TextureType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$allocator@W4TextureType@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 298  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 293  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Getblock, COMDAT
; _this$ = ecx

; 688  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 690  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Off$[ebp]
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	and	eax, edx

; 691  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Deque_val<std::_Deque_simple_types<enum TextureType> >, COMDAT
; _this$ = ecx

; 684  : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 680  : 		: _Map(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 681  : 		_Mapsize(0),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 682  : 		_Myoff(0),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 683  : 		_Mysize(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 685  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Deque_val<std::_Deque_simple_types<enum TextureType> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize, COMDAT
; _this$ = ecx

; 882  : 		{	// return const reference to _Mysize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 883  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 16					; 00000010H

; 884  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize, COMDAT
; _this$ = ecx

; 877  : 		{	// return reference to _Mysize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 16					; 00000010H

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff, COMDAT
; _this$ = ecx

; 872  : 		{	// return const reference to _Myoff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 		return (_Get_data()._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 12					; 0000000cH

; 874  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff, COMDAT
; _this$ = ecx

; 867  : 		{	// return reference to _Myoff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 868  : 		return (_Get_data()._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 12					; 0000000cH

; 869  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize, COMDAT
; _this$ = ecx

; 857  : 		{	// return reference to _Mapsize

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		return (_Get_data()._Mapsize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 8

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map, COMDAT
; _this$ = ecx

; 847  : 		{	// return reference to _Map

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 848  : 		return (_Get_data()._Map);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	add	eax, 4

; 849  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAPAW4TextureType@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Map
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data, COMDAT
; _this$ = ecx

; 842  : 		{	// return const reference to _Deque_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second

; 844  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data, COMDAT
; _this$ = ecx

; 837  : 		{	// return reference to _Deque_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 838  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_second

; 839  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$allocator@W4TextureType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$allocator@W4TextureType@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal, COMDAT
; _this$ = ecx

; 832  : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 833  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first

; 834  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$allocator@W4TextureType@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal, COMDAT
; _this$ = ecx

; 827  : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Get_first

; 829  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 817  : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 818  : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 819  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy, COMDAT
; _this$ = ecx

; 807  : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 808  : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data

; 809  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 802  : 		{	// get address of iterator chain

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 803  : 		return (_Get_data()._Getpfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	mov	ecx, eax
	call	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 804  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpfirst@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum TextureType>

; 795  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Orphan_all

; 796  : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 797  : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Proxy_allocator$[ebp]
	push	eax
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
	add	esp, 8

; 798  : 		_Myproxy() = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 799  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 785  : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$allocator@W4TextureType@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0W4TextureType@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@W4TextureType@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><enum TextureType>

; 787  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 788  : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 789  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	push	eax
	call	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<enum TextureType> > >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi

; 790  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::~_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >, COMDAT
; _this$ = ecx

; 744  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Free_proxy

; 746  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::~_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >, COMDAT
; _this$ = ecx

; 730  : 		{	// default construct allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 		: _Mypair(_Zero_then_variadic_args_t())

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@W4TextureType@@@std@@V?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1>::_Compressed_pair<std::allocator<enum TextureType>,std::_Deque_val<std::_Deque_simple_types<enum TextureType> >,1><>

; 731  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Alloc_proxy

; 732  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock, COMDAT
; _this$ = ecx

; 724  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 		return (_Get_data()._Getblock(_Off));

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Get_data
	mov	ecx, eax
	call	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@W4TextureType@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<enum TextureType> >::_Getblock

; 726  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@W4TextureType@@V?$allocator@W4TextureType@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<enum TextureType,std::allocator<enum TextureType> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAW4TextureType@@@std@@QAEPAPAW4TextureType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAW4TextureType@@@std@@QAEPAPAW4TextureType@@I@Z PROC ; std::allocator<enum TextureType *>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAW4TextureType@@@std@@QAEPAPAW4TextureType@@I@Z ENDP ; std::allocator<enum TextureType *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z PROC ; std::allocator<enum TextureType *>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAW4TextureType@@@std@@QAEXQAPAW4TextureType@@I@Z ENDP ; std::allocator<enum TextureType *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAIABV?$allocator@W4TextureType@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAIABV?$allocator@W4TextureType@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::max_size, COMDAT

; 891  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	eax, 1073741823				; 3fffffffH

; 893  : 		}

	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@W4TextureType@@@std@@@std@@SAIABV?$allocator@W4TextureType@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<enum TextureType> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z PROC ; std::allocator<enum TextureType>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@W4TextureType@@@std@@QAEPAW4TextureType@@I@Z ENDP ; std::allocator<enum TextureType>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@W4TextureType@@@std@@QAEXQAW4TextureType@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@W4TextureType@@@std@@QAEXQAW4TextureType@@I@Z PROC ; std::allocator<enum TextureType>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@W4TextureType@@@std@@QAEXQAW4TextureType@@I@Z ENDP ; std::allocator<enum TextureType>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@W4TextureType@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@W4TextureType@@@std@@QAE@XZ PROC		; std::allocator<enum TextureType>::allocator<enum TextureType>, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@W4TextureType@@@std@@QAE@XZ ENDP		; std::allocator<enum TextureType>::allocator<enum TextureType>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmUp@@YAXXZ
text$di	SEGMENT
??__EmUp@@YAXXZ PROC					; `dynamic initializer for 'mUp'', COMDAT

; 65   : STVector3 mUp;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?mUp@@3USTVector3@@A	; mUp
	call	??0STVector3@@QAE@XZ			; STVector3::STVector3
	pop	ebp
	ret	0
??__EmUp@@YAXXZ ENDP					; `dynamic initializer for 'mUp''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmRight@@YAXXZ
text$di	SEGMENT
??__EmRight@@YAXXZ PROC					; `dynamic initializer for 'mRight'', COMDAT

; 64   : STVector3 mRight;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?mRight@@3USTVector3@@A	; mRight
	call	??0STVector3@@QAE@XZ			; STVector3::STVector3
	pop	ebp
	ret	0
??__EmRight@@YAXXZ ENDP					; `dynamic initializer for 'mRight''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmLookAt@@YAXXZ
text$di	SEGMENT
??__EmLookAt@@YAXXZ PROC				; `dynamic initializer for 'mLookAt'', COMDAT

; 63   : STVector3 mLookAt;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?mLookAt@@3USTVector3@@A	; mLookAt
	call	??0STVector3@@QAE@XZ			; STVector3::STVector3
	pop	ebp
	ret	0
??__EmLookAt@@YAXXZ ENDP				; `dynamic initializer for 'mLookAt''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmPosition@@YAXXZ
text$di	SEGMENT
??__EmPosition@@YAXXZ PROC				; `dynamic initializer for 'mPosition'', COMDAT

; 62   : STVector3 mPosition;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?mPosition@@3USTVector3@@A	; mPosition
	call	??0STVector3@@QAE@XZ			; STVector3::STVector3
	pop	ebp
	ret	0
??__EmPosition@@YAXXZ ENDP				; `dynamic initializer for 'mPosition''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FcolorMap@@YAXXZ
text$yd	SEGMENT
??__FcolorMap@@YAXXZ PROC				; `dynamic atexit destructor for 'colorMap'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; colorMap
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FcolorMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'colorMap''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EcolorMap@@YAXXZ
text$di	SEGMENT
??__EcolorMap@@YAXXZ PROC				; `dynamic initializer for 'colorMap'', COMDAT

; 38   : std::string colorMap;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?colorMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; colorMap
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FcolorMap@@YAXXZ		; `dynamic atexit destructor for 'colorMap''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EcolorMap@@YAXXZ ENDP				; `dynamic initializer for 'colorMap''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FmeshOBJ@@YAXXZ
text$yd	SEGMENT
??__FmeshOBJ@@YAXXZ PROC				; `dynamic atexit destructor for 'meshOBJ'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; meshOBJ
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FmeshOBJ@@YAXXZ ENDP				; `dynamic atexit destructor for 'meshOBJ''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EmeshOBJ@@YAXXZ
text$di	SEGMENT
??__EmeshOBJ@@YAXXZ PROC				; `dynamic initializer for 'meshOBJ'', COMDAT

; 35   : std::string meshOBJ;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?meshOBJ@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; meshOBJ
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FmeshOBJ@@YAXXZ		; `dynamic atexit destructor for 'meshOBJ''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EmeshOBJ@@YAXXZ ENDP				; `dynamic initializer for 'meshOBJ''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FdisplacementMap@@YAXXZ
text$yd	SEGMENT
??__FdisplacementMap@@YAXXZ PROC			; `dynamic atexit destructor for 'displacementMap'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; displacementMap
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FdisplacementMap@@YAXXZ ENDP			; `dynamic atexit destructor for 'displacementMap''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EdisplacementMap@@YAXXZ
text$di	SEGMENT
??__EdisplacementMap@@YAXXZ PROC			; `dynamic initializer for 'displacementMap'', COMDAT

; 34   : std::string displacementMap;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?displacementMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; displacementMap
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FdisplacementMap@@YAXXZ	; `dynamic atexit destructor for 'displacementMap''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EdisplacementMap@@YAXXZ ENDP			; `dynamic initializer for 'displacementMap''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FnormalMap@@YAXXZ
text$yd	SEGMENT
??__FnormalMap@@YAXXZ PROC				; `dynamic atexit destructor for 'normalMap'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; normalMap
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FnormalMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'normalMap''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EnormalMap@@YAXXZ
text$di	SEGMENT
??__EnormalMap@@YAXXZ PROC				; `dynamic initializer for 'normalMap'', COMDAT

; 33   : std::string normalMap;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?normalMap@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; normalMap
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FnormalMap@@YAXXZ		; `dynamic atexit destructor for 'normalMap''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EnormalMap@@YAXXZ ENDP				; `dynamic initializer for 'normalMap''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FfragmentShader@@YAXXZ
text$yd	SEGMENT
??__FfragmentShader@@YAXXZ PROC				; `dynamic atexit destructor for 'fragmentShader'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; fragmentShader
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FfragmentShader@@YAXXZ ENDP				; `dynamic atexit destructor for 'fragmentShader''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EfragmentShader@@YAXXZ
text$di	SEGMENT
??__EfragmentShader@@YAXXZ PROC				; `dynamic initializer for 'fragmentShader'', COMDAT

; 32   : std::string fragmentShader;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?fragmentShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; fragmentShader
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FfragmentShader@@YAXXZ	; `dynamic atexit destructor for 'fragmentShader''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EfragmentShader@@YAXXZ ENDP				; `dynamic initializer for 'fragmentShader''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FvertexShader@@YAXXZ
text$yd	SEGMENT
??__FvertexShader@@YAXXZ PROC				; `dynamic atexit destructor for 'vertexShader'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; vertexShader
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__FvertexShader@@YAXXZ ENDP				; `dynamic atexit destructor for 'vertexShader''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ??__EvertexShader@@YAXXZ
text$di	SEGMENT
??__EvertexShader@@YAXXZ PROC				; `dynamic initializer for 'vertexShader'', COMDAT

; 31   : std::string vertexShader;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?vertexShader@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; vertexShader
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__FvertexShader@@YAXXZ		; `dynamic atexit destructor for 'vertexShader''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__EvertexShader@@YAXXZ ENDP				; `dynamic initializer for 'vertexShader''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xrange@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xrange, COMDAT

; 1930 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp

; 1931 : 		_Xout_of_range("invalid vector<T> subscript");

	push	OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xrange:

; 1932 : 		}

	pop	ebp
	ret	0
?_Xrange@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xlength, COMDAT

; 1925 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp

; 1926 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 1927 : 		}

	pop	ebp
	ret	0
?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1911 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all

; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Tidy

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy

; 1916 : 			this->_Getal().deallocate(this->_Myfirst(), capacity());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z ; std::allocator<STTriangleMesh *>::deallocate

; 1917 : 
; 1918 : 			this->_Myfirst() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	DWORD PTR [eax], 0

; 1919 : 			this->_Mylast() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	DWORD PTR [eax], 0

; 1920 : 			this->_Myend() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
	mov	DWORD PTR [eax], 0
$LN1@Tidy:

; 1921 : 			}
; 1922 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAE_NI@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Buy, COMDAT
; _this$ = ecx

; 1872 : 		{	// allocate array with _Newcapacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1873 : 		this->_Myfirst() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	DWORD PTR [eax], 0

; 1874 : 		this->_Mylast() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	DWORD PTR [eax], 0

; 1875 : 		this->_Myend() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
	mov	DWORD PTR [eax], 0

; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

	cmp	DWORD PTR __Newcapacity$[ebp], 0
	jne	SHORT $LN2@Buy

; 1878 : 			{
; 1879 : 			return (false);

	xor	al, al
	jmp	SHORT $LN4@Buy
$LN2@Buy:

; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size
	cmp	DWORD PTR __Newcapacity$[ebp], eax
	jbe	SHORT $LN3@Buy

; 1883 : 			{
; 1884 : 			_Xlength();

	call	?_Xlength@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xlength
$LN3@Buy:

; 1885 : 			}
; 1886 : 
; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEPAPAVSTTriangleMesh@@I@Z ; std::allocator<STTriangleMesh *>::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	DWORD PTR [eax], esi

; 1888 : 		this->_Mylast() = this->_Myfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
	mov	DWORD PTR [eax], esi

; 1890 : 
; 1891 : 		return (true);

	mov	al, 1
$LN4@Buy:

; 1892 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAE_NI@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
_this$ = -8						; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@ABEII@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1854 : 		const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size
	mov	ecx, DWORD PTR __Oldcapacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	DWORD PTR __Oldcapacity$[ebp], eax
	jbe	SHORT $LN2@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	edx, DWORD PTR __Oldcapacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Oldcapacity$[ebp]
	mov	DWORD PTR __Geometric$[ebp], edx

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	mov	eax, DWORD PTR __Geometric$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@Calculate_

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient

	mov	eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1869 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@ABEII@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy, COMDAT
; _this$ = ecx

; 1848 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXPAPAVSTTriangleMesh@@0AAV?$allocator@PAVSTTriangleMesh@@@0@@Z ; std::_Destroy_range<std::allocator<STTriangleMesh *> >
	add	esp, 12					; 0000000cH

; 1850 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXPAPAVSTTriangleMesh@@0@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at, COMDAT
; _this$ = ecx

; 1749 : 		{	// subscript mutable sequence with checking

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1750 : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $LN2@at

; 1751 : 			{
; 1752 : 			_Xrange();

	call	?_Xrange@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@CAXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Xrange
$LN2@at:

; 1753 : 			}
; 1754 : 
; 1755 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@at:

; 1756 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?at@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@operator:

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jae	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1733					; 000006c5H
	push	OFFSET ??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	push	0
	push	1733					; 000006c5H
	push	OFFSET ??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1LO@PDFJBEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@
	push	OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	edx, edx
	jne	SHORT $LN4@operator

; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 1737 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAPAVSTTriangleMesh@@I@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity, COMDAT
; _this$ = ecx

; 1714 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	mov	eax, ecx

; 1716 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size, COMDAT
; _this$ = ecx

; 1708 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@SAIABV?$allocator@PAVSTTriangleMesh@@@2@@Z ; std::_Default_allocator_traits<std::allocator<STTriangleMesh *> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size, COMDAT
; _this$ = ecx

; 1703 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	mov	eax, ecx

; 1705 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QBEIXZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??4?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator=, COMDAT
; _this$ = ecx

; 1399 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1400 : 		if (this != _STD addressof(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPBV?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@0@ABV10@@Z ; std::addressof<std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> > const >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	je	SHORT $LN2@operator

; 1401 : 			{	// different, assign it
; 1402 : #pragma warning(push)
; 1403 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1404 : 			if (_Alty_traits::propagate_on_container_copy_assignment::value
; 1405 : 				&& this->_Getal() != _Right._Getal())

	xor	ecx, ecx
	je	SHORT $LN3@operator

; 1406 : 				{	// reload array
; 1407 : 				_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Tidy
$LN3@operator:

; 1408 : 				}
; 1409 : #pragma warning(pop)
; 1410 : 
; 1411 : 			this->_Copy_alloc(_Right._Getal());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXABV?$allocator@PAVSTTriangleMesh@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Copy_alloc

; 1412 : 
; 1413 : 			assign(_Right._Myfirst(), _Right._Mylast());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$assign@PAPAVSTTriangleMesh@@X@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEXPAPAVSTTriangleMesh@@0@Z ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::assign<STTriangleMesh * *,void>
$LN2@operator:

; 1414 : 			}
; 1415 : 
; 1416 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1417 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 894  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@AAEXXZ ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::_Tidy

; 895  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::~_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::~vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ PROC ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >, COMDAT
; _this$ = ecx

; 651  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 650  : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >

; 652  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ENDP ; std::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >::vector<STTriangleMesh *,std::allocator<STTriangleMesh *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 303  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 298  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 293  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<STTriangleMesh *> >::_Vector_val<std::_Simple_types<STTriangleMesh *> >, COMDAT
; _this$ = ecx

; 392  : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 389  : 		: _Myfirst(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 390  : 		_Mylast(),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 391  : 		_Myend()

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 393  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<STTriangleMesh *> >::_Vector_val<std::_Simple_types<STTriangleMesh *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend, COMDAT
; _this$ = ecx

; 600  : 		{	// return const reference to _Myend

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Get_data()._Myend);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 12					; 0000000cH

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend, COMDAT
; _this$ = ecx

; 595  : 		{	// return reference to _Myend

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 596  : 		return (_Get_data()._Myend);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 12					; 0000000cH

; 597  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast, COMDAT
; _this$ = ecx

; 590  : 		{	// return const reference to _Mylast

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast, COMDAT
; _this$ = ecx

; 585  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 8

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 580  : 		{	// return const reference to _Myfirst

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 4

; 582  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABQAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 575  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	add	eax, 4

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAPAVSTTriangleMesh@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data, COMDAT
; _this$ = ecx

; 559  : 		{	// return const reference to _Vector_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second

; 561  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data, COMDAT
; _this$ = ecx

; 554  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_second

; 556  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal, COMDAT
; _this$ = ecx

; 549  : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 550  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first

; 551  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QBEABV?$allocator@PAVSTTriangleMesh@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal, COMDAT
; _this$ = ecx

; 544  : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Get_first

; 546  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 534  : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 536  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy, COMDAT
; _this$ = ecx

; 523  : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 524  : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 509  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 510  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><STTriangleMesh *>

; 511  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Orphan_all

; 512  : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 513  : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Proxy_allocator$[ebp]
	push	eax
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
	add	esp, 8

; 514  : 		_Myproxy() = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 515  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 501  : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 502  : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0PAVSTTriangleMesh@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSTTriangleMesh@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><STTriangleMesh *>

; 503  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 504  : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 505  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Get_data
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<STTriangleMesh *> > >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi

; 506  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXABV?$allocator@PAVSTTriangleMesh@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Reload$ = -1						; size = 1
__Al$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXABV?$allocator@PAVSTTriangleMesh@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 465  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 466  : 		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
; 467  : 			&& _Getal() != _Al;

	mov	BYTE PTR __Reload$[ebp], 0

; 468  : 
; 469  : 		if (_Reload)

	xor	eax, eax
	je	SHORT $LN2@Copy_alloc

; 470  : 			{
; 471  : 			_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Free_proxy
$LN2@Copy_alloc:

; 472  : 			}
; 473  : 
; 474  : 		_Pocca(_Getal(), _Al);

	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEAAV?$allocator@PAVSTTriangleMesh@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Getal
	push	eax
	call	??$_Pocca@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@YAXAAV?$allocator@PAVSTTriangleMesh@@@0@ABV10@@Z ; std::_Pocca<std::allocator<STTriangleMesh *> >
	add	esp, 8

; 475  : 
; 476  : 		if (_Reload)

	xor	edx, edx
	je	SHORT $LN1@Copy_alloc

; 477  : 			{
; 478  : 			_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Alloc_proxy
$LN1@Copy_alloc:

; 479  : 			}
; 480  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXABV?$allocator@PAVSTTriangleMesh@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::~_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >, COMDAT
; _this$ = ecx

; 460  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 461  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Free_proxy

; 462  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::~_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >, COMDAT
; _this$ = ecx

; 446  : 		{	// default construct allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		: _Mypair(_Zero_then_variadic_args_t())

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVSTTriangleMesh@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSTTriangleMesh@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1>::_Compressed_pair<std::allocator<STTriangleMesh *>,std::_Vector_val<std::_Simple_types<STTriangleMesh *> >,1><>

; 447  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Alloc_proxy

; 448  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@PAVSTTriangleMesh@@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >::_Vector_alloc<std::_Vec_base_types<STTriangleMesh *,std::allocator<STTriangleMesh *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@SAIABV?$allocator@PAVSTTriangleMesh@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@SAIABV?$allocator@PAVSTTriangleMesh@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<STTriangleMesh *> >::max_size, COMDAT

; 891  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	eax, 1073741823				; 3fffffffH

; 893  : 		}

	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PAVSTTriangleMesh@@@std@@@std@@SAIABV?$allocator@PAVSTTriangleMesh@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<STTriangleMesh *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEPAPAVSTTriangleMesh@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEPAPAVSTTriangleMesh@@I@Z PROC ; std::allocator<STTriangleMesh *>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEPAPAVSTTriangleMesh@@I@Z ENDP ; std::allocator<STTriangleMesh *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z PROC ; std::allocator<STTriangleMesh *>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSTTriangleMesh@@@std@@QAEXQAPAVSTTriangleMesh@@I@Z ENDP ; std::allocator<STTriangleMesh *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@PAVSTTriangleMesh@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVSTTriangleMesh@@@std@@QAE@XZ PROC	; std::allocator<STTriangleMesh *>::allocator<STTriangleMesh *>, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVSTTriangleMesh@@@std@@QAE@XZ ENDP	; std::allocator<STTriangleMesh *>::allocator<STTriangleMesh *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\freeglut-3.0.0\include\gl\freeglut_std.h
_TEXT	SEGMENT
_title$ = 8						; size = 4
_glutCreateWindow_ATEXIT_HACK PROC

; 639  : static int FGAPIENTRY FGUNUSED glutCreateWindow_ATEXIT_HACK(const char *title) { return __glutCreateWindowWithExit(title, exit); }

	push	ebp
	mov	ebp, esp
	push	OFFSET _exit
	mov	eax, DWORD PTR _title$[ebp]
	push	eax
	call	___glutCreateWindowWithExit
	add	esp, 8
	pop	ebp
	ret	0
_glutCreateWindow_ATEXIT_HACK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\freeglut-3.0.0\include\gl\freeglut_std.h
_TEXT	SEGMENT
_argcp$ = 8						; size = 4
_argv$ = 12						; size = 4
_glutInit_ATEXIT_HACK PROC

; 637  : static void FGAPIENTRY FGUNUSED glutInit_ATEXIT_HACK(int *argcp, char **argv) { __glutInitWithExit(argcp, argv, exit); }

	push	ebp
	mov	ebp, esp
	push	OFFSET _exit
	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argcp$[ebp]
	push	ecx
	call	___glutInitWithExit
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
_glutInit_ATEXIT_HACK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSTTriangleMesh@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSTTriangleMesh@@QAEPAXI@Z PROC			; STTriangleMesh::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1STTriangleMesh@@QAE@XZ		; STTriangleMesh::~STTriangleMesh
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	172					; 000000acH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSTTriangleMesh@@QAEPAXI@Z ENDP			; STTriangleMesh::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -124						; size = 8
tv287 = -116						; size = 8
tv338 = -108						; size = 8
tv326 = -100						; size = 8
tv135 = -92						; size = 8
__Count$ = -84						; size = 8
__Pad$ = -76						; size = 8
$T2 = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
tv290 = -56						; size = 4
tv289 = -52						; size = 4
tv286 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
tv285 = -36						; size = 4
tv284 = -32						; size = 4
tv137 = -28						; size = 4
__State$ = -24						; size = 4
tv288 = -18						; size = 1
tv283 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 790  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 791  : 	typedef char _Elem;
; 792  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 793  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 794  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIQBD@Z	; std::char_traits<char>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 795  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv326[ebp], eax
	mov	DWORD PTR tv326[ebp+4], edx
	cmp	DWORD PTR tv326[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv326[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	mov	DWORD PTR tv338[ebp], eax
	mov	DWORD PTR tv338[ebp+4], edx
	mov	eax, DWORD PTR tv338[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv338[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?width@ios_base@std@@QBE_JXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp+4], edx

; 796  : 		? 0 : _Ostr.width() - _Count;
; 797  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 798  : 
; 799  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@operator

; 800  : 		_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 801  : 	else

	jmp	$LN9@operator
$LN8@operator:

; 802  : 		{	// state okay, insert
; 803  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 804  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 805  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR __Pad$[ebp+4]
	sbb	edx, 0
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	DWORD PTR __Pad$[ebp+4], edx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	SHORT $LN11@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN11@operator
$LN26@operator:

; 806  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv283[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv284[ebp], eax
	movzx	eax, BYTE PTR tv283[ebp]
	push	eax
	mov	ecx, DWORD PTR tv284[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv285[ebp], eax
	mov	ecx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 807  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 808  : 					{	// insertion failed, quit
; 809  : 					_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 810  : 					break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 811  : 					}
; 812  : 
; 813  : 		if (_State == ios_base::goodbit

	jmp	$LN2@operator
$LN11@operator:

; 814  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv286[ebp], eax
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv286[ebp]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	mov	DWORD PTR tv287[ebp], eax
	mov	DWORD PTR tv287[ebp+4], edx
	mov	eax, DWORD PTR tv287[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv287[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 815  : 			_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx
$LN13@operator:

; 816  : 
; 817  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN14@operator

; 818  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	SHORT $LN14@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	SHORT $LN14@operator
$LN28@operator:

; 819  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv288[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv289[ebp], eax
	movzx	eax, BYTE PTR tv288[ebp]
	push	eax
	mov	ecx, DWORD PTR tv289[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv290[ebp], eax
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@operator

; 820  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 821  : 					{	// insertion failed, quit
; 822  : 					_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 823  : 					break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 824  : 					}

	jmp	$LN5@operator
$LN14@operator:

; 825  : 		_Ostr.width(0);

	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QAE_J_J@Z		; std::ios_base::width
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 826  : 		_CATCH_IO_(_Ostr)

	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN9@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 827  : 		}
; 828  : 
; 829  : 	_Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 830  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 831  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 586  : 		{	// flush output stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 587  : 		if (_Myios::rdbuf() != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $LN2@flush

; 588  : 			{	// buffer exists, flush it
; 589  : 			const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$2[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 590  : 
; 591  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

	lea	ecx, DWORD PTR __Ok$2[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@flush
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	cmp	eax, -1
	jne	SHORT $LN3@flush

; 592  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN3@flush:

; 593  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Ok$2[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
$LN2@flush:

; 594  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 595  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:
	lea	ecx, DWORD PTR __Ok$2[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
	mov	eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__Ok$ = -52						; size = 8
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
tv153 = -32						; size = 4
tv65 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 546  : 		{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 548  : 		const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 
; 550  : 		if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@put

; 551  : 			_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 552  : 		else

	jmp	$LN3@put
$LN2@put:

; 553  : 			{	// state okay, insert character
; 554  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 555  : 			if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv65[ebp], eax
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv65[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@put

; 556  : 				_Myios::rdbuf()->sputc(_Ch)))
; 557  : 				_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx
$LN5@put:
	jmp	SHORT $LN7@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:

; 558  : 			_CATCH_IO_END

	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN11@put
	ret	0
$LN7@put:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN3@put
$LN11@put:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@put:

; 559  : 			}
; 560  : 
; 561  : 		_Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 562  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 563  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
_TEXT	SEGMENT
$T2 = -84						; size = 8
$T3 = -76						; size = 8
$T4 = -68						; size = 8
__Ok$ = -60						; size = 8
$T5 = -52						; size = 4
tv198 = -48						; size = 4
__Nput_fac$6 = -44					; size = 4
tv197 = -40						; size = 4
tv193 = -36						; size = 4
tv65 = -32						; size = 4
__State$ = -28						; size = 4
_this$ = -24						; size = 4
tv196 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 421  : 		{	// insert a float

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 423  : 		const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 424  : 
; 425  : 		if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@operator

; 426  : 			{	// state okay, use facet to insert
; 427  : 			const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv193[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR tv193[ebp]
	push	ecx
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR __Nput_fac$6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 428  : 
; 429  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 430  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 431  : 				_Myios::fill(), (double)_Val).failed())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv196[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv197[ebp], eax
	cvtss2sd xmm0, DWORD PTR __Val$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR tv196[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv197[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Nput_fac$6[ebp]
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
	mov	DWORD PTR tv198[ebp], eax
	mov	ecx, DWORD PTR tv198[ebp]
	call	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@operator

; 432  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN4@operator:
	jmp	SHORT $LN6@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0:

; 433  : 			_CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN11@operator
	ret	0
$LN6@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN10@operator
$LN11@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN10@operator:

; 434  : 			}
; 435  : 
; 436  : 		_Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 437  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T5[ebp]

; 438  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 205  : 		{	// call basic_ostream manipulator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		return ((*_Pfn)(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __Pfn$[ebp]
	add	esp, 4

; 207  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv152 = -36						; size = 4
tv151 = -32						; size = 4
tv150 = -28						; size = 4
_this$ = -24						; size = 4
tv149 = -17						; size = 1
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 176  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 178  : 		if (this->good() && this->flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	mov	BYTE PTR tv149[ebp], al
	movzx	eax, BYTE PTR tv149[ebp]
	test	eax, eax
	je	SHORT $LN3@Osfx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv150[ebp], eax
	mov	eax, DWORD PTR tv150[ebp]
	and	eax, 2
	je	SHORT $LN3@Osfx

; 179  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	mov	DWORD PTR tv152[ebp], eax
	cmp	DWORD PTR tv152[ebp], -1
	jne	SHORT $LN3@Osfx

; 180  : 				_Myios::setstate(ios_base::badbit);

	push	0
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN3@Osfx:
	jmp	SHORT $LN6@Osfx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 181  : 		_CATCH_ALL
; 182  : 		_CATCH_END

	mov	eax, $LN9@Osfx
	ret	0
$LN6@Osfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN1@Osfx
$LN9@Osfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN1@Osfx:

; 183  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T2 = -36						; size = 8
tv79 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 124  : 		{	// convert _Byte to character using imbued locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		return (_STD use_facet<_Ctype>(getloc()).widen(_Byte));

	movzx	eax, BYTE PTR __Byte$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv80[ebp], eax
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	ecx, eax
	call	?widen@?$ctype@D@std@@QBEDD@Z		; std::ctype<char>::widen
	mov	BYTE PTR $T3[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	mov	al, BYTE PTR $T3[ebp]

; 126  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
	mov	eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 107  : 		{	// return fill character

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 		return (_Fillch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+64]

; 109  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 86   : 		{	// return stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 74   : 		{	// return tie pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		return (_Tiestr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		{	// merge _State into state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 		clear(rdstate() | _State, _Reraise);

	movzx	eax, BYTE PTR __Reraise$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 42   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 		ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN3@clear
	mov	ecx, DWORD PTR __State$[ebp]
	or	ecx, 4
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@clear
$LN3@clear:
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN4@clear:
	movzx	eax, BYTE PTR __Reraise$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv73[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 44   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$max@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YAABMABM0@Z PROC				; std::max<float>, COMDAT

; 5387 : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp

; 5388 : 	if (_Left < _Right)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN8@max
$LN4@max:

; 5389 : 		{
; 5390 : 		_STL_ASSERT(!(_Right < _Left), "invalid comparator");

	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, DWORD PTR [eax]
	ja	SHORT $LN9@max
	jmp	SHORT $LN6@max
$LN9@max:
	push	OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	5390					; 0000150eH
	push	OFFSET ??_C@_0GK@JMBMHIBC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN12@max
	int	3
$LN12@max:
	push	0
	push	5390					; 0000150eH
	push	OFFSET ??_C@_1NE@FKBPBJEB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1BC@ICCOKLEG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAm?$AAa?$AAx@
	push	OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	edx, edx
	jne	SHORT $LN9@max
$LN6@max:
	xor	eax, eax
	jne	SHORT $LN4@max

; 5391 : 		return (_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	jmp	SHORT $LN1@max
$LN8@max:

; 5392 : 		}
; 5393 : 
; 5394 : 	return (_Left);

	mov	eax, DWORD PTR __Left$[ebp]
$LN1@max:

; 5395 : 	}

	pop	ebp
	ret	0
??$max@M@std@@YAABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stpoint3.inl
;	COMDAT ??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_pt$ = 12						; size = 4
??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z PROC ; operator<<, COMDAT

; 120  : inline std::ostream& operator <<(std::ostream& stream, const STPoint3& pt) {

	push	ebp
	mov	ebp, esp

; 121  :     stream<<"["<<pt.x<<" "<<pt.y<<" "<<pt.z<<"]";

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN@
	mov	eax, DWORD PTR _pt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	ecx, DWORD PTR _pt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	edx, DWORD PTR _pt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_01OHGJGJJP@?$FL@
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 122  :     return stream;

	mov	eax, DWORD PTR _stream$[ebp]

; 123  : }

	pop	ebp
	ret	0
??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@ABUSTPoint3@@@Z ENDP ; operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stpoint3.inl
;	COMDAT ??0STPoint3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0STPoint3@@QAE@XZ PROC				; STPoint3::STPoint3, COMDAT
; _this$ = ecx

; 13   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 14   :     x = 0;

	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 15   :     y = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+4], xmm0

; 16   :     z = 0;

	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+8], xmm0

; 17   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0STPoint3@@QAE@XZ ENDP				; STPoint3::STPoint3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??G@YA?AUSTVector3@@ABUSTPoint3@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
??G@YA?AUSTVector3@@ABUSTPoint3@@0@Z PROC		; operator-, COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp

; 244  :     return STVector3(left.x - right.x,

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [eax+4]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [edx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 245  :                      left.y - right.y,
; 246  :                      left.z - right.z);
; 247  : }

	pop	ebp
	ret	0
??G@YA?AUSTVector3@@ABUSTPoint3@@0@Z ENDP		; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??G@YA?AUSTVector3@@ABU0@0@Z
_TEXT	SEGMENT
_result$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
??G@YA?AUSTVector3@@ABU0@0@Z PROC			; operator-, COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 200  :     STVector3 result(left);

	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3

; 201  :     result -= right;

	mov	ecx, DWORD PTR _right$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	??ZSTVector3@@QAEAAU0@ABU0@@Z		; STVector3::operator-=

; 202  :     return result;

	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??G@YA?AUSTVector3@@ABU0@0@Z ENDP			; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??D@YA?AUSTVector3@@MABU0@@Z
_TEXT	SEGMENT
_result$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
??D@YA?AUSTVector3@@MABU0@@Z PROC			; operator*, COMDAT

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 179  :     STVector3 result(right);

	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3

; 180  :     result *= left;

	push	ecx
	movss	xmm0, DWORD PTR _left$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _result$[ebp]
	call	??XSTVector3@@QAEAAU0@M@Z		; STVector3::operator*=

; 181  :     return result;

	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AUSTVector3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ?Cross@STVector3@@SA?AU1@ABU1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
?Cross@STVector3@@SA?AU1@ABU1@0@Z PROC			; STVector3::Cross, COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp

; 113  :     return STVector3(left.y * right.z - left.z * right.y,

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _right$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0STVector3@@QAE@MMM@Z			; STVector3::STVector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 114  :                      left.z * right.x - left.x * right.z,
; 115  :                      left.x * right.y - left.y * right.x);
; 116  : }

	pop	ebp
	ret	0
?Cross@STVector3@@SA?AU1@ABU1@0@Z ENDP			; STVector3::Cross
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ?LengthSq@STVector3@@QBEMXZ
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
?LengthSq@STVector3@@QBEMXZ PROC			; STVector3::LengthSq, COMDAT
; _this$ = ecx

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 70   :     return x * x + y * y + z * z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [edx+4]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]

; 71   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LengthSq@STVector3@@QBEMXZ ENDP			; STVector3::LengthSq
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ?Length@STVector3@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Length@STVector3@@QBEMXZ PROC				; STVector3::Length, COMDAT
; _this$ = ecx

; 61   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   :     return sqrtf(LengthSq());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LengthSq@STVector3@@QBEMXZ		; STVector3::LengthSq
	push	ecx
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Length@STVector3@@QBEMXZ ENDP				; STVector3::Length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ?Normalize@STVector3@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_len$ = -4						; size = 4
?Normalize@STVector3@@QAEXXZ PROC			; STVector3::Normalize, COMDAT
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 90   :     float len = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@STVector3@@QBEMXZ		; STVector3::Length
	fstp	DWORD PTR _len$[ebp]

; 91   :     if (len != 0.0f) {

	movss	xmm0, DWORD PTR _len$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Normalize

; 92   :         (*this) /= len;

	push	ecx
	movss	xmm0, DWORD PTR _len$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??_0STVector3@@QAEAAU0@M@Z		; STVector3::operator/=
$LN2@Normalize:

; 93   :     }
; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Normalize@STVector3@@QAEXXZ ENDP			; STVector3::Normalize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??ZSTVector3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_right$ = 8						; size = 4
??ZSTVector3@@QAEAAU0@ABU0@@Z PROC			; STVector3::operator-=, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  :     x -= right.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0

; 232  :     y -= right.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 233  :     z -= right.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 234  :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??ZSTVector3@@QAEAAU0@ABU0@@Z ENDP			; STVector3::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??YSTVector3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_right$ = 8						; size = 4
??YSTVector3@@QAEAAU0@ABU0@@Z PROC			; STVector3::operator+=, COMDAT
; _this$ = ecx

; 222  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 223  :     x += right.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0

; 224  :     y += right.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 225  :     z += right.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 226  :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??YSTVector3@@QAEAAU0@ABU0@@Z ENDP			; STVector3::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??_0STVector3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_right$ = 8						; size = 4
??_0STVector3@@QAEAAU0@M@Z PROC				; STVector3::operator/=, COMDAT
; _this$ = ecx

; 214  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 215  :     x /= right;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	divss	xmm0, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 216  :     y /= right;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 217  :     z /= right;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	divss	xmm0, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 218  :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 219  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??_0STVector3@@QAEAAU0@M@Z ENDP				; STVector3::operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??XSTVector3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_right$ = 8						; size = 4
??XSTVector3@@QAEAAU0@M@Z PROC				; STVector3::operator*=, COMDAT
; _this$ = ecx

; 206  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 207  :     x *= right;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 208  :     y *= right;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 209  :     z *= right;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 210  :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??XSTVector3@@QAEAAU0@M@Z ENDP				; STVector3::operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??4STVector3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??4STVector3@@QAEAAU0@ABU0@@Z PROC			; STVector3::operator=, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   :     x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 52   :     y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 53   :     z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 54   :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 55   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4STVector3@@QAEAAU0@ABU0@@Z ENDP			; STVector3::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??0STVector3@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_inX$ = 8						; size = 4
_inY$ = 12						; size = 4
_inZ$ = 16						; size = 4
??0STVector3@@QAE@MMM@Z PROC				; STVector3::STVector3, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 23   :     x = inX;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _inX$[ebp]
	movss	DWORD PTR [eax], xmm0

; 24   :     y = inY;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _inY$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 25   :     z = inZ;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _inZ$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 26   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0STVector3@@QAE@MMM@Z ENDP				; STVector3::STVector3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??0STVector3@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0STVector3@@QAE@ABU0@@Z PROC				; STVector3::STVector3, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 37   :     x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 38   :     y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 39   :     z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 40   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0STVector3@@QAE@ABU0@@Z ENDP				; STVector3::STVector3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stvector3.inl
;	COMDAT ??0STVector3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0STVector3@@QAE@XZ PROC				; STVector3::STVector3, COMDAT
; _this$ = ecx

; 15   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 16   :     x = 0;

	mov	eax, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 17   :     y = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+4], xmm0

; 18   :     z = 0;

	mov	edx, DWORD PTR _this$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+8], xmm0

; 19   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0STVector3@@QAE@XZ ENDP				; STVector3::STVector3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stmatrix4.inl
;	COMDAT ??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z
_TEXT	SEGMENT
_result$ = -16						; size = 12
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z PROC		; STMatrix4::operator*, COMDAT
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 67   :     STVector3 result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	??0STVector3@@QAE@XZ			; STVector3::STVector3

; 68   :     result.x = table[0][0]*v.x + table[0][1]*v.y + table[0][2]*v.z;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR _result$[ebp], xmm0

; 69   :     result.y = table[1][0]*v.x + table[1][1]*v.y + table[1][2]*v.z;

	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm0, xmm1
	movss	DWORD PTR _result$[ebp+4], xmm0

; 70   :     result.z = table[2][0]*v.x + table[2][1]*v.y + table[2][2]*v.z;

	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+4]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR _result$[ebp+8], xmm0

; 71   :     return result;

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	8
??DSTMatrix4@@QAE?AUSTVector3@@ABU1@@Z ENDP		; STMatrix4::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stmatrix4.inl
;	COMDAT ?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z
_TEXT	SEGMENT
_unit_vector$ = -36					; size = 12
_sin_t$ = -24						; size = 4
_z$ = -20						; size = 4
_x$ = -16						; size = 4
_y$ = -12						; size = 4
_this$ = -8						; size = 4
_cos_t$ = -4						; size = 4
_degrees$ = 8						; size = 4
_axis$ = 12						; size = 4
?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z PROC		; STMatrix4::EncodeR, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 40   :     EncodeI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeI@STMatrix4@@QAEXXZ		; STMatrix4::EncodeI

; 41   :     //http://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
; 42   :     float cos_t=cos(degrees * 3.1415926536f / 180.f);

	movss	xmm0, DWORD PTR _degrees$[ebp]
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?cos@@YAMM@Z				; cos
	add	esp, 4
	fstp	DWORD PTR _cos_t$[ebp]

; 43   :     float sin_t=sin(degrees * 3.1415926535f / 180.f);

	movss	xmm0, DWORD PTR _degrees$[ebp]
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?sin@@YAMM@Z				; sin
	add	esp, 4
	fstp	DWORD PTR _sin_t$[ebp]

; 44   : 
; 45   :     STVector3 unit_vector=axis;

	mov	eax, DWORD PTR _axis$[ebp]
	push	eax
	lea	ecx, DWORD PTR _unit_vector$[ebp]
	call	??0STVector3@@QAE@ABU0@@Z		; STVector3::STVector3

; 46   :     unit_vector.Normalize();

	lea	ecx, DWORD PTR _unit_vector$[ebp]
	call	?Normalize@STVector3@@QAEXXZ		; STVector3::Normalize

; 47   : 
; 48   :     const float& x=unit_vector.x;

	lea	ecx, DWORD PTR _unit_vector$[ebp]
	mov	DWORD PTR _x$[ebp], ecx

; 49   :     const float& y=unit_vector.y;

	lea	edx, DWORD PTR _unit_vector$[ebp+4]
	mov	DWORD PTR _y$[ebp], edx

; 50   :     const float& z=unit_vector.z;

	lea	eax, DWORD PTR _unit_vector$[ebp+8]
	mov	DWORD PTR _z$[ebp], eax

; 51   : 
; 52   :     table[0][0] = cos_t + x*x*(1.f-cos_t);

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _cos_t$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 53   :     table[0][1] = x*y*(1-cos_t) - z*sin_t;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _z$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	subss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 54   :     table[0][2] = x*z*(1-cos_t) + y*sin_t;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 55   : 
; 56   :     table[1][0] = y*x*(1-cos_t) + z*sin_t;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _z$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 57   :     table[1][1] = cos_t + y*y*(1-cos_t);

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _cos_t$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 58   :     table[1][2] = y*z*(1-cos_t) - x*sin_t;

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	subss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 59   : 
; 60   :     table[2][0] = z*x*(1-cos_t) - y*sin_t;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	subss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 61   :     table[2][1] = z*y*(1-cos_t) + x*sin_t;

	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR _sin_t$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 62   :     table[2][2] = cos_t + z*z*(1-cos_t);

	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _cos_t$[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR _cos_t$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?EncodeR@STMatrix4@@QAEXMABUSTVector3@@@Z ENDP		; STMatrix4::EncodeR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stmatrix4.inl
;	COMDAT ?EncodeI@STMatrix4@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv74 = -12						; size = 4
_j$1 = -8						; size = 4
_i$2 = -4						; size = 4
?EncodeI@STMatrix4@@QAEXXZ PROC				; STMatrix4::EncodeI, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 18   :     for(int i=0;i<4;i++)for(int j=0;j<4;j++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@EncodeI
$LN2@EncodeI:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@EncodeI:
	cmp	DWORD PTR _i$2[ebp], 4
	jge	SHORT $LN3@EncodeI
	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN7@EncodeI
$LN5@EncodeI:
	mov	ecx, DWORD PTR _j$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$1[ebp], ecx
$LN7@EncodeI:
	cmp	DWORD PTR _j$1[ebp], 4
	jge	SHORT $LN6@EncodeI

; 19   :         table[i][j]=(i==j?1.f:0.f);

	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR _j$1[ebp]
	jne	SHORT $LN9@EncodeI
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN10@EncodeI
$LN9@EncodeI:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv74[ebp], xmm0
$LN10@EncodeI:
	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$1[ebp]
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
	jmp	SHORT $LN5@EncodeI
$LN6@EncodeI:
	jmp	SHORT $LN2@EncodeI
$LN3@EncodeI:

; 20   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EncodeI@STMatrix4@@QAEXXZ ENDP				; STMatrix4::EncodeI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\libst-2018\include\stmatrix4.inl
;	COMDAT ??0STMatrix4@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0STMatrix4@@QAE@XZ PROC				; STMatrix4::STMatrix4, COMDAT
; _this$ = ecx

; 12   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 13   :     EncodeI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeI@STMatrix4@@QAEXXZ		; STMatrix4::EncodeI

; 14   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0STMatrix4@@QAE@XZ ENDP				; STMatrix4::STMatrix4
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GSTImage@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSTImage@@QAEPAXI@Z PROC				; STImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1STImage@@QAE@XZ			; STImage::~STImage
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSTImage@@QAEPAXI@Z ENDP				; STImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
__Orig$ = -12						; size = 4
__Val$ = -8						; size = 4
__Errno_ref$ = -4					; size = 4
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Pten$ = 16						; size = 4
__Perr$ = 20						; size = 4
?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z PROC			; std::_Stofx_v2, COMDAT

; 72   : 	{	// convert string to float

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 73   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno
	mov	DWORD PTR __Errno_ref$[ebp], eax

; 74   : 	const int _Orig = _Errno_ref;

	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Orig$[ebp], ecx

; 75   : 
; 76   : 	_Errno_ref = 0;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	DWORD PTR [edx], 0

; 77   : 	float _Val = _CSTD strtof(_Str, _Endptr);

	mov	eax, DWORD PTR __Endptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strtof
	add	esp, 8
	fstp	DWORD PTR __Val$[ebp]

; 78   : 	*_Perr = _Errno_ref;

	mov	edx, DWORD PTR __Perr$[ebp]
	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 79   : 	_Errno_ref = _Orig;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	eax, DWORD PTR __Orig$[ebp]
	mov	DWORD PTR [edx], eax

; 80   : 
; 81   : 	if (_Pten != 0)

	cmp	DWORD PTR __Pten$[ebp], 0
	je	SHORT $LN2@Stofx_v2

; 82   : 		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	cvtsi2ss xmm0, DWORD PTR __Pten$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	call	_powf
	add	esp, 8
	fstp	DWORD PTR tv93[ebp]
	movss	xmm0, DWORD PTR tv93[ebp]
	mulss	xmm0, DWORD PTR __Val$[ebp]
	movss	DWORD PTR __Val$[ebp], xmm0
$LN2@Stofx_v2:

; 83   : 
; 84   : 	return (_Val);

	fld	DWORD PTR __Val$[ebp]

; 85   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z ENDP			; std::_Stofx_v2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Stodx_v2@std@@YANPBDPAPADHPAH@Z
_TEXT	SEGMENT
tv93 = -24						; size = 8
__Val$ = -16						; size = 8
__Orig$ = -8						; size = 4
__Errno_ref$ = -4					; size = 4
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Pten$ = 16						; size = 4
__Perr$ = 20						; size = 4
?_Stodx_v2@std@@YANPBDPAPADHPAH@Z PROC			; std::_Stodx_v2, COMDAT

; 55   : 	{	// convert string to double

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 56   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno
	mov	DWORD PTR __Errno_ref$[ebp], eax

; 57   : 	const int _Orig = _Errno_ref;

	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Orig$[ebp], ecx

; 58   : 
; 59   : 	_Errno_ref = 0;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	DWORD PTR [edx], 0

; 60   : 	double _Val = _CSTD strtod(_Str, _Endptr);

	mov	eax, DWORD PTR __Endptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strtod
	add	esp, 8
	fstp	QWORD PTR __Val$[ebp]

; 61   : 	*_Perr = _Errno_ref;

	mov	edx, DWORD PTR __Perr$[ebp]
	mov	eax, DWORD PTR __Errno_ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 62   : 	_Errno_ref = _Orig;

	mov	edx, DWORD PTR __Errno_ref$[ebp]
	mov	eax, DWORD PTR __Orig$[ebp]
	mov	DWORD PTR [edx], eax

; 63   : 
; 64   : 	if (_Pten != 0)

	cmp	DWORD PTR __Pten$[ebp], 0
	je	SHORT $LN2@Stodx_v2

; 65   : 		_Val *= _CSTD pow(10.0, static_cast<double>(_Pten));

	cvtsi2sd xmm0, DWORD PTR __Pten$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv93[ebp]
	movsd	xmm0, QWORD PTR tv93[ebp]
	mulsd	xmm0, QWORD PTR __Val$[ebp]
	movsd	QWORD PTR __Val$[ebp], xmm0
$LN2@Stodx_v2:

; 66   : 
; 67   : 	return (_Val);

	fld	QWORD PTR __Val$[ebp]

; 68   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Stodx_v2@std@@YANPBDPAPADHPAH@Z ENDP			; std::_Stodx_v2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 444  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 445  : 		return (*_Ploc);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0locale@std@@QAE@ABV01@@Z		; std::locale::locale
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Oldwidth$ = -12					; size = 8
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 437  : 		{	// set width to argument

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 		const streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR __Oldwidth$[ebp], ecx
	mov	edx, DWORD PTR [eax+36]
	mov	DWORD PTR __Oldwidth$[ebp+4], edx

; 439  : 		_Wide = _Newwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newwidth$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	edx, DWORD PTR __Newwidth$[ebp+4]
	mov	DWORD PTR [eax+36], edx

; 440  : 		return (_Oldwidth);

	mov	eax, DWORD PTR __Oldwidth$[ebp]
	mov	edx, DWORD PTR __Oldwidth$[ebp+4]

; 441  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 432  : 		{	// return width

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 		return (_Wide);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 434  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 420  : 		{	// return precision

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 		return (_Prec);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 422  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 389  : 		{	// return format flags

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 390  : 		return (_Fmtfl);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 391  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 351  : 		{	// test if no state bits are set

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 		return (rdstate() == ios_base::goodbit);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	test	eax, eax
	jne	SHORT $LN3@good
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@good
$LN3@good:
	mov	DWORD PTR tv67[ebp], 0
$LN4@good:
	mov	al, BYTE PTR tv67[ebp]

; 353  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 329  : 		{	// return stream state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 330  : 		return (_Mystate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 331  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -20						; size = 8
_this$ = -12						; size = 4
__Msg$3 = -8						; size = 4
__Filtered$ = -4					; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 287  : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 		_State &= _Statmask;

	mov	eax, DWORD PTR __State$[ebp]
	and	eax, 23					; 00000017H
	mov	DWORD PTR __State$[ebp], eax

; 289  : 		_Mystate = _State;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 290  : 		const auto _Filtered = _State & _Except;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
	and	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Filtered$[ebp], ecx

; 291  : 		if (_Filtered)

	je	SHORT $LN8@clear

; 292  : 			{
; 293  : 			if (_Reraise)

	movzx	edx, BYTE PTR __Reraise$[ebp]
	test	edx, edx
	je	SHORT $LN3@clear

; 294  : 				{
; 295  : 				_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN3@clear:

; 296  : 				}
; 297  : 
; 298  : 			const char * _Msg;
; 299  : 			if (_Filtered & ios_base::badbit)

	mov	eax, DWORD PTR __Filtered$[ebp]
	and	eax, 4
	je	SHORT $LN4@clear

; 300  : 				{
; 301  : 				_Msg = "ios_base::badbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	jmp	SHORT $LN5@clear
$LN4@clear:

; 302  : 				}
; 303  : 			else if (_Filtered & ios_base::failbit)

	mov	ecx, DWORD PTR __Filtered$[ebp]
	and	ecx, 2
	je	SHORT $LN6@clear

; 304  : 				{
; 305  : 				_Msg = "ios_base::failbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@

; 306  : 				}
; 307  : 			else

	jmp	SHORT $LN5@clear
$LN6@clear:

; 308  : 				{
; 309  : 				_Msg = "ios_base::eofbit set";

	mov	DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
$LN5@clear:

; 310  : 				}
; 311  : 
; 312  : 			_THROW(failure(_Msg));

	push	1
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR __Msg$3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN8@clear:

; 313  : 			}
; 314  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1failure@ios_base@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0system_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1system_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 238  : 			{	// construct with message

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 			: system_error(_Errcode, _Message)

	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errcode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 238  : 			{	// construct with message

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@

; 239  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 607  : 	{	// return a reference to an object that will live forever

	push	ebp
	mov	ebp, esp

; 608  : 	static_assert(sizeof(void *) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 609  : 	static_assert(alignof(void *) == alignof(once_flag), "TRANSITION, VSO#406237");
; 610  : 	static void * _Flag = nullptr;
; 611  : 	static aligned_union_t<1, _Ty> _Storage;
; 612  : 	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Immortaliz

; 613  : 		{	// _Execute_once should never fail if the callback never fails
; 614  : 		_STD terminate();

	call	_terminate
$LN2@Immortaliz:

; 615  : 		}
; 616  : 
; 617  : 	return (reinterpret_cast<_Ty&>(_Storage));

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
$LN3@Immortaliz:

; 618  : 	}

	pop	ebp
	ret	0
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 516  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 517  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 518  : 			{
; 519  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN1@message

; 520  : 			}
; 521  : 		else

	jmp	SHORT $LN1@message
$LN2@message:

; 522  : 			{
; 523  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@message:

; 524  : 			}
; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 511  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 513  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 505  : 	_Iostream_error_category() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 506  : 		{	// default constructor
; 507  : 		_Addr = _Iostream_addr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 5

; 508  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 495  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 496  : 		return (_Syserror_map(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 490  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic@

; 492  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 484  : 	_Generic_error_category() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 485  : 		{	// default constructor
; 486  : 		_Addr = _Generic_addr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 3

; 487  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1system_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_System_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T2 = -44						; size = 28
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 440  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		: _Mybase(_Errcode, _Message)

	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR __Errcode$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 440  : 		{	// construct from error code and message string

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@

; 441  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T2 = -56						; size = 28
$T3 = -28						; size = 4
tv137 = -24						; size = 4
tv135 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 415  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 		: runtime_error(_Makestr(_Errcode, _Message)),

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR __Errcode$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Errcode$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv137[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 415  : 		{	// construct from error code and message string

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@

; 414  : 		_Mycode(_Errcode)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR __Errcode$[ebp+4]
	mov	DWORD PTR [ecx+16], eax

; 416  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 28
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 28
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 401  : 		{	// compose error message

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 402  : 		if (!_Message.empty())

	lea	ecx, DWORD PTR __Message$[ebp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Makestr

; 403  : 			{
; 404  : 			_Message.append(": ");

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR __Message$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 405  : 			}
; 406  : 
; 407  : 		_Message.append(_Errcode.message());

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Errcode$[ebp]
	call	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
	mov	DWORD PTR tv79[ebp], eax
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv84[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv84[ebp]
	push	eax
	lea	ecx, DWORD PTR __Message$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 408  : 		return (_Message);

	lea	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Message$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 409  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
	lea	ecx, DWORD PTR __Message$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
tv78 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 285  : 	{	// test errors for equality

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 286  : 	return (_Left.category() == _Right.category()

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 287  : 		&& _Left.value() == _Right.value());
; 288  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 246  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 241  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 208  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		: _Myval(_Val),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 207  : 		_Mycat(&_Cat)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 209  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 181  : 		{	// get name of error code

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 182  : 		return (category().message(value()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv67[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv67[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 183  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 174  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 176  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 169  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 171  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 136  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 		: _Myval(_Val),

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 135  : 		_Mycat(&_Cat)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 137  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 94   : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		return (_Addr == _Right._Addr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv67[ebp]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 338  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 340  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 333  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	push	eax
	call	??8std@@YA_NABVerror_condition@0@0@Z	; std::operator==
	add	esp, 8

; 335  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 328  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 330  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 80   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 74   : 	/* constexpr */ error_category() noexcept	// TRANSITION

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		{	// default constructor
; 76   : 		_Addr = reinterpret_cast<uintptr_t>(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 77   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 627  : 	{	// get iostream_category

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?iostream_category@std@@YAABVerror_category@1@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp

; 628  : 	return (_Immortalize<_Iostream_error_category>());

	call	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>

; 629  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?iostream_category@std@@YAABVerror_category@1@XZ:
	mov	eax, OFFSET __ehfuncinfo$?iostream_category@std@@YAABVerror_category@1@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 355  : 	{	// make an error_code

	push	ebp
	mov	ebp, esp

; 356  : 	return (error_code((int)_Errno, iostream_category()));

	call	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
	push	eax
	mov	eax, DWORD PTR __Errno$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 357  : 	}

	pop	ebp
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 12
$T3 = -40						; size = 4
__Lock$4 = -36						; size = 4
__Id$5 = -32						; size = 4
__Psave_guard$6 = -28					; size = 4
__Pf$7 = -24						; size = 4
__Pfmod$8 = -20						; size = 4
__Psave$9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 505  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$9[ebp], eax

; 509  : 
; 510  : 		const size_t _Id = _Facet::id;

	mov	ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$5[ebp], eax

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$7[ebp], eax

; 512  : 
; 513  : 		if (_Pf == nullptr)

	cmp	DWORD PTR __Pf$7[ebp], 0
	jne	$LN2@use_facet

; 514  : 			{
; 515  : 			if (_Psave != nullptr)

	cmp	DWORD PTR __Psave$9[ebp], 0
	je	SHORT $LN3@use_facet

; 516  : 				{
; 517  : 				_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 518  : 				}
; 519  : 			else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Psave$9[ebp]
	push	ecx
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN5@use_facet

; 520  : 				{
; 521  :  #if _HAS_EXCEPTIONS
; 522  : 				_THROW(bad_cast{});	// lazy disallowed

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@XZ			; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 				abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 				}
; 527  : 			else

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 528  : 				{	// queue up lazy facet for destruction
; 529  : 				auto _Pfmod = const_cast<locale::facet *>(_Psave);

	mov	eax, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pfmod$8[ebp], eax

; 530  : 				unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base *>(_Pfmod));

	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 531  : 
; 532  :  #if defined(_M_CEE)
; 533  : 				_Facet_Register_m(_Pfmod);
; 534  :  #else /* defined(_M_CEE) */
; 535  : 				_Facet_Register(_Pfmod);

	mov	edx, DWORD PTR __Pfmod$8[ebp]
	push	edx
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4

; 536  :  #endif /* defined(_M_CEE) */
; 537  : 
; 538  : 				_Pfmod->_Incref();

	mov	eax, DWORD PTR __Pfmod$8[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Pfmod$8[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 539  : 				_Facetptr<_Facet>::_Psave = _Psave;

	mov	ecx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<char> >::_Psave

; 540  : 				_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$9[ebp]
	mov	DWORD PTR __Pf$7[ebp], edx

; 541  : 
; 542  : 				(void) _Psave_guard.release();

	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 543  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 544  : 			}
; 545  : 
; 546  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	mov	eax, DWORD PTR __Pf$7[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T3[ebp]
$LN7@use_facet:

; 547  : 	_END_LOCK()
; 548  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$4[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$6[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$ctype@D@std@@MAE@XZ		; std::ctype<char>::~ctype<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2713 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2714 : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2715 : 		_CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2716 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 2717 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2707 : 		{	// narrow char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2708 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 2709 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2700 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2701 : 		_Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2702 : 		_CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2703 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 2704 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2694 : 		{	// widen char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2695 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 2696 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2683 : 		{	// convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2684 : 		_Adl_verify_range((const _Elem *)_First, _Last);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2685 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@do_toupper
$LN2@do_toupper:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$LN4@do_toupper:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@do_toupper

; 2686 : 			{
; 2687 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__Toupper
	add	esp, 8
	mov	edx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [edx], al

; 2688 : 			}

	jmp	SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2689 : 
; 2690 : 		return ((const _Elem *)_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2691 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2677 : 		{	// convert element to upper case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2678 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Toupper
	add	esp, 8

; 2679 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2666 : 		{	// convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2667 : 		_Adl_verify_range((const _Elem *)_First, _Last);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
	add	esp, 8

; 2668 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@do_tolower
$LN2@do_tolower:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$LN4@do_tolower:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@do_tolower

; 2669 : 			{
; 2670 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__Tolower
	add	esp, 8
	mov	edx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [edx], al

; 2671 : 			}

	jmp	SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2672 : 
; 2673 : 		return ((const _Elem *)_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2674 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2660 : 		{	// convert element to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2661 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Tolower
	add	esp, 8

; 2662 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2650 : 		{	// free any allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2651 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN2@Tidy

; 2652 : 			_CSTD free((void *)_Ctype._Table);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_free
	add	esp, 4
	jmp	SHORT $LN3@Tidy
$LN2@Tidy:

; 2653 : 		else if (_Ctype._Delfl < 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jge	SHORT $LN3@Tidy

; 2654 : 			delete[] _Ctype._Table;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@Tidy:

; 2655 : 
; 2656 : 		_CSTD free(_Ctype._LocaleName);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_free
	add	esp, 4

; 2657 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2645 : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2646 : 		_Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 2647 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2640 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$ctype@D@std@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2641 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$ctype@D@std@@IAEXXZ		; std::ctype<char>::_Tidy

; 2642 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ctype@D@std@@MAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ctype@D@std@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv94 = -32						; size = 4
tv131 = -28						; size = 4
tv88 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2618 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR $T5[ebp], 0

; 2619 : 		if (_Ppf != nullptr && *_Ppf == nullptr)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	$LN2@Getcat
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@Getcat

; 2620 : 			*_Ppf = new ctype<_Elem>(

	push	24					; 00000018H
	call	??2_Crt_new_delete@std@@SAPAXI@Z	; std::_Crt_new_delete::operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN4@Getcat
	push	0
	mov	ecx, DWORD PTR __Ploc$[ebp]
	call	?c_str@locale@std@@QBEPBDXZ		; std::locale::c_str
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T5[ebp]
	or	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z	; std::ctype<char>::ctype<char>
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	DWORD PTR tv88[ebp], 0
$LN5@Getcat:
	mov	ecx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	and	ecx, 1
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2621 : 				_Locinfo(_Ploc->c_str()));
; 2622 : 		return (_X_CTYPE);

	mov	eax, 2

; 2623 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2612 : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2611 : 		: ctype_base(_Refs)

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ctype_base@std@@QAE@I@Z		; std::ctype_base::ctype_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2612 : 		{	// construct from current locale

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$ctype@D@std@@6B@

; 2613 : 		_Init(_Lobj);

	mov	edx, DWORD PTR __Lobj$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init

; 2614 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
__ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2571 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2572 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 2573 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2565 : 		{	// widen char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2566 : 		return (do_widen(_Byte));

	movzx	eax, BYTE PTR __Byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 2567 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2507 : 		{	// test if element fits any mask classifications

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2508 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	movzx	eax, BYTE PTR __Ch$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movsx	eax, WORD PTR [edx+eax*2]
	movsx	ecx, WORD PTR __Maskval$[ebp]
	and	eax, ecx
	je	SHORT $LN3@is
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@is
$LN3@is:
	mov	DWORD PTR tv73[ebp], 0
$LN4@is:
	mov	al, BYTE PTR tv73[ebp]

; 2509 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2217 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2218 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	esp, ebp
	pop	ebp
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2213 : 		{	// default constructor

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2212 : 		: locale::facet(_Refs)

	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet

; 2213 : 		{	// default constructor

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@

; 2214 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 615  : 	{	// check that [_First, _Last) forms an iterator range

	push	ebp
	mov	ebp, esp
	push	ecx

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z ; std::_Adl_verify_range1<char const *,char const *>
	add	esp, 12					; 0000000cH

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 23   : 	{	// return smaller of _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@Min_value
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@Min_value
$LN3@Min_value:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
tv83 = -20						; size = 4
__Ptr0$1 = -16						; size = 4
__Facptr$ = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 435  : 		{	// look up a facet in locale object

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Id$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Id$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN7@Getfacet
$LN6@Getfacet:
	mov	DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR __Facptr$[ebp], edx

; 437  : 			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
; 438  : 		if (_Facptr != nullptr || !_Ptr->_Xparent)

	cmp	DWORD PTR __Facptr$[ebp], 0
	jne	SHORT $LN4@Getfacet
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN2@Getfacet
$LN4@Getfacet:

; 439  : 			return (_Facptr);	// found facet or not transparent

	mov	eax, DWORD PTR __Facptr$[ebp]
	jmp	SHORT $LN1@Getfacet

; 440  : 		else

	jmp	SHORT $LN1@Getfacet
$LN2@Getfacet:

; 441  : 			{	// look in current locale
; 442  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	mov	DWORD PTR __Ptr0$1[ebp], eax

; 443  : 			return (_Id < _Ptr0->_Facetcount

	mov	eax, DWORD PTR __Ptr0$1[ebp]
	mov	ecx, DWORD PTR __Id$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	edx, DWORD PTR __Ptr0$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Id$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN9@Getfacet
$LN8@Getfacet:
	mov	DWORD PTR tv83[ebp], 0
$LN9@Getfacet:
	mov	eax, DWORD PTR tv83[ebp]
$LN1@Getfacet:

; 444  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 445  : 				: nullptr);	// no entry in current locale
; 446  : 			}
; 447  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 430  : 		{	// return locale name as NTBS

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 		return (_Ptr == nullptr ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@c_str
	mov	DWORD PTR tv70[ebp], OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 24					; 00000018H
	call	?c_str@?$_Yarn@D@std@@QBEPBDXZ		; std::_Yarn<char>::c_str
	mov	DWORD PTR tv70[ebp], eax
$LN4@c_str:
	mov	eax, DWORD PTR tv70[ebp]

; 432  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 408  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1locale@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		if (_Ptr != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@locale

; 410  : 			delete _Ptr->_Decref();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@locale
	push	1
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN3@locale
$LN4@locale:
	mov	DWORD PTR tv84[ebp], 0
$LN3@locale:

; 411  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 303  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0locale@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		: _Ptr(_Right._Ptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 304  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 305  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Odtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 4
	jne	SHORT $LN3@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3_Crt_new_delete@std@@SAXPAX@Z	; std::_Crt_new_delete::operator delete
	add	esp, 4
	jmp	SHORT $LN2@scalar
$LN3@scalar:
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 176  : 			{	// ensure that derived classes can be destroyed properly

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 177  : 			}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Facet_base@std@@UAE@XZ		; std::_Facet_base::~_Facet_base
	mov	esp, ebp
	pop	ebp
	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 172  : 			{	// construct with initial reference count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Facet_base@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 171  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 173  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 157  : 			{	// decrement use count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 			if (_MT_DECR(_Myrefs) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	dec	ecx
	jne	SHORT $LN2@Decref

; 159  : 				{
; 160  : 				return (this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@Decref
$LN2@Decref:

; 161  : 				}
; 162  : 
; 163  : 			return (nullptr);

	xor	eax, eax
$LN1@Decref:

; 164  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 152  : 			{	// increment use count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 			_MT_INCR(_Myrefs);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	lock	 inc	 DWORD PTR [eax]

; 154  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -8						; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 115  : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 			if (_Id == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@operator

; 120  : 						{
; 121  : 						_Id = static_cast<size_t>(++_Id_cnt);

	mov	edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	edx, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	DWORD PTR [eax], ecx
$LN3@operator:

; 122  : 						}
; 123  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN2@operator:

; 124  : 				}
; 125  : 			return (_Id);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 126  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 111  : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			: _Id(_Val)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 112  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??3_Crt_new_delete@std@@SAXPAX@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??3_Crt_new_delete@std@@SAXPAX@Z PROC			; std::_Crt_new_delete::operator delete, COMDAT

; 79   : 		{	// replace operator delete

	push	ebp
	mov	ebp, esp

; 80   : 		_CSTD free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 81   : 		}

	pop	ebp
	ret	0
??3_Crt_new_delete@std@@SAXPAX@Z ENDP			; std::_Crt_new_delete::operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z
_TEXT	SEGMENT
tv71 = -4						; size = 4
__Size$ = 8						; size = 4
___formal$ = 12						; size = 4
??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z PROC	; std::_Crt_new_delete::operator new, COMDAT

; 74   : 		{	// replace nothrow operator new

	push	ebp
	mov	ebp, esp
	push	ecx

; 75   : 		return (_malloc_dbg(_Size > 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__));

	cmp	DWORD PTR __Size$[ebp], 0
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator:
	push	75					; 0000004bH
	push	OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	__malloc_dbg
	add	esp, 16					; 00000010H

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z ENDP	; std::_Crt_new_delete::operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??2_Crt_new_delete@std@@SAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Size$ = 8						; size = 4
??2_Crt_new_delete@std@@SAPAXI@Z PROC			; std::_Crt_new_delete::operator new, COMDAT

; 66   : 		{	// replace operator new

	push	ebp
	mov	ebp, esp
	push	ecx

; 67   : 		void * _Ptr = operator new(_Size, nothrow);

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	eax, DWORD PTR __Size$[ebp]
	push	eax
	call	??2_Crt_new_delete@std@@SAPAXIABUnothrow_t@1@@Z ; std::_Crt_new_delete::operator new
	add	esp, 8
	mov	DWORD PTR __Ptr$[ebp], eax

; 68   : 		if (!_Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN2@operator

; 69   : 			_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN2@operator:

; 70   : 		return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN3@operator:

; 71   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??2_Crt_new_delete@std@@SAPAXI@Z ENDP			; std::_Crt_new_delete::operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Facet_base@std@@UAE@XZ		; std::_Facet_base::~_Facet_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 4168 : 		{	// discard any string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4169 : 		if (_Myptr != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 4170 : 
; 4171 :  #ifdef _DEBUG
; 4172 : 			_free_dbg(_Myptr, _CRT_BLOCK);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__free_dbg
	add	esp, 8
$LN2@Tidy:

; 4173 : 
; 4174 :  #else /* _DEBUG */
; 4175 : 			_CSTD free(_Myptr);
; 4176 :  #endif /* _DEBUG */
; 4177 : 
; 4178 : 		_Myptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 4179 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 4142 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Yarn@_W@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4143 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Yarn@_W@std@@AAEXXZ		; std::_Yarn<wchar_t>::_Tidy

; 4144 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Yarn@_W@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Yarn@_W@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 4087 : 		{	// default construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4086 : 		: _Myptr(nullptr), _Nul(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+4], cx

; 4088 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 4168 : 		{	// discard any string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4169 : 		if (_Myptr != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 4170 : 
; 4171 :  #ifdef _DEBUG
; 4172 : 			_free_dbg(_Myptr, _CRT_BLOCK);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__free_dbg
	add	esp, 8
$LN2@Tidy:

; 4173 : 
; 4174 :  #else /* _DEBUG */
; 4175 : 			_CSTD free(_Myptr);
; 4176 :  #endif /* _DEBUG */
; 4177 : 
; 4178 : 		_Myptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 4179 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 4152 : 		{	// return NTBS

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4153 : 		return (_Myptr != nullptr ? _Myptr : &_Nul);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@c_str
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@c_str:
	mov	eax, DWORD PTR tv68[ebp]

; 4154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 4142 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Yarn@D@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4143 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Yarn@D@std@@AAEXXZ		; std::_Yarn<char>::_Tidy

; 4144 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Yarn@D@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_Yarn@D@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 4087 : 		{	// default construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4086 : 		: _Myptr(nullptr), _Nul(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 4088 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 171  : 		{	// return true name (no C source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true@

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 166  : 		{	// return false name (no C source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 126  : 		{	// return localeconv stuff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		return (localeconv());

	call	_localeconv

; 128  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -92						; size = 44
$T2 = -48						; size = 44
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getcvt
	add	esp, 4
	mov	ecx, 11					; 0000000bH
	mov	esi, eax
	lea	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	ecx, 11					; 0000000bH
	lea	esi, DWORD PTR $T2[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 123  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 16
$T2 = -20						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getctype
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T2[ebp+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T2[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 118  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		_Locinfo_dtor(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
	add	esp, 4

; 96   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 		: _Lock(_LOCK_LOCALE)

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 76   : 		{	// construct from NTBS

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::_Yarn<char>
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 77   : 		if (_Pch == nullptr)

	cmp	DWORD PTR __Pch$[ebp], 0
	jne	SHORT $LN2@Locinfo

; 78   : 			_THROW(runtime_error("bad locale name"));

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Locinfo:

; 79   : 		_Locinfo_ctor(this, _Pch);

	mov	ecx, DWORD PTR __Pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 80   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_cast@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  :         : exception("bad cast", 1)

	push	1
	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 131  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		: _Mybase(_Message)

	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception

; 170  : 		{	// construct from message string

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 165  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 		: _Mybase(_Message.c_str())

	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBD@Z		; std::exception::exception

; 165  : 		{	// construct from message string

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@

; 166  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4003 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp

; 4004 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 4005 : 		}

	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Ptr$1 = -20						; size = 4
__Al$2 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T3 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3984 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3985 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 3986 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3987 : 		if (_My_data._Large_string_engaged())

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Ptr$1[ebp], edx

; 3990 : 			auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$2[ebp], eax

; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$2[ebp]
	push	ecx
	call	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$2[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 3993 : 			}
; 3994 : 
; 3995 : 		_My_data._Mysize = 0;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+20], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 3997 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3998 : 		// write can alias this
; 3999 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR __My_data$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 4000 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3974 : 		{	// initialize basic_string data members

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3975 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3976 : 		_My_data._Mysize = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR __My_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3981 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3968 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3969 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3971 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Al$ = -16						; size = 4
__Ptr$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 3954 : 		{	// release any held storage and return to small string mode

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3955 : 			// pre: *this is in large string mode
; 3956 : 			// pre: this is small enough to return to small string mode
; 3957 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3958 : 		_My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3959 : 		const pointer _Ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 3960 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 3961 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));

	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 3962 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 3963 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 3964 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+24], 15			; 0000000fH

; 3965 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
__My_data$ = -20					; size = 4
__Masked$ = -16						; size = 4
_this$ = -12						; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3866 : 		{	// determines the next array size to allocate

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3867 : 		const size_type _Max = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 3868 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Requested$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Masked$[ebp], eax

; 3870 : 		if (_Masked > _Max)

	mov	ecx, DWORD PTR __Masked$[ebp]
	cmp	ecx, DWORD PTR __Max$[ebp]
	jbe	SHORT $LN2@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR __Old$[ebp], eax

; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	ecx, DWORD PTR __Old$[ebp]
	shr	ecx, 1
	mov	edx, DWORD PTR __Max$[ebp]
	sub	edx, ecx
	cmp	DWORD PTR __Old$[ebp], edx
	jbe	SHORT $LN3@Calculate_

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Old$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR __Masked$[ebp]
	push	edx
	call	??$_Max_value@I@std@@YAABIABI0@Z	; std::_Max_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
$LN1@Calculate_:

; 3882 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3370 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3371 : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv67[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv67[ebp]

; 3372 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Old_size$1 = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -1						; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3336 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3337 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3338 : 		if (_My_data._Mysize > _Newcap)

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newcap$[ebp]
	jbe	SHORT $LN2@reserve

; 3339 : 			{	// requested capacity is not large enough for current size, ignore
; 3340 : 			return;	// nothing to do

	jmp	SHORT $LN1@reserve
$LN2@reserve:

; 3341 : 			}
; 3342 : 
; 3343 : 		if (_My_data._Myres == _Newcap)

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR __Newcap$[ebp]
	jne	SHORT $LN3@reserve

; 3344 : 			{	// we're already at the requested capacity
; 3345 : 			return;	// nothing to do

	jmp	SHORT $LN1@reserve
$LN3@reserve:

; 3346 : 			}
; 3347 : 
; 3348 : 		if (_My_data._Myres < _Newcap)

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Newcap$[ebp]
	jae	SHORT $LN4@reserve

; 3349 : 			{	// reallocate to grow
; 3350 : 			const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$1[ebp], ecx

; 3351 : 			_Reallocate_grow_by(_Newcap - _Old_size,

	xor	edx, edx
	mov	BYTE PTR $T2[ebp], dl
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newcap$[ebp]
	sub	ecx, DWORD PTR __Old_size$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3352 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3353 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3354 : 				});
; 3355 : 
; 3356 : 			_My_data._Mysize = _Old_size;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Old_size$1[ebp]
	mov	DWORD PTR [edx+20], eax

; 3357 : 			return;

	jmp	SHORT $LN1@reserve
$LN4@reserve:

; 3358 : 			}
; 3359 : 
; 3360 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

	cmp	DWORD PTR __Newcap$[ebp], 16		; 00000010H
	jae	SHORT $LN1@reserve
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@reserve

; 3361 : 			{	// deallocate everything; switch back to "small" mode
; 3362 : 			_Become_small();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
$LN1@reserve:

; 3363 : 			return;
; 3364 : 			}
; 3365 : 
; 3366 : 		// ignore requests to reserve to [_BUF_SIZE, _Myres)
; 3367 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 3318 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3319 : 		const size_type _Old_size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Old_size$[ebp], eax

; 3320 : 		if (_Newsize <= _Old_size)

	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR __Old_size$[ebp]
	ja	SHORT $LN2@resize

; 3321 : 			{
; 3322 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 3323 : 			}
; 3324 : 		else

	jmp	SHORT $LN1@resize
$LN2@resize:

; 3325 : 			{
; 3326 : 			append(_Newsize - _Old_size, _Ch);

	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, DWORD PTR __Old_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@resize:

; 3327 : 			}
; 3328 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Storage_max$ = -16					; size = 4
__Alloc_max$ = -12					; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3306 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3307 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	add	esp, 4
	mov	DWORD PTR __Alloc_max$[ebp], eax

; 3308 : 		const size_type _Storage_max = // can always store small string
; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));

	mov	DWORD PTR $T3[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __Alloc_max$[ebp]
	push	ecx
	call	??$_Max_value@I@std@@YAABIABI0@Z	; std::_Max_value<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Storage_max$[ebp], edx

; 3310 : 		return (_Min_value(

	mov	eax, DWORD PTR __Storage_max$[ebp]
	sub	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3301 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	eax, DWORD PTR [eax+20]

; 3303 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3279 : 		{	// return pointer to null-terminated immutable array

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3280 : 		return (this->_Get_data()._Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	ecx, eax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3281 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:
	mov	eax, OFFSET __ehfuncinfo$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Ptr$1 = -16						; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3227 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3228 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 3229 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 3230 : 		if (_Old_size < _My_data._Myres)

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Old_size$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jae	SHORT $LN2@push_back

; 3231 : 			{
; 3232 : 			_My_data._Mysize = _Old_size + 1;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 3233 : 			_Elem * const _Ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Ptr$1[ebp], eax

; 3234 : 			_Traits::assign(_Ptr[_Old_size], _Ch);

	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	add	ecx, DWORD PTR __Old_size$[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3235 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_size$[ebp]
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 3236 : 			return;

	jmp	SHORT $LN1@push_back
$LN2@push_back:

; 3237 : 			}
; 3238 : 
; 3239 : 		_Reallocate_grow_by(1,

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1@push_back:

; 3240 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 3241 : 				const _Elem _Ch) {
; 3242 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3243 : 			_Traits::assign(_New_ptr[_Old_size], _Ch);
; 3244 : 			_Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3245 : 			}, _Ch);
; 3246 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3210 : 		{	// subscript immutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3211 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 3212 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3213 : 		_STL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	3213					; 00000c8dH
	push	OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	push	0
	push	3213					; 00000c8dH
	push	OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1LO@NPPEKPAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr?$AAi@
	push	OFFSET ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	eax, eax
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	ecx, ecx
	jne	SHORT $LN4@operator

; 3214 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 3215 : 		return (_My_data._Myptr()[_Off]);

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 3216 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3201 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3202 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 3203 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3204 : 		_STL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN7@operator
	jmp	SHORT $LN2@operator
$LN7@operator:
	push	OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	3204					; 00000c84H
	push	OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN11@operator
	int	3
$LN11@operator:
	push	0
	push	3204					; 00000c84H
	push	OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1LO@NPPEKPAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr?$AAi@
	push	OFFSET ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	eax, eax
	jne	SHORT $LN7@operator
$LN2@operator:
	xor	ecx, ecx
	jne	SHORT $LN4@operator

; 3205 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 3206 : 		return (_My_data._Myptr()[_Off]);

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 3207 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2833 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2834 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2835 : 		_My_data._Check_offset(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 2836 : 		_Eos(_Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2837 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 2838 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -24					; size = 4
_this$ = -20						; size = 4
__Insert_at$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
$T3 = -1						; size = 1
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2786 : 		{	// insert _Count * _Ch at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2787 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2788 : 		_My_data._Check_offset(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 2789 : 		const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Old_size$[ebp], edx

; 2790 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], ecx
	ja	SHORT $LN2@insert

; 2791 : 			{
; 2792 : 			_My_data._Mysize = _Old_size + _Count;

	mov	edx, DWORD PTR __Old_size$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], edx

; 2793 : 			_Elem * const _Old_ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 2794 : 			_Elem * const _Insert_at = _Old_ptr + _Off;

	mov	ecx, DWORD PTR __Old_ptr$1[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Insert_at$2[ebp], ecx

; 2795 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	mov	edx, DWORD PTR __Old_size$[ebp]
	sub	edx, DWORD PTR __Off$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Insert_at$2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Insert_at$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	?move@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 2796 : 			_Traits::assign(_Insert_at, _Count, _Ch); // fill hole

	movzx	edx, BYTE PTR __Ch$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Insert_at$2[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2797 : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@insert
$LN2@insert:

; 2798 : 			}
; 2799 : 
; 2800 : 		return (_Reallocate_grow_by(_Count,

	xor	edx, edx
	mov	BYTE PTR $T3[ebp], dl
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN1@insert:

; 2801 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2802 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {
; 2803 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2804 : 			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 2805 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2806 : 			}, _Off, _Count, _Ch));
; 2807 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2680 : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2681 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2682 : 		if (_Count <= _My_data._Myres)

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	ja	SHORT $LN2@assign

; 2683 : 			{
; 2684 : 			_Elem * const _Old_ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 2685 : 			_My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2686 : 			_Traits::assign(_Old_ptr, _Count, _Ch);

	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2687 : 			_Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2688 : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 2689 : 			}
; 2690 : 
; 2691 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
$LN1@assign:

; 2692 : 			_Traits::assign(_New_ptr, _Count, _Ch);
; 2693 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2694 : 			}, _Ch));
; 2695 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2675 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIQBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2677 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2657 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2658 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2659 : 		if (_Count <= _My_data._Myres)

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	ja	SHORT $LN2@assign

; 2660 : 			{
; 2661 : 			_Elem * const _Old_ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 2662 : 			_My_data._Mysize = _Count;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2663 : 			_Traits::move(_Old_ptr, _Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Old_ptr$1[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 2664 : 			_Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2665 : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@assign
$LN2@assign:

; 2666 : 			}
; 2667 : 
; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 2669 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2671 : 			}, _Ptr));
; 2672 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -20					; size = 4
_this$ = -16						; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2596 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2597 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2598 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 2599 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	ja	SHORT $LN2@append

; 2600 : 			{
; 2601 : 			_My_data._Mysize = _Old_size + _Count;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 2602 : 			_Elem * const _Old_ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 2603 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?assign@?$char_traits@D@std@@SAPADQADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 2604 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2605 : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 2606 : 			}
; 2607 : 
; 2608 : 		return (_Reallocate_grow_by(_Count,

	xor	edx, edx
	mov	BYTE PTR $T2[ebp], dl
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN1@append:

; 2609 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2610 : 				const size_type _Count, const _Elem _Ch) {
; 2611 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2612 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2613 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2614 : 			}, _Count, _Ch));
; 2615 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2591 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2592 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIQBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@I@std@@YAII@Z		; std::_Convert_size<unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2593 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -20					; size = 4
_this$ = -16						; size = 4
__Old_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2569 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2570 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2571 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Old_size$[ebp], ecx

; 2572 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, DWORD PTR __Old_size$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	ja	SHORT $LN2@append

; 2573 : 			{
; 2574 : 			_My_data._Mysize = _Old_size + _Count;

	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 2575 : 			_Elem * const _Old_ptr = _My_data._Myptr();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Old_ptr$1[ebp], eax

; 2576 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Old_ptr$1[ebp]
	add	edx, DWORD PTR __Old_size$[ebp]
	push	edx
	call	?move@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 2577 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Old_size$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Old_ptr$1[ebp]
	push	ecx
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2578 : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN1@append
$LN2@append:

; 2579 : 			}
; 2580 : 
; 2581 : 		return (_Reallocate_grow_by(_Count,

	xor	edx, edx
	mov	BYTE PTR $T2[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2582 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2583 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2584 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2585 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2586 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2587 : 			}, _Ptr, _Count));
; 2588 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right_data$ = -4					; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2537 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2538 : 		auto& _Right_data = _Right._Get_data();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __Right_data$[ebp], eax

; 2539 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2540 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2512 : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2513 : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2514 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2459 : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2460 : 		_Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2461 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
__New_capacity$ = -32					; size = 4
__New_array$ = -28					; size = 4
__Right_ptr$ = -24					; size = 4
__Al$ = -20						; size = 4
__Right_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Right_size$ = -8					; size = 4
__My_data$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2394 : 		{	// assign by copying data stored in _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2395 : 			// pre: this != &_Right
; 2396 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2397 : 		auto& _My_data = this->_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __My_data$[ebp], eax

; 2398 : 		auto& _Right_data = _Right._Get_data();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __Right_data$[ebp], eax

; 2399 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Right_size$[ebp], ecx

; 2400 : 		const _Elem * const _Right_ptr = _Right_data._Myptr();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	DWORD PTR __Right_ptr$[ebp], eax

; 2401 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	DWORD PTR __Right_size$[ebp], 16	; 00000010H
	jae	SHORT $LN2@Construct_

; 2402 : 			{	// stay small, don't allocate
; 2403 : 			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);

	push	16					; 00000010H
	mov	edx, DWORD PTR __Right_ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2404 : 			_My_data._Mysize = _Right_size;

	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR __Right_size$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2405 : 			_My_data._Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2406 : 			return;

	jmp	$LN1@Construct_
$LN2@Construct_:

; 2407 : 			}
; 2408 : 
; 2409 : 		auto& _Al = this->_Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR __Right_size$[ebp]
	or	ecx, 15					; 0000000fH
	mov	DWORD PTR $T1[ebp], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Min_value@I@std@@YAABIABI0@Z	; std::_Min_value<unsigned int>
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __New_capacity$[ebp], ecx

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	mov	edx, DWORD PTR __New_capacity$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_array$[ebp], eax

; 2412 : 		_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);

	lea	eax, DWORD PTR __New_array$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	call	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
	add	esp, 12					; 0000000cH

; 2413 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Right_ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_array$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 2414 : 		_My_data._Mysize = _Right_size;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Right_size$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2415 : 		_My_data._Myres = _New_capacity;

	mov	edx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN1@Construct_:

; 2416 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__My_data_mem$ = -28					; size = 4
__Right_data_mem$ = -24					; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2344 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2345 : 			// pre: this != &_Right
; 2346 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2347 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2348 : 		auto& _Right_data = _Right._Get_data();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	DWORD PTR __Right_data$[ebp], eax

; 2349 : 
; 2350 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2351 : 		if (_Right_data._Large_string_engaged())

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Assign_rv_

; 2352 : 			{	// take ownership of _Right's iterators along with its buffer
; 2353 : 			this->_Swap_all(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all

; 2354 : 			}
; 2355 : 		else

	jmp	SHORT $LN3@Assign_rv_
$LN2@Assign_rv_:

; 2356 : 			{
; 2357 : 			_Right._Orphan_all();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
$LN3@Assign_rv_:

; 2358 : 			}
; 2359 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2360 : 
; 2361 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2362 : 			+ _Memcpy_move_offset;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __My_data_mem$[ebp], eax

; 2363 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2364 : 			+ _Memcpy_move_offset;

	mov	edx, DWORD PTR __Right_data$[ebp]
	push	edx
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __Right_data_mem$[ebp], eax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	push	24					; 00000018H
	mov	eax, DWORD PTR __Right_data_mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data_mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2366 : 		_Right._Tidy_init();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2367 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2321 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2322 : 			// pre: this != &_Right
; 2323 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2324 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2325 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2315 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2316 : 		*this = _STD move(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2317 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 2318 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2301 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2302 : 		if (this != _STD addressof(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	cmp	DWORD PTR _this$[ebp], eax
	je	SHORT $LN2@operator

; 2303 : 			{	// different, assign it
; 2304 : 			_Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2305 : 			this->_Move_alloc(_Right._Getal());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc

; 2306 : 			// tag dispatch to remove unnecessary exception handling codegen in the
; 2307 : 			// equal allocators case
; 2308 : 			_Assign_rv_contents(_STD move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});

	xor	ecx, ecx
	mov	BYTE PTR $T2[ebp], cl
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
$LN2@operator:

; 2309 : 			}
; 2310 : 
; 2311 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 2312 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2268 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2267 : 		: _Mybase(_STD move(_Right._Getal()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2270 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2201 : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2202 : 		_Tidy_init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2203 : 		assign(_Count, _Ch);

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2204 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2183 : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2182 : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2184 : 		_Tidy_init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2185 : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2186 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2142 : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2141 : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >

; 2143 : 		_Tidy_init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2144 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2130 : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2131 : 		_Construct_lv_contents(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2132 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 308  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 303  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 298  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 293  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2047 : 		{	// return const reference to _String_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2048 : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 2049 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2042 : 		{	// return reference to _String_val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2043 : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second

; 2044 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2037 : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2038 : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 2039 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2032 : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 2034 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all, COMDAT
; _this$ = ecx

; 2027 : 		{	// swap all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2028 : 		_Get_data()._Swap_all(_Right._Get_data());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	ecx, eax
	call	?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all

; 2029 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 2022 : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2023 : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2024 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 2011 : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2012 : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data

; 2013 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 1997 : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1998 : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 1999 : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 2000 : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 2001 : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Proxy_allocator$[ebp]
	push	eax
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
	add	esp, 8

; 2002 : 		_Myproxy() = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 2003 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1989 : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1990 : 		_Alproxy _Proxy_allocator(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 1992 : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Proxy_allocator$[ebp]
	push	ecx
	call	??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi

; 1994 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Reload$ = -2						; size = 1
tv72 = -1						; size = 1
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 1971 : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1972 : 		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
; 1973 : 			&& _Getal() != _Al;

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Move_alloc
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z	; std::operator!=<char,char>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@Move_alloc
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN6@Move_alloc
$LN5@Move_alloc:
	mov	BYTE PTR tv72[ebp], 0
$LN6@Move_alloc:
	mov	al, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Reload$[ebp], al

; 1974 : 
; 1975 : 		if (_Reload)

	movzx	ecx, BYTE PTR __Reload$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@Move_alloc

; 1976 : 			{
; 1977 : 			_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
$LN2@Move_alloc:

; 1978 : 			}
; 1979 : 
; 1980 : 		_Pocma(_Getal(), _Al);

	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
	add	esp, 8

; 1981 : 
; 1982 : 		if (_Reload)

	movzx	eax, BYTE PTR __Reload$[ebp]
	test	eax, eax
	je	SHORT $LN1@Move_alloc

; 1983 : 			{
; 1984 : 			_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
$LN1@Move_alloc:

; 1985 : 			}
; 1986 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1948 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1949 : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 1950 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1934 : 		{	// default construct allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1933 : 		: _Mypair(_Zero_then_variadic_args_t())

	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1935 : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 1936 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1861 : 			{	// user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1862 : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1856 : 		_Bxty()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1845 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp

; 1846 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 1847 : 		}

	pop	ebp
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 1829 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1830 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN3@Check_offs

; 1831 : 			{
; 1832 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN3@Check_offs:

; 1833 : 			}
; 1834 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1824 : 		{	// returns whether the large string mode (allocated memory) is engaged

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Large_stri
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Large_stri
$LN3@Large_stri:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
	mov	al, BYTE PTR tv66[ebp]

; 1826 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1813 : 		{	// determine current pointer to buffer for immutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 1815 : 		if (_Large_string_engaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Myptr

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 1821 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1802 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1803 : 		value_type * _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 1804 : 		if (_Large_string_engaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Myptr

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 1810 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1786 : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 1783 : 		: _Bx(),

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 1784 : 		_Mysize(0),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1785 : 		_Myres(0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 1787 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 896  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 897  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 898  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 891  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	or	eax, -1

; 893  : 		}

	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1203 : 	{	// convert size_t to size_t, unchanged

	push	ebp
	mov	ebp, esp

; 1204 : 	return (_Len);

	mov	eax, DWORD PTR __Len$[ebp]

; 1205 : 	}

	pop	ebp
	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_container$ = -12					; size = 4
__Back_shift$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 114  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 115  : 	_Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, 4
	imul	eax, edx, -1
	mov	ecx, DWORD PTR __Ptr_user$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR __Ptr_container$[ebp], edx
$LN4@Adjust_man:

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN7@Adjust_man
	jmp	SHORT $LN2@Adjust_man
$LN7@Adjust_man:
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	122					; 0000007aH
	push	OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	push	0
	push	122					; 0000007aH
	push	OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN7@Adjust_man
$LN2@Adjust_man:
	xor	edx, edx
	jne	SHORT $LN4@Adjust_man

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN13@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN13@Adjust_man
	jmp	SHORT $LN8@Adjust_man
$LN13@Adjust_man:
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	132					; 00000084H
	push	OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	push	0
	push	132					; 00000084H
	push	OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN8@Adjust_man:
	xor	ecx, ecx
	jne	SHORT $LN10@Adjust_man

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [edx], eax

; 134  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   : 		{

	push	ebp
	mov	ebp, esp

; 52   : 		return (::operator new(_Bytes));

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 53   : 		}

	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   : 	{	// gets the size of _Count copies of a type with size 1

	push	ebp
	mov	ebp, esp

; 38   : 	return (_Count);

	mov	eax, DWORD PTR __Count$[ebp]

; 39   : 	}

	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnext$1 = -4						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 191  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN13@Orphan_me

; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	mov	DWORD PTR __Pnext$1[ebp], edx
$LN2@Orphan_me:

; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_me
	mov	ecx, DWORD PTR __Pnext$1[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _this$[ebp]
	je	SHORT $LN6@Orphan_me

; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN2@Orphan_me
$LN6@Orphan_me:

; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

	mov	edx, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN9@Orphan_me
	jmp	SHORT $LN4@Orphan_me
$LN9@Orphan_me:
	push	OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	199					; 000000c7H
	push	OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
	push	2
	call	__CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jne	SHORT $LN14@Orphan_me
	int	3
$LN14@Orphan_me:
	push	0
	push	199					; 000000c7H
	push	OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
	push	OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
	call	__invalid_parameter
	add	esp, 20					; 00000014H
	xor	ecx, ecx
	jne	SHORT $LN9@Orphan_me
$LN4@Orphan_me:
	xor	edx, edx
	jne	SHORT $LN6@Orphan_me

; 200  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 201  : 			_Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN13@Orphan_me:

; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 186  : 		{	// get address of remaining iterator chain

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 		return (&_Mynextiter);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 181  : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getcont
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 183  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 176  : 		{	// disown owning container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		_Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 178  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -28						; size = 4
__Lock$3 = -24						; size = 4
__Parent_proxy$4 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 147  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		if (_Parent == nullptr)

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN2@Adopt

; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 152  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 155  : 		else

	jmp	SHORT $LN5@Adopt
$LN2@Adopt:

; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$4[ebp], ecx

; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Parent_proxy$4[ebp]
	je	SHORT $LN5@Adopt

; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 163  : 				_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Parent_proxy$4[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 165  : 				_Parent_proxy->_Myfirstiter = this;

	mov	ecx, DWORD PTR __Parent_proxy$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 166  : 				_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$4[ebp]
	mov	DWORD PTR [eax], ecx

; 167  : 				}

	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN5@Adopt:

; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 139  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Iterator_base12@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 142  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Iterator_base12@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 109  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
__Temp$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 229  : 	{	// swap all iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$[ebp], ecx

; 235  : 	_Myproxy = _Right._Myproxy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 236  : 	_Right._Myproxy = _Temp;

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Temp$[ebp]
	mov	DWORD PTR [edx], eax

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

	mov	edx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@Swap_all:

; 242  : 	}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$2 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	mov	DWORD PTR __Pnext$3[ebp], edx
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)

	mov	eax, DWORD PTR __Pnext$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$3[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@Orphan_all:
	mov	ecx, DWORD PTR __Pnext$3[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@Orphan_all

; 222  : 			(*_Pnext)->_Myproxy = nullptr;

	mov	edx, DWORD PTR __Pnext$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], 0

; 224  : 		}

	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Container_base12::_Getpfirst, COMDAT
; _this$ = ecx

; 95   : 		{	// get address of iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getpfirst
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getpfirst
$LN3@Getpfirst:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	mov	DWORD PTR tv68[ebp], edx
$LN4@Getpfirst:
	mov	eax, DWORD PTR tv68[ebp]

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Container_base12::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 81   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		: _Myproxy(nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 82   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 69   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 70   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 540  : 		{	// return end-of-file metacharacter

	push	ebp
	mov	ebp, esp

; 541  : 		return (EOF);

	or	eax, -1

; 542  : 		}

	pop	ebp
	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 530  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 531  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 532  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 525  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 526  : 		return (static_cast<unsigned char>(_Ch));

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 527  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 520  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 521  : 		return (static_cast<char>(_Meta));

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 522  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 505  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 506  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 507  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 500  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 501  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 502  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 494  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 496  : 		}

	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 470  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 472  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 460  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 461  : #if _HAS_CXX17
; 462  : 		return (__builtin_strlen(_First));
; 463  : #else /* _HAS_CXX17 */
; 464  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 465  : #endif /* _HAS_CXX17 */
; 466  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	__vsprintf_s_l
	add	esp, 20					; 00000014H
	mov	DWORD PTR __Result$[ebp], eax

; 1846 :             __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1847 :             return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1848 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1497 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___stdio_common_vsprintf_s
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsprintf_s
	mov	DWORD PTR tv73[ebp], -1
	jmp	SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv73[ebp], ecx
$LN4@vsprintf_s:
	mov	eax, DWORD PTR tv73[ebp]

; 1503 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 644  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 616  : 		{	// return maximum value

	push	ebp
	mov	ebp, esp

; 617  : 		return (INT_MAX);

	mov	eax, 2147483647				; 7fffffffH

; 618  : 		}

	pop	ebp
	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 284  : 	{

	push	ebp
	mov	ebp, esp

; 285  : 	return (_CSTD sinf(_Xx));

	push	ecx
	movss	xmm0, DWORD PTR __Xx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sinf
	add	esp, 4

; 286  : 	}

	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 77   : 	{

	push	ebp
	mov	ebp, esp

; 78   : 	return (_CSTD cosf(_Xx));

	push	ecx
	movss	xmm0, DWORD PTR __Xx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_cosf
	add	esp, 4

; 79   : 	}

	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 92   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 85   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 86   :         __std_exception_destroy(&_Data);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_destroy
	add	esp, 4

; 87   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 67   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 70   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 62   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 61   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 63   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 64   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -12					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 55   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 54   :         : _Data()

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	mov	DWORD PTR __InitData$[ebp], eax
	mov	BYTE PTR __InitData$[ebp+4], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR __InitData$[ebp]
	push	edx
	call	___std_exception_copy
	add	esp, 8

; 58   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 863  :     {

	push	ebp
	mov	ebp, esp

; 864  :         return frexp((double)_X, _Y);

	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	add	esp, 12					; 0000000cH

; 865  :     }

	pop	ebp
	ret	0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 842  :     {

	push	ebp
	mov	ebp, esp

; 843  :         return fabs((double)_X);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8

; 844  :     }

	pop	ebp
	ret	0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 760  :             return (float)sqrt(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 761  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 749  :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 750  :             return (float)sin(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 751  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv74 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 744  :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 745  :             return (float)pow(_X, _Y);

	cvtss2sd xmm0, DWORD PTR __Y$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 746  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_powf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _ldexpf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_ldexpf	PROC						; COMDAT

; 707  :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 708  :         return (float)ldexp(_X, _Y);

	mov	eax, DWORD PTR __Y$[ebp]
	push	eax
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]

; 709  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_ldexpf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv71 = -4						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 649  :             return (float)cos(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 650  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

	push	ebp
	mov	ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 188  :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\michael mcnally\source\repos\final proj\src\mainsrc\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
